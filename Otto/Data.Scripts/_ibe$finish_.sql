

/******************************************************************************/
/***                           Unique Constraints                           ***/
/******************************************************************************/

ALTER TABLE MESSAGES ADD CONSTRAINT UNQ1_MESSAGES UNIQUE (FILE_NAME);


/******************************************************************************/
/***                              Primary Keys                              ***/
/******************************************************************************/

ALTER TABLE ACCOPERS ADD CONSTRAINT PK_ACCOPERS PRIMARY KEY (ACCOPER_ID);
ALTER TABLE ACCOUNTS ADD CONSTRAINT PK_ACCOUNTS PRIMARY KEY (ACCOUNT_ID);
ALTER TABLE ACCRESTS ADD CONSTRAINT PK_ACCRESTS PRIMARY KEY (ACCREST_ID);
ALTER TABLE ACTIONCODES ADD CONSTRAINT PK_ACTIONCODES PRIMARY KEY (ACTION_SIGN);
ALTER TABLE ACTIONCODE_CRITERIAS ADD CONSTRAINT PK_ACTIONCODE_CRITERIAS PRIMARY KEY (ACTIONCODE_SIGN, PARAM_NAME);
ALTER TABLE ACTIONCODE_PARAMS ADD CONSTRAINT PK_ACTIONCODE_PARAMS PRIMARY KEY (ACTION_SIGN, PARAM_NAME, PARAM_KIND);
ALTER TABLE ACTIONS ADD CONSTRAINT PK_ACTIONS PRIMARY KEY (ACTION_ID);
ALTER TABLE ACTIONTREE ADD CONSTRAINT PK_ACTIONTREE PRIMARY KEY (ACTIONTREEITEM_ID);
ALTER TABLE ACTIONTREE_CRITERIAS ADD CONSTRAINT PK_ACTIONTREE_CRITERIAS PRIMARY KEY (ACTIONTREEITEM_ID, PARAM_NAME);
ALTER TABLE ACTIONTREE_PARAMS ADD CONSTRAINT PK_ACTIONTREE_PARAMS PRIMARY KEY (ACTIONTREEITEM_ID, PARAM_NAME, PARAM_KIND);
ALTER TABLE ACTION_ATTRS ADD CONSTRAINT PK_ACTION_ATTRS PRIMARY KEY (OBJECT_ID, ATTR_ID);
ALTER TABLE ADRESSES ADD CONSTRAINT PK_ADRESSES PRIMARY KEY (ADRESS_ID);
ALTER TABLE ATTRS ADD CONSTRAINT PK_ATTRS PRIMARY KEY (ATTR_ID);
ALTER TABLE BONUSES ADD CONSTRAINT PK_BONUSES PRIMARY KEY (BONUS_ID);
ALTER TABLE BUILDS ADD CONSTRAINT PK_BUILDS PRIMARY KEY (BUILD);
ALTER TABLE CALCPOINTS ADD CONSTRAINT PK_CALCPOINTS PRIMARY KEY (CALCPOINT_ID);
ALTER TABLE CATALOG2PLUGIN ADD CONSTRAINT PK_CATALOG2PLUGIN PRIMARY KEY (CATALOG_ID, PLUGIN_ID);
ALTER TABLE CATALOGS ADD CONSTRAINT PK_CATALOGS PRIMARY KEY (CATALOG_ID);
ALTER TABLE CLIENTNOTIFIES ADD CONSTRAINT PK_CLIENTNOTIFIES PRIMARY KEY (CLIENTNOTIFY_ID);
ALTER TABLE CLIENTS ADD CONSTRAINT PK_CLIENTS PRIMARY KEY (CLIENT_ID);
ALTER TABLE CLIENT_ATTRS ADD CONSTRAINT PK_CLIENT_ATTRS PRIMARY KEY (OBJECT_ID, ATTR_ID);
ALTER TABLE COUNTERS ADD CONSTRAINT PK_COUNTERS PRIMARY KEY (OBJECT_SIGN, ATTR_SIGN, OBJECT_ID);
ALTER TABLE DEALERNOTIFIES ADD CONSTRAINT PK_DEALERNOTIFIES PRIMARY KEY (DEALERNOTIFY_ID);
ALTER TABLE DEALERORDERS ADD CONSTRAINT PK_DEALERORDERS PRIMARY KEY (PRODUCT_ID, DEALER_ID);
ALTER TABLE DEALERS ADD CONSTRAINT PK_DEALERS PRIMARY KEY (DEALER_ID);
ALTER TABLE DETECTOR ADD CONSTRAINT PK_DETECTOR PRIMARY KEY (OBJECT_SIGN, OBJECT_ID, PARAM_SIGN);
ALTER TABLE EVENTCODES ADD CONSTRAINT PK_EVENTCODES PRIMARY KEY (EVENT_SIGN);
ALTER TABLE EVENTS ADD CONSTRAINT PK_EVENTS PRIMARY KEY (EVENT_ID);
ALTER TABLE FLAGS ADD CONSTRAINT PK_FLAGS PRIMARY KEY (FLAG_SIGN);
ALTER TABLE FLAGS2STATUSES ADD CONSTRAINT PK_FLAGS2STATUSES PRIMARY KEY (STATUS_ID, FLAG_SIGN);
ALTER TABLE LOGS ADD CONSTRAINT PK_LOGS PRIMARY KEY (LOG_ID);
ALTER TABLE MAGAZINES ADD CONSTRAINT PK_MAGAZINES PRIMARY KEY (MAGAZINE_ID);
ALTER TABLE MESSAGES ADD CONSTRAINT PK_MESSAGES PRIMARY KEY (MESSAGE_ID);
ALTER TABLE MESSAGE_ATTRS ADD CONSTRAINT PK_MESSAGE_ATTRS PRIMARY KEY (OBJECT_ID, ATTR_ID);
ALTER TABLE MONEYBACKS ADD CONSTRAINT PK_MONEYBACKS PRIMARY KEY (MONEYBACK_ID);
ALTER TABLE MONEYBACK_ATTRS ADD CONSTRAINT PK_MONEYBACK_ATTRS_1 PRIMARY KEY (OBJECT_ID, ATTR_ID);
ALTER TABLE NOTIFIES ADD CONSTRAINT PK_NOTIFIES PRIMARY KEY (NOTIFY_ID);
ALTER TABLE OBJECTS ADD CONSTRAINT PK_OBJECTS PRIMARY KEY (OBJECT_SIGN);
ALTER TABLE ORDERITEMS ADD CONSTRAINT PK_ORDERITEMS PRIMARY KEY (ORDERITEM_ID);
ALTER TABLE ORDERITEM_ATTRS ADD CONSTRAINT PK_ORDERITEM_ATTRS PRIMARY KEY (OBJECT_ID, ATTR_ID);
ALTER TABLE ORDERMONEYS ADD CONSTRAINT PK_ORDERMONEYS PRIMARY KEY (ORDERMONEY_ID);
ALTER TABLE ORDERS ADD CONSTRAINT PK_ORDERS PRIMARY KEY (ORDER_ID);
ALTER TABLE ORDERTAXS ADD CONSTRAINT PK_ORDERTAXS PRIMARY KEY (ORDERTAX_ID);
ALTER TABLE ORDER_ATTRS ADD CONSTRAINT PK_ORDER_ATTRS PRIMARY KEY (OBJECT_ID, ATTR_ID);
ALTER TABLE PACKLISTS ADD CONSTRAINT PK_PACKLISTS PRIMARY KEY (PACKLIST_NO);
ALTER TABLE PARAMACTIONS ADD CONSTRAINT PK_PARAMACTIONS PRIMARY KEY (PARAM_KIND, PARAM_ACTION);
ALTER TABLE PARAMHEADS ADD CONSTRAINT PK_PARAMHEADS PRIMARY KEY (PARAM_ID);
ALTER TABLE PARAMKINDS ADD CONSTRAINT PK_PARAMKINDS PRIMARY KEY (PARAM_KIND);
ALTER TABLE PARAMS ADD CONSTRAINT PK_PARAMS PRIMARY KEY (PARAM_NAME, PARAM_ID);
ALTER TABLE PAYMENTS ADD CONSTRAINT PK_PAYMENTS PRIMARY KEY (PAYMENT_ID);
ALTER TABLE PLACES ADD CONSTRAINT PK_PLACES PRIMARY KEY (PLACE_ID);
ALTER TABLE PLACETYPES ADD CONSTRAINT PK_PLACETYPES PRIMARY KEY (PLACETYPE_CODE);
ALTER TABLE PLUGINS ADD CONSTRAINT PK_PLUGINS PRIMARY KEY (PLUGIN_ID);
ALTER TABLE PLUGIN_PARAMS ADD CONSTRAINT PK_PLUGIN_PARAMS PRIMARY KEY (PLUGIN_ID, PARAM_SIGN);
ALTER TABLE PORTS ADD CONSTRAINT PK_PORTS PRIMARY KEY (PORT_ID);
ALTER TABLE PRODUCT2TAXPLAN ADD CONSTRAINT PK_PRODUCT2TAXPLAN PRIMARY KEY (PRODUCT_ID, TAXPLAN_ID);
ALTER TABLE PRODUCTS ADD CONSTRAINT PK_PRODUCTS PRIMARY KEY (PRODUCT_ID);
ALTER TABLE PRODUCT_ATTRS ADD CONSTRAINT PK_PRODUCT_ATTRS PRIMARY KEY (OBJECT_ID, ATTR_ID);
ALTER TABLE RECODES ADD CONSTRAINT PK_RECODES PRIMARY KEY (OBJECT_SIGN, ATTR_SIGN, ORIGINAL_VALUE);
ALTER TABLE RECODE_MASKS ADD CONSTRAINT PK_RECODE_MASKS PRIMARY KEY (OBJECT_SIGN, ATTR_SIGN, SEARCH_MASK);
ALTER TABLE SESSIONS ADD CONSTRAINT PK_SESSIONS PRIMARY KEY (SESSION_ID);
ALTER TABLE SETTINGS ADD CONSTRAINT PK_SETTINGS PRIMARY KEY (SETTING_ID);
ALTER TABLE SETTINGSIGNS ADD CONSTRAINT PK_SETTINGSIGNS PRIMARY KEY (SETTING_SIGN);
ALTER TABLE STATUSES ADD CONSTRAINT PK_STATUSES PRIMARY KEY (STATUS_ID);
ALTER TABLE STATUS_RULES ADD CONSTRAINT PK_STATUS_RULES PRIMARY KEY (OLD_STATUS_ID, NEW_STATUS_ID);
ALTER TABLE STREETTYPES ADD CONSTRAINT PK_STREETTYPES PRIMARY KEY (STREETTYPE_CODE);
ALTER TABLE TAXPLANS ADD CONSTRAINT PK_TAXPLANS PRIMARY KEY (TAXPLAN_ID);
ALTER TABLE TAXRATES ADD CONSTRAINT PK_TAXRATES PRIMARY KEY (TAXRATE_ID);
ALTER TABLE TAXRATE_ATTRS ADD CONSTRAINT PK_TAXRATE_ATTRS PRIMARY KEY (OBJECT_ID, ATTR_ID);
ALTER TABLE TAXSERVS ADD CONSTRAINT PK_TAXSERVS PRIMARY KEY (TAXSERV_ID);
ALTER TABLE TEMPLATES ADD CONSTRAINT PK_TEMPLATES PRIMARY KEY (TEMPLATE_ID);
ALTER TABLE USERS ADD CONSTRAINT PK_USERS PRIMARY KEY (USER_SIGN);
ALTER TABLE VALUTES ADD CONSTRAINT PK_VALUTES PRIMARY KEY (VALUTE_CODE);
ALTER TABLE VENDORS ADD CONSTRAINT PK_VENDORS PRIMARY KEY (VENDOR_ID);
ALTER TABLE WAYS ADD CONSTRAINT PK_WAYS PRIMARY KEY (WAY_ID);


/******************************************************************************/
/***                              Foreign Keys                              ***/
/******************************************************************************/

ALTER TABLE ACCOPERS ADD CONSTRAINT FK_ACCOPERS_ACCOUNT FOREIGN KEY (ACCOUNT_ID) REFERENCES ACCOUNTS (ACCOUNT_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE ACCOPERS ADD CONSTRAINT FK_ACCOPERS_ORDER FOREIGN KEY (ORDER_ID) REFERENCES ORDERS (ORDER_ID) ON UPDATE CASCADE;
ALTER TABLE ACCOUNTS ADD CONSTRAINT FK_ACCOUNTS_STATUS FOREIGN KEY (STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE CASCADE;
ALTER TABLE ACCRESTS ADD CONSTRAINT FK_ACCRESTS_ACCOUNT FOREIGN KEY (ACCOUNT_ID) REFERENCES ACCOUNTS (ACCOUNT_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE ACTIONCODES ADD CONSTRAINT FK_ACTIONCODES_OBJECT FOREIGN KEY (OBJECT_SIGN) REFERENCES OBJECTS (OBJECT_SIGN) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE ACTIONCODE_CRITERIAS ADD CONSTRAINT FK_ACTIONCODE_CRITERIAS_ACTION FOREIGN KEY (ACTIONCODE_SIGN) REFERENCES ACTIONCODES (ACTION_SIGN) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE ACTIONCODE_CRITERIAS ADD CONSTRAINT FK_ACTIONCODE_CRITERIAS_PRMACT FOREIGN KEY (PARAM_KIND, PARAM_ACTION) REFERENCES PARAMACTIONS (PARAM_KIND, PARAM_ACTION) ON UPDATE CASCADE;
ALTER TABLE ACTIONCODE_PARAMS ADD CONSTRAINT FK_ACTIONCODE_PARAMS_ACTION FOREIGN KEY (ACTION_SIGN) REFERENCES ACTIONCODES (ACTION_SIGN) ON DELETE CASCADE ON UPDATE CASCADE
  USING INDEX FK_ACTIONCODE_PARAMS_1;
ALTER TABLE ACTIONCODE_PARAMS ADD CONSTRAINT FK_ACTIONCODE_PARAMS_PARAMKIND FOREIGN KEY (PARAM_KIND) REFERENCES PARAMKINDS (PARAM_KIND) ON UPDATE CASCADE;
ALTER TABLE ACTIONS ADD CONSTRAINT FK_ACTIONS_ACTIONCODE FOREIGN KEY (ACTION_SIGN) REFERENCES ACTIONCODES (ACTION_SIGN) ON UPDATE CASCADE;
ALTER TABLE ACTIONTREE ADD CONSTRAINT FK_ACTIONTREE_ACTION FOREIGN KEY (ACTION_SIGN) REFERENCES ACTIONCODES (ACTION_SIGN) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE ACTIONTREE ADD CONSTRAINT FK_ACTIONTREE_CHILD FOREIGN KEY (CHILD_ACTION) REFERENCES ACTIONCODES (ACTION_SIGN) ON UPDATE CASCADE;
ALTER TABLE ACTIONTREE_CRITERIAS ADD CONSTRAINT FK_ACTTREECRIT_ACTTIONTREEITEM FOREIGN KEY (ACTIONTREEITEM_ID) REFERENCES ACTIONTREE (ACTIONTREEITEM_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE ACTIONTREE_CRITERIAS ADD CONSTRAINT FK_ACTTREECRIT_PARAMACTION FOREIGN KEY (PARAM_KIND, PARAM_ACTION) REFERENCES PARAMACTIONS (PARAM_KIND, PARAM_ACTION) ON UPDATE CASCADE;
ALTER TABLE ACTIONTREE_PARAMS ADD CONSTRAINT FK_ACTIONTREE_PARAMS_ACTIONTREE FOREIGN KEY (ACTIONTREEITEM_ID) REFERENCES ACTIONTREE (ACTIONTREEITEM_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE ACTIONTREE_PARAMS ADD CONSTRAINT FK_ACTIONTREE_PARAMS_PARAMKIND FOREIGN KEY (PARAM_KIND) REFERENCES PARAMKINDS (PARAM_KIND) ON UPDATE CASCADE;
ALTER TABLE ACTION_ATTRS ADD CONSTRAINT FK_ACTION_ATTRS_ACTION FOREIGN KEY (OBJECT_ID) REFERENCES ACTIONS (ACTION_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE ACTION_ATTRS ADD CONSTRAINT FK_ACTION_ATTRS_ATTR FOREIGN KEY (ATTR_ID) REFERENCES ATTRS (ATTR_ID) ON UPDATE CASCADE;
ALTER TABLE ADRESSES ADD CONSTRAINT FK_ADRESSES_CLIENT FOREIGN KEY (CLIENT_ID) REFERENCES CLIENTS (CLIENT_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE ADRESSES ADD CONSTRAINT FK_ADRESSES_PLACE FOREIGN KEY (PLACE_ID) REFERENCES PLACES (PLACE_ID) ON UPDATE CASCADE;
ALTER TABLE ADRESSES ADD CONSTRAINT FK_ADRESSES_STATUS FOREIGN KEY (STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE CASCADE;
ALTER TABLE ADRESSES ADD CONSTRAINT FK_ADRESSES_STREETTYPE FOREIGN KEY (STREETTYPE_CODE) REFERENCES STREETTYPES (STREETTYPE_CODE) ON UPDATE CASCADE;
ALTER TABLE ATTRS ADD CONSTRAINT FK_ATTRS_OBJECT FOREIGN KEY (OBJECT_SIGN) REFERENCES OBJECTS (OBJECT_SIGN) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE BONUSES ADD CONSTRAINT FK_BONUSES_CLIENT_ID FOREIGN KEY (CLIENT_ID) REFERENCES CLIENTS (CLIENT_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE BONUSES ADD CONSTRAINT FK_BONUSES_ORDERTAX_ID FOREIGN KEY (ORDERTAX_ID) REFERENCES ORDERTAXS (ORDERTAX_ID) ON DELETE SET NULL ON UPDATE CASCADE;
ALTER TABLE BONUSES ADD CONSTRAINT FK_BONUSES_STATUS_ID FOREIGN KEY (STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE CASCADE;
ALTER TABLE BONUSES ADD CONSTRAINT FK_BONUSES_TAXSERV_ID FOREIGN KEY (TAXSERV_ID) REFERENCES TAXSERVS (TAXSERV_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE CALCPOINTS ADD CONSTRAINT FK_CALCPOINTS_OBJECT FOREIGN KEY (OBJECT_SIGN) REFERENCES OBJECTS (OBJECT_SIGN) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE CALCPOINTS ADD CONSTRAINT FK_CALCPOINTS_OBJECTSTATUS FOREIGN KEY (OBJECT_STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE CASCADE;
ALTER TABLE CATALOG2PLUGIN ADD CONSTRAINT FK_CATALOG2PLUGIN_CATALOG FOREIGN KEY (CATALOG_ID) REFERENCES CATALOGS (CATALOG_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE CATALOG2PLUGIN ADD CONSTRAINT FK_CATALOG2PLUGIN_PLUGIN FOREIGN KEY (PLUGIN_ID) REFERENCES PLUGINS (PLUGIN_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE CATALOGS ADD CONSTRAINT FK_CATALOGS_STATUS FOREIGN KEY (STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE CASCADE;
ALTER TABLE CATALOGS ADD CONSTRAINT FK_CATALOGS_VENDOR FOREIGN KEY (VENDOR_ID) REFERENCES VENDORS (VENDOR_ID) ON UPDATE CASCADE;
ALTER TABLE CLIENTNOTIFIES ADD CONSTRAINT FK_CLIENTNOTIFIES_CLIENT FOREIGN KEY (CLIENT_ID) REFERENCES CLIENTS (CLIENT_ID) ON DELETE CASCADE ON UPDATE CASCADE
  USING INDEX FK_CLIENTNOTIFIES_CLIENT_ID;
ALTER TABLE CLIENTNOTIFIES ADD CONSTRAINT FK_CLIENTNOTIFIES_STATUS FOREIGN KEY (STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE SET DEFAULT;
ALTER TABLE CLIENTS ADD CONSTRAINT FK_CLIENTS_ACCOUNT FOREIGN KEY (ACCOUNT_ID) REFERENCES ACCOUNTS (ACCOUNT_ID) ON UPDATE CASCADE;
ALTER TABLE CLIENTS ADD CONSTRAINT FK_CLIENTS_STATUS FOREIGN KEY (STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE CASCADE;
ALTER TABLE CLIENT_ATTRS ADD CONSTRAINT FK_CLIENT_ATTRS_ATTR FOREIGN KEY (ATTR_ID) REFERENCES ATTRS (ATTR_ID) ON UPDATE CASCADE;
ALTER TABLE CLIENT_ATTRS ADD CONSTRAINT FK_CLIENT_ATTRS_OBJECT FOREIGN KEY (OBJECT_ID) REFERENCES CLIENTS (CLIENT_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE COUNTERS ADD CONSTRAINT FK_COUNTERS_OBJECT FOREIGN KEY (OBJECT_SIGN) REFERENCES OBJECTS (OBJECT_SIGN) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE DEALERNOTIFIES ADD CONSTRAINT FK_DEALERNOTIFIES_DEALER FOREIGN KEY (DEALER_ID) REFERENCES DEALERS (DEALER_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE DEALERNOTIFIES ADD CONSTRAINT FK_DEALERNOTIFIES_MESSAGE FOREIGN KEY (MESSAGE_ID) REFERENCES MESSAGES (MESSAGE_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE DEALERNOTIFIES ADD CONSTRAINT FK_DEALERNOTIFIES_STATUS FOREIGN KEY (STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE CASCADE;
ALTER TABLE DEALERORDERS ADD CONSTRAINT FK_DEALERORDERS_DEALER FOREIGN KEY (DEALER_ID) REFERENCES DEALERS (DEALER_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE DEALERORDERS ADD CONSTRAINT FK_DEALERORDERS_PRODUCT FOREIGN KEY (PRODUCT_ID) REFERENCES PRODUCTS (PRODUCT_ID) ON UPDATE CASCADE;
ALTER TABLE EVENTCODES ADD CONSTRAINT FK_EVENTCODES_OBJECT FOREIGN KEY (OBJECT_SIGN) REFERENCES OBJECTS (OBJECT_SIGN) ON UPDATE CASCADE;
ALTER TABLE EVENTS ADD CONSTRAINT FK_EVENTS_EVENT FOREIGN KEY (EVENT_SIGN) REFERENCES EVENTCODES (EVENT_SIGN) ON UPDATE CASCADE;
ALTER TABLE EVENTS ADD CONSTRAINT FK_EVENTS_STATUS FOREIGN KEY (STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE CASCADE;
ALTER TABLE FLAGS2STATUSES ADD CONSTRAINT FK_FLAGS2STATUSES_FLAG FOREIGN KEY (FLAG_SIGN) REFERENCES FLAGS (FLAG_SIGN) ON UPDATE CASCADE;
ALTER TABLE FLAGS2STATUSES ADD CONSTRAINT FK_FLAGS2STATUSES_STATUS FOREIGN KEY (STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE MAGAZINES ADD CONSTRAINT FK_MAGAZINES_CATALOG FOREIGN KEY (CATALOG_ID) REFERENCES CATALOGS (CATALOG_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE MESSAGES ADD CONSTRAINT FK_MESSAGES_PORT FOREIGN KEY (PORT_ID) REFERENCES PORTS (PORT_ID) ON UPDATE CASCADE;
ALTER TABLE MESSAGES ADD CONSTRAINT FK_MESSAGES_STATUS FOREIGN KEY (STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE CASCADE;
ALTER TABLE MESSAGES ADD CONSTRAINT FK_MESSAGES_TEMPLATE FOREIGN KEY (TEMPLATE_ID) REFERENCES TEMPLATES (TEMPLATE_ID) ON UPDATE CASCADE;
ALTER TABLE MESSAGE_ATTRS ADD CONSTRAINT FK_MESSAGE_ATTRS_ATTR FOREIGN KEY (ATTR_ID) REFERENCES ATTRS (ATTR_ID) ON UPDATE CASCADE;
ALTER TABLE MESSAGE_ATTRS ADD CONSTRAINT FK_MESSAGE_ATTRS_MESSAGE FOREIGN KEY (OBJECT_ID) REFERENCES MESSAGES (MESSAGE_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE MONEYBACKS ADD CONSTRAINT FK_MONEYBACKS_ACCOUNT FOREIGN KEY (ACCOUNT_ID) REFERENCES ACCOUNTS (ACCOUNT_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE MONEYBACKS ADD CONSTRAINT FK_MONEYBACKS_ORDER FOREIGN KEY (ORDER_ID) REFERENCES ORDERS (ORDER_ID) ON UPDATE CASCADE;
ALTER TABLE MONEYBACKS ADD CONSTRAINT FK_MONEYBACKS_STATUS FOREIGN KEY (STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE CASCADE;
ALTER TABLE MONEYBACK_ATTRS ADD CONSTRAINT FK_MONEYBACK_ATTRS_ATTR FOREIGN KEY (ATTR_ID) REFERENCES ATTRS (ATTR_ID) ON UPDATE CASCADE;
ALTER TABLE MONEYBACK_ATTRS ADD CONSTRAINT FK_MONEYBACK_ATTRS_BONEYBACK FOREIGN KEY (OBJECT_ID) REFERENCES MONEYBACKS (MONEYBACK_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE NOTIFIES ADD CONSTRAINT FK_NOTIFIES_MESSAGE FOREIGN KEY (MESSAGE_ID) REFERENCES MESSAGES (MESSAGE_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE ORDERHISTORY ADD CONSTRAINT FK_ORDERHISTORY_ORDER FOREIGN KEY (ORDER_ID) REFERENCES ORDERS (ORDER_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE ORDERHISTORY ADD CONSTRAINT FK_ORDERHISTORY_STATE FOREIGN KEY (STATE_ID) REFERENCES STATUSES (STATUS_ID) ON DELETE SET NULL ON UPDATE CASCADE;
ALTER TABLE ORDERHISTORY ADD CONSTRAINT FK_ORDERHISTORY_STATUS FOREIGN KEY (STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE ORDERITEMS ADD CONSTRAINT FK_ORDERITEMS_ORDER FOREIGN KEY (ORDER_ID) REFERENCES ORDERS (ORDER_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE ORDERITEMS ADD CONSTRAINT FK_ORDERITEMS_RETURN FOREIGN KEY (RETURN_REESTR_ID) REFERENCES MESSAGES (MESSAGE_ID) ON DELETE SET NULL ON UPDATE CASCADE;
ALTER TABLE ORDERITEMS ADD CONSTRAINT FK_ORDERITEMS_STATUS FOREIGN KEY (STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE CASCADE;
ALTER TABLE ORDERITEM_ATTRS ADD CONSTRAINT FK_ORDERITEM_ATTRS_ATTR FOREIGN KEY (ATTR_ID) REFERENCES ATTRS (ATTR_ID) ON UPDATE CASCADE;
ALTER TABLE ORDERITEM_ATTRS ADD CONSTRAINT FK_ORDERITEM_ATTRS_OBJECT FOREIGN KEY (OBJECT_ID) REFERENCES ORDERITEMS (ORDERITEM_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE ORDERMONEYS ADD CONSTRAINT FK_ORDERMONEYS_ACCOUNT FOREIGN KEY (ACCOUNT_ID) REFERENCES ACCOUNTS (ACCOUNT_ID) ON UPDATE CASCADE;
ALTER TABLE ORDERMONEYS ADD CONSTRAINT FK_ORDERMONEYS_ORDER FOREIGN KEY (ORDER_ID) REFERENCES ORDERS (ORDER_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE ORDERMONEYS ADD CONSTRAINT FK_ORDERMONEYS_STATUS FOREIGN KEY (STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE CASCADE;
ALTER TABLE ORDERS ADD CONSTRAINT FK_ORDERS_ACCOUNT FOREIGN KEY (ACCOUNT_ID) REFERENCES ACCOUNTS (ACCOUNT_ID) ON UPDATE CASCADE;
ALTER TABLE ORDERS ADD CONSTRAINT FK_ORDERS_ADRESS FOREIGN KEY (ADRESS_ID) REFERENCES ADRESSES (ADRESS_ID) ON UPDATE CASCADE;
ALTER TABLE ORDERS ADD CONSTRAINT FK_ORDERS_CLIENT FOREIGN KEY (CLIENT_ID) REFERENCES CLIENTS (CLIENT_ID) ON UPDATE CASCADE;
ALTER TABLE ORDERS ADD CONSTRAINT FK_ORDERS_PRODUCT FOREIGN KEY (PRODUCT_ID) REFERENCES PRODUCTS (PRODUCT_ID) ON UPDATE CASCADE;
ALTER TABLE ORDERS ADD CONSTRAINT FK_ORDERS_STATE FOREIGN KEY (STATE_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE CASCADE;
ALTER TABLE ORDERS ADD CONSTRAINT FK_ORDERS_STATUS FOREIGN KEY (STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE CASCADE;
ALTER TABLE ORDERS ADD CONSTRAINT FK_ORDERS_TAXPLAN FOREIGN KEY (TAXPLAN_ID) REFERENCES TAXPLANS (TAXPLAN_ID) ON UPDATE CASCADE;
ALTER TABLE ORDERTAXS ADD CONSTRAINT FK_ORDERTAXS_ORDER FOREIGN KEY (ORDER_ID) REFERENCES ORDERS (ORDER_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE ORDERTAXS ADD CONSTRAINT FK_ORDERTAXS_STATUS FOREIGN KEY (STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE CASCADE;
ALTER TABLE ORDERTAXS ADD CONSTRAINT FK_ORDERTAXS_TAXRATE FOREIGN KEY (TAXRATE_ID) REFERENCES TAXRATES (TAXRATE_ID) ON UPDATE CASCADE;
ALTER TABLE ORDER_ATTRS ADD CONSTRAINT FK_ORDER_ATTRS_ATTR FOREIGN KEY (ATTR_ID) REFERENCES ATTRS (ATTR_ID) ON UPDATE CASCADE;
ALTER TABLE ORDER_ATTRS ADD CONSTRAINT FK_ORDER_ATTRS_OBJECT FOREIGN KEY (OBJECT_ID) REFERENCES ORDERS (ORDER_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE PARAMHEADS ADD CONSTRAINT FK_PARAMHEADS_ACTION FOREIGN KEY (ACTION_ID) REFERENCES ACTIONS (ACTION_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE PARAMHEADS ADD CONSTRAINT FK_PARAMHEADS_OBJECT FOREIGN KEY (OBJECT_SIGN) REFERENCES OBJECTS (OBJECT_SIGN) ON UPDATE CASCADE;
ALTER TABLE PARAMS ADD CONSTRAINT FK_PARAMS_PARAM FOREIGN KEY (PARAM_ID) REFERENCES PARAMHEADS (PARAM_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE PAYMENTS ADD CONSTRAINT FK_PAYMENTS_MESSAGE FOREIGN KEY (MESSAGE_ID) REFERENCES MESSAGES (MESSAGE_ID) ON DELETE SET NULL ON UPDATE CASCADE;
ALTER TABLE PAYMENTS ADD CONSTRAINT FK_PAYMENTS_STATUS FOREIGN KEY (STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE CASCADE;
ALTER TABLE PLACES ADD CONSTRAINT FK_PLACES_OWNER FOREIGN KEY (OWNER_PLACE) REFERENCES PLACES (PLACE_ID) ON UPDATE CASCADE;
ALTER TABLE PLACES ADD CONSTRAINT FK_PLACES_PLACETYPE FOREIGN KEY (PLACETYPE_CODE) REFERENCES PLACETYPES (PLACETYPE_CODE) ON UPDATE CASCADE;
ALTER TABLE PLACES ADD CONSTRAINT FK_PLACES_STATUS FOREIGN KEY (STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE CASCADE;
ALTER TABLE PLUGIN_PARAMS ADD CONSTRAINT FK_PLUGIN_PARAMS_PLUGIN FOREIGN KEY (PLUGIN_ID) REFERENCES PLUGINS (PLUGIN_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE PORT2TEMPLATE ADD CONSTRAINT FK_PORT2TEMPLATE_PORT FOREIGN KEY (PORT_ID) REFERENCES PORTS (PORT_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE PORT2TEMPLATE ADD CONSTRAINT FK_PORT2TEMPLATE_TEMPLATE FOREIGN KEY (TEMPLATE_ID) REFERENCES TEMPLATES (TEMPLATE_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE PRODUCT2TAXPLAN ADD CONSTRAINT FK_PRODUCT2TAXPLAN_PRODUCT_ID FOREIGN KEY (PRODUCT_ID) REFERENCES PRODUCTS (PRODUCT_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE PRODUCT2TAXPLAN ADD CONSTRAINT FK_PRODUCT2TAXPLAN_TAXPLAN_ID FOREIGN KEY (TAXPLAN_ID) REFERENCES TAXPLANS (TAXPLAN_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE PRODUCTS ADD CONSTRAINT FK_PRODUCTS_STATUS FOREIGN KEY (STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE CASCADE;
ALTER TABLE PRODUCTS ADD CONSTRAINT FK_PRODUCTS_VENDOR FOREIGN KEY (VENDOR_ID) REFERENCES VENDORS (VENDOR_ID) ON UPDATE CASCADE;
ALTER TABLE PRODUCT_ATTRS ADD CONSTRAINT FK_PRODUCT_ATTRS_ATTR FOREIGN KEY (ATTR_ID) REFERENCES ATTRS (ATTR_ID) ON UPDATE CASCADE;
ALTER TABLE PRODUCT_ATTRS ADD CONSTRAINT FK_PRODUCT_ATTRS_PRODUCT FOREIGN KEY (OBJECT_ID) REFERENCES PRODUCTS (PRODUCT_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE RECODES ADD CONSTRAINT FK_RECODES_OBJECT FOREIGN KEY (OBJECT_SIGN) REFERENCES OBJECTS (OBJECT_SIGN) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE RECODE_MASKS ADD CONSTRAINT FK_RECODE_MASKS_OBJECT FOREIGN KEY (OBJECT_SIGN) REFERENCES OBJECTS (OBJECT_SIGN) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE SETTINGS ADD CONSTRAINT FK_SETTINGS_SETTINGSIGN FOREIGN KEY (SETTING_SIGN) REFERENCES SETTINGSIGNS (SETTING_SIGN) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE STATUSES ADD CONSTRAINT FK_STATUSES_ACTION FOREIGN KEY (ACTION_SIGN) REFERENCES ACTIONCODES (ACTION_SIGN) ON UPDATE CASCADE;
ALTER TABLE STATUSES ADD CONSTRAINT FK_STATUSES_OBJECT FOREIGN KEY (OBJECT_SIGN) REFERENCES OBJECTS (OBJECT_SIGN) ON UPDATE CASCADE;
ALTER TABLE STATUS_RULES ADD CONSTRAINT FK_STATUS_RULES_ACTIONCODE FOREIGN KEY (ACTION_SIGN) REFERENCES ACTIONCODES (ACTION_SIGN) ON DELETE SET NULL ON UPDATE CASCADE;
ALTER TABLE STATUS_RULES ADD CONSTRAINT FK_STATUS_RULES_NEWSTATUS FOREIGN KEY (NEW_STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE CASCADE;
ALTER TABLE STATUS_RULES ADD CONSTRAINT FK_STATUS_RULES_OLDSTATUS FOREIGN KEY (OLD_STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE TAXPLANS ADD CONSTRAINT FK_TAXPLANS_STATUS FOREIGN KEY (STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE CASCADE;
ALTER TABLE TAXRATES ADD CONSTRAINT FK_TAXRATES_STATUS FOREIGN KEY (STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE CASCADE;
ALTER TABLE TAXRATES ADD CONSTRAINT FK_TAXRATES_TAXPLAN FOREIGN KEY (TAXPLAN_ID) REFERENCES TAXPLANS (TAXPLAN_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE TAXRATES ADD CONSTRAINT FK_TAXRATES_TAXSERV FOREIGN KEY (TAXSERV_ID) REFERENCES TAXSERVS (TAXSERV_ID) ON DELETE CASCADE ON UPDATE CASCADE
  USING INDEX FK_TAXRATES_SERVS;
ALTER TABLE TAXRATE_ATTRS ADD CONSTRAINT FK_TAXRATE_ATTRS_ATTR FOREIGN KEY (ATTR_ID) REFERENCES ATTRS (ATTR_ID) ON UPDATE CASCADE;
ALTER TABLE TAXRATE_ATTRS ADD CONSTRAINT FK_TAXRATE_ATTRS_TAXRATE FOREIGN KEY (OBJECT_ID) REFERENCES TAXRATES (TAXRATE_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE TAXSERVS ADD CONSTRAINT FK_TAXSERVS_CALCPOINT FOREIGN KEY (CALCPOINT_ID) REFERENCES CALCPOINTS (CALCPOINT_ID) ON UPDATE CASCADE;
ALTER TABLE TAXSERVS ADD CONSTRAINT FK_TAXSERVS_STATUS FOREIGN KEY (STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE CASCADE;
ALTER TABLE WAYS ADD CONSTRAINT FK_WAYS_PORT FOREIGN KEY (PORT_ID) REFERENCES PORTS (PORT_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE WAYS ADD CONSTRAINT FK_WAYS_STATUS FOREIGN KEY (STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE CASCADE;


/******************************************************************************/
/***                                Indices                                 ***/
/******************************************************************************/

CREATE DESCENDING INDEX IK_ORDERS_CREATE_DTM ON ORDERS (CREATE_DTM);
CREATE INDEX SEARCHES_IDX1 ON SEARCHES (SEARCH_ID, OBJECT_ID);
CREATE INDEX IDX_TMP_SEARCHES_1 ON TMP_SEARCHES (SEARCH_ID, OBJECT_ID);


/******************************************************************************/
/***                                Triggers                                ***/
/******************************************************************************/


SET TERM ^ ;



/******************************************************************************/
/***                        Database event triggers                         ***/
/******************************************************************************/



/* Trigger: CLOSE_SESSION */
CREATE OR ALTER TRIGGER CLOSE_SESSION
ACTIVE ON DISCONNECT POSITION 0
AS
  declare variable v_max_param_id id_param;
begin
--  in autonomous transaction do
  update sessions s
    set s.finish_dtm = current_timestamp
    where s.session_id = current_connection;

  update messages m
    set busy_id = null
    where busy_id = current_connection;

  delete from sessions s
    where s.session_id = current_connection;


end
^

/******************************************************************************/
/***                          Triggers for tables                           ***/
/******************************************************************************/



/* Trigger: ACCOPERS_AI0 */
CREATE OR ALTER TRIGGER ACCOPERS_AI0 FOR ACCOPERS
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 0
AS
begin
  update accounts a
  set a.rest_eur = (select coalesce(sum(ar.rest_eur), 0)
    from accrests ar
    where ar.account_id = new.account_id)
  where a.account_id = new.account_id;
end
^

/* Trigger: ACCOPERS_BI */
CREATE OR ALTER TRIGGER ACCOPERS_BI FOR ACCOPERS
ACTIVE BEFORE INSERT POSITION 0
as
declare variable v_accrest_id id_accrest;
declare variable v_amount_eur money_eur;
begin
  if (new.accoper_id is null) then
    new.accoper_id = gen_id(seq_accoper_id,1);
  new.accoper_dtm = current_timestamp;

  if (new.byr2eur is null) then
    select cast(o_value as integer)
      from setting_get('BYR2EUR', new.accoper_dtm)
      into new.byr2eur;

  if (new.amount_byr is null) then
    select o_money_byr from money_eur2byr(new.amount_eur, new.byr2eur) into new.amount_byr;

  if (new.amount_eur is null) then
    new.amount_eur = (0.00 + new.amount_byr) / new.byr2eur;

  v_amount_eur = new.amount_eur;

  select ar.accrest_id
    from accrests ar
    where ar.account_id = new.account_id
      and ar.byr2eur = new.byr2eur
    into :v_accrest_id;

  if (:v_accrest_id is null) then
    insert into accrests (account_id, byr2eur, rest_eur)
      values(new.account_id, new.byr2eur, new.amount_eur)
      returning accrest_id
      into new.accrest_id;
  else
    update accrests ar
      set ar.rest_eur = ar.rest_eur + new.amount_eur
      where ar.accrest_id = :v_accrest_id
        and ar.byr2eur = new.byr2eur
      returning accrest_id
      into new.accrest_id;
end
^

/* Trigger: ACCOPERS_BU0 */
CREATE OR ALTER TRIGGER ACCOPERS_BU0 FOR ACCOPERS
ACTIVE BEFORE UPDATE POSITION 0
AS
begin
  select o_money_byr from money_eur2byr(new.amount_eur, new.byr2eur) into new.amount_byr;
end
^

/* Trigger: ACCOUNTS_BI0 */
CREATE OR ALTER TRIGGER ACCOUNTS_BI0 FOR ACCOUNTS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.account_id is null) then
    new.account_id = gen_id(seq_account_id, 1);
  if (new.status_id is null) then
    select o_status_id from status_get_default('ACCOUNT') into new.status_id;
  if (new.rest_eur is null) then
  begin
    new.rest_eur = 0;
    new.rest_date = current_timestamp;
  end
end
^

/* Trigger: ACCOUNTS_BU0 */
CREATE OR ALTER TRIGGER ACCOUNTS_BU0 FOR ACCOUNTS
ACTIVE BEFORE UPDATE POSITION 0
AS
begin
  new.rest_date = current_timestamp;
end
^

/* Trigger: ACCRESTS_BI0 */
CREATE OR ALTER TRIGGER ACCRESTS_BI0 FOR ACCRESTS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  new.rest_dtm = current_timestamp;

  if (new.accrest_id is null) then
    new.accrest_id = gen_id(seq_accrest_id, 1);

  if (new.byr2eur is null) then
    select o_value from setting_get('BYR2EUR', new.rest_dtm) into new.byr2eur;

  if (new.rest_eur is null and new.rest_byr is not null) then
    new.rest_eur = cast(new.rest_byr as numeric(12,2)) / new.byr2eur;

  select o_money_byr from money_eur2byr(new.rest_eur, new.byr2eur) into new.rest_byr;

end
^

/* Trigger: ACCRESTS_BU0 */
CREATE OR ALTER TRIGGER ACCRESTS_BU0 FOR ACCRESTS
ACTIVE BEFORE UPDATE POSITION 0
AS
begin
  new.rest_dtm = current_timestamp;

  select o_money_byr from money_eur2byr(new.rest_eur, new.byr2eur) into new.rest_byr;
end
^

/* Trigger: ACTIONCODES_BIU0 */
CREATE OR ALTER TRIGGER ACTIONCODES_BIU0 FOR ACTIONCODES
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
  if (new.procedure_name is not null) then
  begin
    if (not exists(select rdb$procedure_id
      from rdb$procedures
      where rdb$procedure_name = upper('ACT_'||new.procedure_name))) then
    exception ex_procedure_not_found 'Procedure ACT_'||new.procedure_name||' not found';
  end
end
^

/* Trigger: ACTIONS_BI0 */
CREATE OR ALTER TRIGGER ACTIONS_BI0 FOR ACTIONS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  new.user_sign = user;
end
^

/* Trigger: ACTIONTREE_BI0 */
CREATE OR ALTER TRIGGER ACTIONTREE_BI0 FOR ACTIONTREE
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.actiontreeitem_id is null) then
    new.actiontreeitem_id = gen_id(seq_actiontreeitem_id, 1);
end
^

/* Trigger: ADRESSES_AI0 */
CREATE OR ALTER TRIGGER ADRESSES_AI0 FOR ADRESSES
ACTIVE AFTER INSERT POSITION 0
AS
  declare variable v_arc_status_id id_status;
begin
  select status_id
    from statuses s
    where s.object_sign = 'ADRESS'
      and s.status_sign = 'ARCHIVE'
    into :v_arc_status_id;
  update adresses a
    set a.status_id = :v_arc_status_id
    where a.adress_id <> new.adress_id
      and a.client_id = new.client_id
      and a.status_id <> :v_arc_status_id;
end
^

/* Trigger: ADRESSES_BI0 */
CREATE OR ALTER TRIGGER ADRESSES_BI0 FOR ADRESSES
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.adress_id is null) then
    new.adress_id = gen_id(seq_adress_id, 1);
  if (new.status_id is null) then
    select o_status_id from status_get_default('ADRESS') into new.status_id;
  new.status_dtm = current_timestamp;
end
^

/* Trigger: ADRESSES_BU0 */
CREATE OR ALTER TRIGGER ADRESSES_BU0 FOR ADRESSES
ACTIVE BEFORE UPDATE POSITION 0
AS
begin
  if (new.status_id <> old.status_id) then
    new.status_dtm = current_timestamp;
end
^

/* Trigger: ATTRS_BIU0 */
CREATE OR ALTER TRIGGER ATTRS_BIU0 FOR ATTRS
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
  if (new.field_name is not null) then
  begin
    if (not exists(select *
                 from objects o
                   inner join rdb$relation_fields r on (r.rdb$relation_name = o.table_name)
                 where r.rdb$field_name = new.field_name)) then
      exception ex_unknown_fieldname;
  end
end
^

/* Trigger: BONUSES_BI0 */
CREATE OR ALTER TRIGGER BONUSES_BI0 FOR BONUSES
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.bonus_id is null) then
    new.bonus_id = gen_id(seq_bonus_id, 1);
  if (new.status_id is null) then
    select o_status_id from status_get_default('BONUS') into new.status_id;
  if (new.create_dtm is null) then
    new.create_dtm = current_timestamp;
  new.status_dtm = current_timestamp;
end
^

/* Trigger: BONUSES_BU0 */
CREATE OR ALTER TRIGGER BONUSES_BU0 FOR BONUSES
ACTIVE BEFORE UPDATE POSITION 0
AS
begin
  if (old.status_id <> new.status_id) then
    new.status_dtm = current_timestamp;
end
^

/* Trigger: BUILDS_BI0 */
CREATE OR ALTER TRIGGER BUILDS_BI0 FOR BUILDS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  new.install_dtm = current_timestamp;
end
^

/* Trigger: CALCPOINTS_BI0 */
CREATE OR ALTER TRIGGER CALCPOINTS_BI0 FOR CALCPOINTS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.calcpoint_id is null) then
    new.calcpoint_id = gen_id(seq_calcpoint_id, 1);
  if (not exists (select *
                from statuses s
                where s.status_id = new.object_status_id
                  and s.object_sign = new.object_sign)) then
    exception ex_wrong_object_status_id;
end
^

/* Trigger: CLIENTNOTIFIES_BI0 */
CREATE OR ALTER TRIGGER CLIENTNOTIFIES_BI0 FOR CLIENTNOTIFIES
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.clientnotify_id is null) then
    new.clientnotify_id = gen_id(seq_clientnotify_id, 1);
  if (new.status_id is null) then
    select o_status_id from status_get_default('CLIENTNOTIFY') into new.status_id;
end
^

/* Trigger: CLIENTS_BI0 */
CREATE OR ALTER TRIGGER CLIENTS_BI0 FOR CLIENTS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.client_id is null) then
    new.client_id = gen_id(seq_client_id, 1);
  if (new.status_id is null) then
    select o_status_id from status_get_default('CLIENT') into new.status_id;
end
^

/* Trigger: COUNTERS_BU0 */
CREATE OR ALTER TRIGGER COUNTERS_BU0 FOR COUNTERS
ACTIVE BEFORE UPDATE POSITION 0
AS
begin
  new.curr_value = old.curr_value + 1;
  if (new.curr_value not between new.min_value and new.max_value) then
    new.curr_value = new.min_value;
end
^

/* Trigger: DEALERNOTIFIES_BI0 */
CREATE OR ALTER TRIGGER DEALERNOTIFIES_BI0 FOR DEALERNOTIFIES
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.dealernotify_id is null) then
    new.dealernotify_id= gen_id(seq_dealernotify_id, 1);
  if (new.status_id is null) then
    select o_status_id from status_get_default('DEALERNOTIFY') into new.status_id;
  new.status_dtm = current_timestamp;
  new.create_dtm = current_timestamp;
end
^

/* Trigger: EVENTS_BI */
CREATE OR ALTER TRIGGER EVENTS_BI FOR EVENTS
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.event_id is null) then
    new.event_id = gen_id(seq_event_id,1);
  if (new.status_id is null) then
    select o_status_id from status_get_default('EVENT') into new.status_id;
  new.status_dtm = current_timestamp;
end
^

/* Trigger: EVENTS_BU0 */
CREATE OR ALTER TRIGGER EVENTS_BU0 FOR EVENTS
ACTIVE BEFORE UPDATE POSITION 0
AS
begin
  if (old.status_id <> new.status_id) then
    new.status_dtm = current_timestamp;
end
^

/* Trigger: FLAGS2STATUSES_AIUD0 */
CREATE OR ALTER TRIGGER FLAGS2STATUSES_AIUD0 FOR FLAGS2STATUSES
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 0
AS
begin
  merge into statuses s
    using (select status_id, ','||list(flag_sign)||',' as flag_sign_list
             from flags2statuses
--             where status_id = old.status_id
             group by status_id) f2s
    on (s.status_id = f2s.status_id)
    when matched then
      update set s.flag_sign_list = f2s.flag_sign_list;
end
^

/* Trigger: LOGS_BI0 */
CREATE OR ALTER TRIGGER LOGS_BI0 FOR LOGS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.log_id is null) then
    new.log_id = gen_id(seq_log_id, 1);
end
^

/* Trigger: MAGAZINES_BI0 */
CREATE OR ALTER TRIGGER MAGAZINES_BI0 FOR MAGAZINES
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.magazine_id is null) then
    new.magazine_id = gen_id(seq_magazine_id, 1);

  if (new.status_id is null) then
    select o_status_id from status_get_default('MAGAZINE') into new.status_id;

  if (new.magazine_name is null) then
    select trim(c.catalog_name)||' до '||new.valid_date
      from catalogs c
      where c.catalog_id = new.catalog_id
    into new.magazine_name;
end
^

/* Trigger: MESSAGES_BI0 */
CREATE OR ALTER TRIGGER MESSAGES_BI0 FOR MESSAGES
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.message_id is null) then
    new.message_id = gen_id(seq_message_id, 1);
  if (new.status_id is null) then
    select o_status_id from status_get_default('MESSAGE') into new.status_id;
end
^

/* Trigger: MONEYBACKS_BI0 */
CREATE OR ALTER TRIGGER MONEYBACKS_BI0 FOR MONEYBACKS
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
  if (new.moneyback_id is null) then
    new.moneyback_id = gen_id(seq_moneyback_id, 1);
  if (new.status_id is null) then
    select o_status_id from status_get_default('MONEYBACK') into new.status_id;
  new.status_dtm = current_timestamp;
end
^

/* Trigger: NOTIFIES_BI0 */
CREATE OR ALTER TRIGGER NOTIFIES_BI0 FOR NOTIFIES
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  new.notify_id = gen_id(seq_notify_id, 1);
  new.notify_dtm = current_timestamp;
end
^

/* Trigger: OBJECTS_BIU0 */
CREATE OR ALTER TRIGGER OBJECTS_BIU0 FOR OBJECTS
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
  if (new.table_name is not null) then
  begin
    if (not exists (select * from rdb$Relations r where r.rdb$relation_name = new.table_name)) then
      exception ex_unknown_tablename 'Unknown table name '||new.table_name;

  if (not exists (select * from rdb$relation_fields f
                    where f.rdb$field_name = new.idfield_name
                      and f.rdb$relation_name = new.table_name)) then
      exception ex_unknown_fieldname 'Unknown field name '||new.idfield_name;
  end

  if (new.attr_table_name is not null) then
    if (not exists (select * from rdb$Relations r where r.rdb$relation_name = new.attr_table_name)) then
      exception ex_unknown_tablename 'Unknown table name '||new.attr_table_name;

end
^

/* Trigger: ORDERHISTORY_BI0 */
CREATE OR ALTER TRIGGER ORDERHISTORY_BI0 FOR ORDERHISTORY
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  new.action_dtm = current_timestamp;
  new.user_sign = user;
end
^

/* Trigger: ORDERITEMS_AIUD0 */
CREATE OR ALTER TRIGGER ORDERITEMS_AIUD0 FOR ORDERITEMS
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 0
AS
begin
  execute procedure order_updatecost(coalesce(new.order_id, old.order_id));
end
^

/* Trigger: ORDERITEMS_BI0 */
CREATE OR ALTER TRIGGER ORDERITEMS_BI0 FOR ORDERITEMS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  new.article_code = upper(new.article_code);
  if (new.orderitem_id is null) then
    new.orderitem_id = gen_id(seq_orderitem_id, 1);
  if (new.status_id is null) then
    select o_status_id from status_get_default('ORDERITEM') into new.status_id;
  new.status_dtm = current_timestamp;

  new.amount = 1;
  new.cost_eur = new.price_eur;
end
^

/* Trigger: ORDERITEMS_BU0 */
CREATE OR ALTER TRIGGER ORDERITEMS_BU0 FOR ORDERITEMS
ACTIVE BEFORE UPDATE POSITION 0
as
declare variable v_flaglist list_signs;
declare variable v_byr2eur money_byr;
begin
  new.article_code = upper(new.article_code);
  new.dimension = upper(new.dimension);
  if (new.status_id <> old.status_id) then
  begin
    new.status_dtm = current_timestamp;
    new.state_id = null;
  end
  if (exists (select *
                from flags2statuses f2s
                where f2s.status_id = new.status_id
                  and f2s.flag_sign = 'CREDIT')) then
    new.amount = 1;
  else
    new.amount = 0;
  new.cost_eur = new.amount * new.price_eur;
end
^

/* Trigger: ORDERMONEYS_AIUD0 */
CREATE OR ALTER TRIGGER ORDERMONEYS_AIUD0 FOR ORDERMONEYS
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 0
AS
begin
  execute procedure order_updatecost(coalesce(new.order_id, old.order_id));
end
^

/* Trigger: ORDERMONEYS_BI0 */
CREATE OR ALTER TRIGGER ORDERMONEYS_BI0 FOR ORDERMONEYS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.ordermoney_id is null) then
    new.ordermoney_id = gen_id(seq_ordermoney_id, 1);
  if (new.status_id is null) then
    select o_status_id from status_get_default('ORDERMONEY') into new.status_id;
  if (new.byr2eur is null) then
    select o.byr2eur
      from orders o
      where o.order_id = new.order_id
      into new.byr2eur;
  if (new.amount_byr is null) then
    select o_money_byr from money_eur2byr(new.amount_eur, new.byr2eur) into new.amount_byr;

  new.status_dtm = current_timestamp;
  new.created_dtm = current_timestamp;
end
^

/* Trigger: ORDERMONEYS_BU0 */
CREATE OR ALTER TRIGGER ORDERMONEYS_BU0 FOR ORDERMONEYS
ACTIVE BEFORE UPDATE POSITION 0
AS
begin
  select o_money_byr from money_eur2byr(new.amount_eur, new.byr2eur) into new.amount_byr;
end
^

/* Trigger: ORDERS_BI0 */
CREATE OR ALTER TRIGGER ORDERS_BI0 FOR ORDERS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.order_id is null) then
    new.order_id = gen_id(seq_order_id, 1);
  if (new.status_id is null) then
    select o_status_id from status_get_default('ORDER') into new.status_id;
  if (new.create_dtm is null) then
    new.create_dtm = current_timestamp;
  new.status_dtm = current_timestamp;
  new.user_sign = current_user;
end
^

/* Trigger: ORDERS_BU0 */
CREATE OR ALTER TRIGGER ORDERS_BU0 FOR ORDERS
ACTIVE BEFORE UPDATE POSITION 0
AS
begin
  if (old.status_id <> new.status_id) then
  begin
    new.status_dtm = current_timestamp;
    new.state_id = null;
  end

  if ((old.cost_eur <> new.cost_eur) or (old.byr2eur <> new.byr2eur)) then
    select o_money_byr from money_eur2byr(new.cost_eur, new.byr2eur) into new.cost_byr;
end
^

/* Trigger: ORDERTAXS_AIUD0 */
CREATE OR ALTER TRIGGER ORDERTAXS_AIUD0 FOR ORDERTAXS
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 0
AS
begin
  execute procedure order_updatecost(coalesce(new.order_id, old.order_id));
end
^

/* Trigger: ORDERTAXS_BI0 */
CREATE OR ALTER TRIGGER ORDERTAXS_BI0 FOR ORDERTAXS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.ordertax_id is null) then
    new.ordertax_id = gen_id(seq_ordertax_id, 1);

  if (new.status_id is null) then
    select o_status_id from status_get_default('ORDERTAX') into new.status_id;
  new.status_dtm = current_timestamp;

  if (new.price_eur is not null and new.amount is not null) then
    new.cost_eur = new.price_eur * new.amount;

end
^

/* Trigger: ORDERTAXS_BU0 */
CREATE OR ALTER TRIGGER ORDERTAXS_BU0 FOR ORDERTAXS
ACTIVE BEFORE UPDATE POSITION 0
AS
begin
  if (old.status_id <> new.status_id) then
    new.status_dtm = current_timestamp;
  if (not exists (select *
                from flags2statuses f2s
                where f2s.status_id = new.status_id
                  and f2s.flag_sign = 'CREDIT')) then
    new.amount = 0;
  new.cost_eur= new.price_eur * new.amount;
end
^

/* Trigger: PARAMHEADS_BI0 */
CREATE OR ALTER TRIGGER PARAMHEADS_BI0 FOR PARAMHEADS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  new.create_dtm = current_timestamp;
end
^

/* Trigger: PAYMENTS_BI0 */
CREATE OR ALTER TRIGGER PAYMENTS_BI0 FOR PAYMENTS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.payment_id is null) then
    new.payment_id = gen_id(seq_payment_id, 1);
  if (new.status_id is null) then
    select o_status_id from status_get_default('PAYMENT') into new.status_id;
  new.status_dtm = current_timestamp;
end
^

/* Trigger: PLACES_BI0 */
CREATE OR ALTER TRIGGER PLACES_BI0 FOR PLACES
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.status_id is null) then
    select o_status_id from status_get_default('PLACE') into new.status_id;

  if (new.place_id is null) then
    select coalesce(max(p.place_id), new.owner_place*100) + 1 from places p
      where p.owner_place = new.owner_place
      into new.place_id;
end
^

/* Trigger: PLUGINS_BI0 */
CREATE OR ALTER TRIGGER PLUGINS_BI0 FOR PLUGINS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.plugin_id is null) then
    new.plugin_id = gen_id(seq_plugin_id, 1);
end
^

/* Trigger: PORTS_BI0 */
CREATE OR ALTER TRIGGER PORTS_BI0 FOR PORTS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.port_id is null) then
    new.port_id = gen_id(seq_port_id, 1);
end
^

/* Trigger: PRODUCTS_BI0 */
CREATE OR ALTER TRIGGER PRODUCTS_BI0 FOR PRODUCTS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.status_id is null) then
    select o_status_id from status_get_default('PRODUCT') into new.status_id;
  new.status_dtm = current_timestamp;
end
^

/* Trigger: PRODUCTS_BU0 */
CREATE OR ALTER TRIGGER PRODUCTS_BU0 FOR PRODUCTS
ACTIVE BEFORE UPDATE POSITION 0
AS
begin
  if (new.status_id <> old.status_id) then
    new.status_dtm = current_timestamp;
end
^

/* Trigger: SETTINGS_BI0 */
CREATE OR ALTER TRIGGER SETTINGS_BI0 FOR SETTINGS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.setting_id is null) then
    new.setting_id = gen_id(seq_setting_id, 1);
  if (new.valid_dtm is null) then
    new.valid_dtm = '9999.12.31';
end
^

/* Trigger: TAXPLANS_BI0 */
CREATE OR ALTER TRIGGER TAXPLANS_BI0 FOR TAXPLANS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.taxplan_id is null) then
    new.taxplan_id = gen_id(seq_taxplan_id, 1);

  if (new.status_id is null) then
    select o_status_id from status_get_default('TAXPLAN') into new.status_id;
  new.status_dtm = current_timestamp;

end
^

/* Trigger: TAXPLANS_BU0 */
CREATE OR ALTER TRIGGER TAXPLANS_BU0 FOR TAXPLANS
ACTIVE BEFORE UPDATE POSITION 0
AS
begin
  if (new.status_id <> old.status_id) then
    new.status_dtm = current_timestamp;
end
^

/* Trigger: TAXRATES_BI0 */
CREATE OR ALTER TRIGGER TAXRATES_BI0 FOR TAXRATES
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.taxrate_id is null) then
    new.taxrate_id = gen_id(seq_taxrate_id, 1);
  select o_status_id from status_get_default('TAXRATE') into new.status_id;
  if (new.status_id is null) then
    exception ex_default_status_undefined 'Undefined default status for TAXRATE';
end
^

/* Trigger: TAXSERVS_BI0 */
CREATE OR ALTER TRIGGER TAXSERVS_BI0 FOR TAXSERVS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.taxserv_id is null) then
    new.taxserv_id = gen_id(seq_taxserv_id, 1);
  select o_status_id from status_get_default('TAXSERV') into new.status_id;
  if (new.status_id is null) then
    exception ex_default_status_undefined 'Undefined default status for TAXSERV';
end
^

/* Trigger: WAYS_BI0 */
CREATE OR ALTER TRIGGER WAYS_BI0 FOR WAYS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.way_id is null) then
    new.way_id = gen_id(seq_way_id, 1);
end
^

SET TERM ; ^



/******************************************************************************/
/***                           Stored Procedures                            ***/
/******************************************************************************/


SET TERM ^ ;

CREATE OR ALTER PROCEDURE AALL_CLEAR (
    I_CLEAR_ARTICLES SMALLINT)
AS
declare variable V_OBJECT_ID type of ID_OBJECT;
begin

  update accopers ao
    set ao.order_id = null, ao.ordermoney_id = null;

  delete from payments;
  v_object_id = gen_id(seq_payment_id, -(gen_id(seq_payment_id, 0)));

  delete from orders;
  v_object_id = gen_id(seq_order_id, -(gen_id(seq_order_id, 0)));
  v_object_id = gen_id(seq_orderitem_id, -(gen_id(seq_orderitem_id, 0)));
  v_object_id = gen_id(seq_ordertax_id, -(gen_id(seq_ordertax_id, 0)));

  delete from clients;
  v_object_id = gen_id(seq_client_id, -(gen_id(seq_client_id, 0)));
  v_object_id = gen_id(seq_adress_id, -(gen_id(seq_adress_id, 0)));

  delete from accounts;
  v_object_id = gen_id(seq_account_id, -(gen_id(seq_account_id, 0)));
  v_object_id = gen_id(seq_accoper_id, -(gen_id(seq_accoper_id, 0)));


  delete from places where place_id > 1000000;
  v_object_id = gen_id(seq_place_id, -(gen_id(seq_place_id, 0))+1000000);


  delete from messages;
  v_object_id = gen_id(seq_message_id, -(gen_id(seq_message_id, 0)));
  v_object_id = gen_id(seq_notify_id, -(gen_id(seq_notify_id, 0)));

  delete from actions;
  v_object_id = gen_id(seq_action_id, -(gen_id(seq_action_id, 0)));

  delete from paramheads;
  v_object_id = gen_id(seq_param_id, -(gen_id(seq_param_id, 0)));

  delete from logs;
  v_object_id = gen_id(seq_log_id, -(gen_id(seq_log_id, 0)));

  delete from events;
  v_object_id = gen_id(seq_event_id, -(gen_id(seq_event_id, 0)));

  delete from sessions;
  if (i_clear_articles is not null) then
  begin
    delete from magazines where magazine_id > 1;
    v_object_id = gen_id(seq_magazine_id, -(gen_id(seq_magazine_id, 0))+1);
  end

end^


CREATE OR ALTER PROCEDURE ACCOUNT_MERGE (
    I_FROM_ACCOUNT_ID TYPE OF ID_ACCOUNT NOT NULL,
    I_TO_ACCOUNT_ID TYPE OF ID_ACCOUNT NOT NULL)
AS
begin
  update accopers ao
    set ao.account_id = :i_to_account_id
    where ao.account_id = :i_from_account_id;

  update clients c
    set c.account_id = :i_to_account_id
    where c.account_id = :i_from_account_id;

  update moneybacks mb
    set mb.account_id = :i_to_account_id
    where mb.account_id = :i_from_account_id;

  update ordermoneys om
    set om.account_id = :i_to_account_id
    where om.account_id = :i_from_account_id;

  update orders o
    set o.account_id = :i_to_account_id
    where o.account_id = :i_from_account_id;

  update accrests ar
    set ar.account_id = :i_to_account_id
    where ar.account_id = :i_from_account_id
      and ar.byr2eur not in (select a.byr2eur from accrests a where a.account_id = :i_to_account_id);

  merge into accrests ar
  using (select a.account_id, a.byr2eur, coalesce(sum(a.amount_eur), 0) rest_eur
           from accopers a
           where a.account_id = :i_to_account_id
           group by  a.account_id, a.byr2eur) ao
  on (ar.account_id = ao.account_id and ar.byr2eur = ao.byr2eur)
  when matched then
    update set ar.rest_eur = ao.rest_eur
  when not matched then
    insert (account_id, byr2eur, rest_eur)
    values (ao.account_id, ao.byr2eur, ao.rest_eur);

  delete from accounts a
    where a.account_id = :i_from_account_id;

end^


CREATE OR ALTER PROCEDURE ACCOUNT_RECALCREST (
    I_ACCOUNT_ID TYPE OF ID_ACCOUNT NOT NULL)
AS
begin
  delete from accrests ar where ar.account_id = :i_account_id;

  insert into accrests (account_id, byr2eur, rest_eur, rest_byr)
  select ao.account_id, ao.byr2eur, sum(ao.amount_eur), sum(ao.amount_byr)
    from accopers ao
    where ao.account_id = :i_account_id
    group by ao.account_id, ao.byr2eur;

  update accounts a
  set a.rest_eur = (select sum(ar.rest_eur)
    from accrests ar
    where ar.account_id = a.account_id)
  where a.account_id = :i_account_id;

end^


CREATE OR ALTER PROCEDURE ACCOUNT_X_SEARCH (
    I_DEST_PARAM_ID TYPE OF ID_PARAM NOT NULL,
    I_PARAM_NAME TYPE OF SIGN_ATTR NOT NULL,
    I_SRC_PARAM_ID TYPE OF ID_PARAM NOT NULL)
AS
declare variable V_ACCOUNT_ID type of ID_ACCOUNT;
declare variable V_OBJECT_ID type of ID_OBJECT;
begin
  if (i_param_name = 'CLIENT_ID') then
  begin
    select o_value from param_get(:i_src_param_id, 'CLIENT_ID') into :v_object_id;
    if (v_object_id is null) then
      exception ex_mandatory_param_expected 'Mandatory param CLIENT_ID expected';
    select c.account_id
      from clients c
      where c.client_id = :v_object_id
      into :v_account_id;
    execute procedure param_set(:i_dest_param_id, 'ID', :v_account_id);
  end
  else
  if (i_param_name = 'ORDER_ID') then
  begin
    select o_value from param_get(:i_src_param_id, 'ORDER_ID') into :v_object_id;
    if (v_object_id is null) then
      exception ex_mandatory_param_expected 'Mandatory param ORDER_ID expected';
    select c.account_id
      from orders o
        inner join clients c on (c.client_id = o.client_id)
      where o.order_id = :v_object_id
      into :v_account_id;
    execute procedure param_set(:i_dest_param_id, 'ID', :v_account_id);
  end

end^


CREATE OR ALTER PROCEDURE ACT_ACCOUNT_CREDIT (
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL,
    I_OBJECT_ID TYPE OF ID_OBJECT NOT NULL,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'ACCOUNT')
AS
declare variable V_AMOUNT_EUR type of MONEY_EUR;
declare variable V_BYR2EUR type of MONEY_BYR;
declare variable V_ORDER_ID type of ID_ORDER;
declare variable V_NOTES type of VALUE_ATTR;
declare variable V_AMOUNT_BYR type of MONEY_BYR;
begin
  update paramheads set object_id = :i_object_id where param_id = :i_param_id;

  execute procedure param_set(:i_param_id, 'ID', :i_object_id);

  select cast(o_value as money_byr) from param_get(:i_param_id, 'AMOUNT_BYR') into :v_amount_byr;
  select cast(o_value as money_eur) from param_get(:i_param_id, 'AMOUNT_EUR') into :v_amount_eur;
  select o_value from param_get(:i_param_id, 'BYR2EUR') into :v_byr2eur;
  select o_value from param_get(:i_param_id, 'NOTES') into :v_notes;

  if (v_amount_byr is null and v_amount_eur is not null) then
  begin
    v_amount_byr = round(:v_amount_eur*:v_byr2eur,  -1);
    execute procedure param_set(:i_param_id, 'AMOUNT_BYR', :v_amount_byr);
  end

  if (v_amount_eur is null and v_amount_byr is not null) then
  begin
    v_amount_eur = (1.00*v_amount_byr)/v_byr2eur;
    execute procedure param_set(:i_param_id, 'AMOUNT_EUR', :v_amount_eur);
  end

  select o_pattern from param_fillpattern(:i_param_id, :v_notes) into :v_notes;

  insert into accopers (account_id, amount_eur, amount_byr, byr2eur, notes)
    values(:i_object_id, -:v_amount_eur, -:v_amount_byr, :v_byr2eur, :v_notes);
end^


CREATE OR ALTER PROCEDURE ACT_ACCOUNT_CREDITORDER (
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL,
    I_OBJECT_ID TYPE OF ID_OBJECT NOT NULL,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'ACCOUNT')
AS
declare variable V_AMOUNT_EUR type of MONEY_EUR;
declare variable V_ORDER_ID type of ID_ORDER;
declare variable V_NOTES type of VALUE_ATTR;
declare variable V_REST_EUR type of MONEY_EUR;
declare variable V_ACC_BYR2EUR type of MONEY_BYR;
declare variable V_DELTA_EUR type of MONEY_EUR;
declare variable V_DELTA_BYR type of MONEY_BYR;
declare variable V_ORDERMONEY_ID type of ID_ORDERITEM;
declare variable V_BYR2EUR type of MONEY_BYR;
begin
  update paramheads set object_id = :i_object_id where param_id = :i_param_id;

  execute procedure param_set(:i_param_id, 'ID', :i_object_id);

  select cast(o_value as money_eur) from param_get(:i_param_id, 'AMOUNT_EUR') into :v_amount_eur;
  select o_value from param_get(:i_param_id, 'ORDER_ID') into :v_order_id;

  for select ar.byr2eur, ar.rest_eur
        from accrests ar
        where ar.account_id = :i_object_id
          and ar.rest_eur <> 0
        into :v_acc_byr2eur, :v_rest_eur do
  begin
    if (abs(v_amount_eur) < abs(v_rest_eur)) then
      v_delta_eur = v_amount_eur;
    else
      v_delta_eur = v_rest_eur;

    v_amount_eur = v_amount_eur - v_delta_eur;
    select o_money_byr from money_eur2byr(:v_delta_eur, :v_acc_byr2eur) into :v_delta_byr;

    select o_value from param_get(:i_param_id, 'NOTES') into :v_notes;
    select o_pattern from param_fill(:v_notes, 'AMOUNT_BYR', :v_delta_byr) into v_notes;
    select o_pattern from param_fill(:v_notes, 'AMOUNT_EUR', :v_delta_eur) into v_notes;
    select o_pattern from param_fillpattern(:i_param_id, :v_notes) into :v_notes;

    insert into ordermoneys (account_id, amount_eur, byr2eur, order_id, amount_byr)
      values(:i_object_id, :v_delta_eur, :v_acc_byr2eur, :v_order_id, :v_delta_byr)
      returning ordermoney_id
      into :v_ordermoney_id;
    insert into accopers (account_id, amount_eur, byr2eur, amount_byr, order_id, notes, ordermoney_id)
      values(:i_object_id, -:v_delta_eur, :v_acc_byr2eur, -:v_delta_byr, :v_order_id, :v_notes, :v_ordermoney_id);
    if (v_amount_eur = 0) then break;
  end

  if (v_amount_eur > 0) then
  begin
    select o.byr2eur
      from orders o
      where o.order_id = :v_order_id
      into :v_byr2eur;

    v_delta_eur = v_amount_eur;
    v_delta_byr = round(v_byr2eur * v_delta_eur, -1);

    select o_value from param_get(:i_param_id, 'NOTES') into :v_notes;
    select o_pattern from param_fill(:v_notes, 'AMOUNT_BYR', :v_delta_byr) into v_notes;
    select o_pattern from param_fill(:v_notes, 'AMOUNT_EUR', :v_delta_eur) into v_notes;
    select o_pattern from param_fillpattern(:i_param_id, :v_notes) into :v_notes;

    insert into ordermoneys (account_id, amount_eur, byr2eur, order_id, amount_byr)
      values(:i_object_id, :v_delta_eur, :v_byr2eur, :v_order_id, :v_delta_byr)
      returning ordermoney_id
      into :v_ordermoney_id;
    insert into accopers (account_id, amount_eur, byr2eur, amount_byr, order_id, notes, ordermoney_id)
      values(:i_object_id, -:v_delta_eur, :v_byr2eur, -:v_delta_byr, :v_order_id, :v_notes, :v_ordermoney_id);
  end
end^


CREATE OR ALTER PROCEDURE ACT_ACCOUNT_DEBIT (
    I_PARAM_ID TYPE OF ID_PARAM,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'ACCOUNT')
AS
declare variable V_AMOUNT_EUR type of MONEY_EUR;
declare variable V_BYR2EUR type of MONEY_BYR;
declare variable V_ORDER_ID type of ID_ORDER;
declare variable V_NOTES type of VALUE_ATTR;
declare variable V_AMOUNT_BYR type of MONEY_BYR;
begin

  update paramheads set object_id = :i_object_id where param_id = :i_param_id;

  execute procedure param_set(:i_param_id, 'ID', :i_object_id);

  select o_value from param_get(:i_param_id, 'AMOUNT_EUR') into :v_amount_eur;
  select o_value from param_get(:i_param_id, 'AMOUNT_BYR') into :v_amount_byr;
  select o_value from param_get(:i_param_id, 'BYR2EUR') into :v_byr2eur;
  select o_value from param_get(:i_param_id, 'ORDER_ID') into :v_order_id;
  select o_value from param_get(:i_param_id, 'NOTES') into :v_notes;

  if (v_amount_byr is null and v_amount_eur is not null) then
  begin
    v_amount_byr = round(:v_amount_eur*:v_byr2eur,  -1);
    execute procedure param_set(:i_param_id, 'AMOUNT_BYR', :v_amount_byr);
  end

  if (v_amount_eur is null and v_amount_byr is not null) then
  begin
    v_amount_eur = (1.00*v_amount_byr)/v_byr2eur;
    execute procedure param_set(:i_param_id, 'AMOUNT_EUR', :v_amount_eur);
  end

  select o_pattern from param_fillpattern(:i_param_id, :v_notes) into :v_notes;

  insert into accopers (account_id, amount_eur, byr2eur, order_id, notes, amount_byr)
    values(:i_object_id, :v_amount_eur, :v_byr2eur, :v_order_id, :v_notes, :v_amount_byr);
end^


CREATE OR ALTER PROCEDURE ACT_ACCOUNT_DEBITORDER (
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL,
    I_OBJECT_ID TYPE OF ID_OBJECT NOT NULL,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'ACCOUNT')
AS
declare variable V_AMOUNT_EUR type of MONEY_EUR;
declare variable V_ORDER_ID type of ID_ORDER;
declare variable V_NOTES type of VALUE_ATTR;
declare variable V_ACC_AMOUNT_EUR type of MONEY_EUR;
declare variable V_ACC_BYR2EUR type of MONEY_BYR;
declare variable V_DELTA_EUR type of MONEY_EUR;
declare variable V_AMOUNT_BYR type of MONEY_BYR;
declare variable V_DELTA_BYR type of MONEY_BYR;
declare variable V_ORDERMONEY_ID type of ID_ORDERITEM;
begin
  update paramheads set object_id = :i_object_id where param_id = :i_param_id;

  execute procedure param_set(:i_param_id, 'ID', :i_object_id);

  select o_value from param_get(:i_param_id, 'ORDER_ID') into :v_order_id;

  select -os.cost_eur
    from v_order_summary os
    where os.order_id = :v_order_id
    into :v_amount_eur;

  v_amount_byr = 0;

  for select om.byr2eur, sum(om.amount_eur)
        from ordermoneys om
        where om.order_id = :v_order_id
        group by om.byr2eur
        having sum(om.amount_eur) > 0
        order by max(om.ordermoney_id)
        into :v_acc_byr2eur, :v_acc_amount_eur do
  begin
    if (v_amount_eur < v_acc_amount_eur) then
      v_delta_eur = v_amount_eur;
    else
      v_delta_eur = v_acc_amount_eur;
    select o_money_byr from money_eur2byr(:v_delta_eur, :v_acc_byr2eur) into :v_delta_byr;

    v_amount_eur = v_amount_eur - v_delta_eur;
    v_amount_byr = v_amount_byr + v_delta_byr;

    select o_value from param_get(:i_param_id, 'NOTES') into :v_notes;
    select o_pattern from param_fillpattern(:i_param_id, :v_notes) into :v_notes;

    insert into ordermoneys (account_id, amount_eur, byr2eur, order_id, amount_byr)
      values(:i_object_id, -:v_delta_eur, :v_acc_byr2eur, :v_order_id, -:v_delta_byr)
      returning ordermoney_id
      into :v_ordermoney_id;
    insert into accopers (account_id, amount_eur, byr2eur, order_id, notes, amount_byr, ordermoney_id)
      values(:i_object_id, :v_delta_eur, :v_acc_byr2eur, :v_order_id, :v_notes, :v_delta_byr, :v_ordermoney_id);
  end

  execute procedure param_set(:i_param_id, 'AMOUNT_BYR', :v_amount_byr);
end^


CREATE OR ALTER PROCEDURE ACT_ACCOUNT_PAYMENTIN (
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL,
    I_OBJECT_ID TYPE OF ID_OBJECT NOT NULL,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'ACCOUNT')
AS
declare variable V_AMOUNT_EUR type of MONEY_EUR;
declare variable V_BYR2EUR type of MONEY_BYR;
declare variable V_ORDER_ID type of ID_ORDER;
declare variable V_NOTES type of VALUE_ATTR;
declare variable V_AMOUNT_BYR type of MONEY_BYR;
declare variable V_ORDER_CODE type of CODE_ORDER;
begin
  update paramheads set object_id = :i_object_id where param_id = :i_param_id;

  execute procedure param_set(:i_param_id, 'ID', :i_object_id);

  select o_value from param_get(:i_param_id, 'AMOUNT_BYR') into :v_amount_byr;
  select o_value from param_get(:i_param_id, 'ORDER_ID') into :v_order_id;
  select o_value from param_get(:i_param_id, 'NOTES') into :v_notes;

  select o.byr2eur, o.order_code
    from orders o
    where o.order_id = :v_order_id
    into :v_byr2eur, :v_order_code;

  v_amount_eur = round(cast(v_amount_byr as numeric(18,3)) / v_byr2eur, 2);

  execute procedure param_set(:i_param_id, 'ORDER_CODE', :v_order_code);
  execute procedure param_set(:i_param_id, 'BYR2EUR', :v_byr2eur);
  execute procedure param_set(:i_param_id, 'AMOUNT_EUR', :v_amount_eur);

  select o_pattern from param_fillpattern(:i_param_id, :v_notes) into :v_notes;

  insert into accopers (account_id, amount_eur, byr2eur, order_id, notes, amount_byr)
    values(:i_object_id, :v_amount_eur, :v_byr2eur, :v_order_id, :v_notes, :v_amount_byr);
end^


CREATE OR ALTER PROCEDURE ACT_ACCOUNT_PAYMENTOUT (
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL,
    I_OBJECT_ID TYPE OF ID_OBJECT NOT NULL,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'ACCOUNT')
AS
declare variable V_NOTES type of VALUE_ATTR;
declare variable V_AMOUNT_BYR type of MONEY_BYR;
declare variable V_REST_BYR type of MONEY_BYR;
declare variable V_DELTA_BYR type of MONEY_BYR;
declare variable V_BYR2EUR type of KURS_EXCH;
begin
  update paramheads set object_id = :i_object_id where param_id = :i_param_id;

  execute procedure param_set(:i_param_id, 'ID', :i_object_id);

  select o_value from param_get(:i_param_id, 'AMOUNT_BYR') into :v_amount_byr;
  select o_value from param_get(:i_param_id, 'NOTES') into :v_notes;

  select o_pattern from param_fillpattern(:i_param_id, :v_notes) into :v_notes;

  for select ar.byr2eur, ar.rest_byr
         from accrests ar
         where ar.account_id = :i_object_id
           and ar.rest_byr > 0
         order by ar.byr2eur
         into :v_byr2eur, :v_rest_byr do
  begin
    if (v_amount_byr < v_rest_byr) then
      v_delta_byr = v_amount_byr;
    else
      v_delta_byr = v_rest_byr;
    v_amount_byr = v_amount_byr - v_delta_byr;

    insert into accopers (account_id, byr2eur, notes, amount_byr)
      values(:i_object_id, :v_byr2eur, :v_notes, -:v_delta_byr);
    if (v_amount_byr = 0) then break;
  end

end^


CREATE OR ALTER PROCEDURE ACT_ACCOUNT_STORE (
    I_PARAM_ID TYPE OF ID_PARAM,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'ACCOUNT')
AS
declare variable V_NOW_STATUS_ID type of ID_STATUS;
declare variable V_NEW_STATUS_ID type of ID_STATUS;
declare variable V_REST_EUR type of MONEY_EUR;
declare variable V_UPDATEABLE type of VALUE_BOOLEAN;
begin
  if (coalesce(i_object_id, 0) = 0) then i_object_id = gen_id(seq_account_id, 1);

  update paramheads set object_id = :i_object_id where param_id = :i_param_id;

  execute procedure param_set(:i_param_id, 'ID', :i_object_id);

  select status_id from accounts where account_id = :i_object_id into :v_now_status_id;

  if (:v_now_status_id is null) then
  begin
    v_rest_eur = 0;
    insert into accounts(account_id, rest_eur, status_id)
      values(:i_object_id, :v_rest_eur, :v_new_status_id)
      returning status_id
      into :v_new_status_id;
    v_updateable = 1;
  end
  else
  begin
    select o_updateable, o_new_status_id
      from object_updateable(:i_param_id, :v_now_status_id, :i_object_sign)
      into :v_updateable, :v_new_status_id;
  end

  if (v_updateable = 1) then
  begin
    execute procedure param_set(:i_param_id, 'STATUS_ID', :v_new_status_id);

    execute procedure object_put(:i_param_id);
  end
end^


CREATE OR ALTER PROCEDURE ACT_ADRESS_STORE (
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'ADRESS')
AS
declare variable V_NOW_STATUS_ID type of ID_STATUS;
declare variable V_PLACE_ID type of ID_PLACE;
declare variable V_CLIENT_ID type of ID_CLIENT;
declare variable V_NEW_STATUS_ID type of ID_STATUS;
declare variable V_UPDATEABLE type of VALUE_BOOLEAN;
begin
  if (coalesce(i_object_id, 0) = 0) then i_object_id = gen_id(seq_adress_id, 1);

  update paramheads set object_id = :i_object_id where param_id = :i_param_id;

  execute procedure param_set(:i_param_id, 'ID', :i_object_id);

  select status_id from adresses oi where adress_id = :i_object_id into :v_now_status_id;

  if (:v_now_status_id is null) then
  begin
    select o_value from param_get(:i_param_id, 'CLIENT_ID') into :v_client_id;
    select o_value from param_get(:i_param_id, 'PLACE_ID') into :v_place_id;

    insert into adresses(adress_id, client_id, place_id, status_id)
      values(:i_object_id, :v_client_id, :v_place_id, :v_new_status_id)
      returning status_id
      into :v_new_status_id;
    v_updateable = 1;
  end
  else
  begin
    select o_updateable, o_new_status_id
      from object_updateable(:i_param_id, :v_now_status_id, :i_object_sign)
      into :v_updateable, :v_new_status_id;
  end

  if (v_updateable = 1) then
  begin
    execute procedure param_set(:i_param_id, 'STATUS_ID', :v_new_status_id);
    execute procedure object_put(:i_param_id);
  end
end^


CREATE OR ALTER PROCEDURE ACT_BONUS_STORE (
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'BONUS')
AS
declare variable V_NOW_STATUS_ID type of ID_STATUS;
declare variable V_UPDATEABLE type of VALUE_BOOLEAN;
declare variable V_NEW_STATUS_ID type of ID_STATUS;
declare variable V_TAXSERV_ID type of ID_TAX;
declare variable V_CLIENT_ID type of ID_CLIENT;
begin
  if (coalesce(i_object_id, 0) = 0) then i_object_id = gen_id(seq_bonus_id, 1);
    
  update paramheads set object_id = :i_object_id where param_id = :i_param_id;
    
  execute procedure param_set(:i_param_id, 'ID', :i_object_id);
    
  select status_id from bonuses b where b.bonus_id = :i_object_id into :v_now_status_id;

  if (:v_now_status_id is null) then
  begin
    select o_value from param_get(:i_param_id, 'TAXSERV_ID') into :v_taxserv_id;
    select o_value from param_get(:i_param_id, 'CLIENT_ID') into :v_client_id;

    insert into bonuses(bonus_id, client_id, taxserv_id, status_id)
      values(:i_object_id, :v_client_id, :v_taxserv_id, :v_new_status_id)
      returning status_id
      into :v_new_status_id;
    v_updateable = 1;
  end
  else
  begin
    select o_updateable, o_new_status_id
      from object_updateable(:i_param_id, :v_now_status_id, :i_object_sign)
      into :v_updateable, :v_new_status_id;
  end

  if (v_updateable = 1) then
  begin
    execute procedure param_set(:i_param_id, 'STATUS_ID', :v_new_status_id);
    execute procedure object_put(:i_param_id);
  end
  else
    exception ex_status_conversion_unavail 'From '||:v_now_status_id||' to '||:v_new_status_id;

end^


CREATE OR ALTER PROCEDURE ACT_BONUS_USE (
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL,
    I_OBJECT_ID TYPE OF ID_OBJECT NOT NULL,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'BONUS')
AS
declare variable V_NOW_STATUS_ID type of ID_STATUS;
declare variable V_ORDER_ID type of ID_ORDER;
declare variable V_UPDATEABLE type of VALUE_BOOLEAN;
declare variable V_NEW_STATUS_ID type of ID_STATUS;
declare variable V_TAXRATE_ID type of ID_TAX;
declare variable V_TAX_PROCEDURE type of NAME_PROCEDURE;
declare variable V_PRICE_EUR type of MONEY_EUR;
declare variable V_ORDERTAX_ID type of ID_TAX;
begin

  update paramheads set object_id = :i_object_id where param_id = :i_param_id;
    
  execute procedure param_set(:i_param_id, 'ID', :i_object_id);

  select o_value from param_get(:i_param_id, 'ORDER_ID') into :v_order_id;

  select status_id from bonuses b where b.bonus_id = :i_object_id into :v_now_status_id;
    
  select r.taxrate_id, r.tax_procedure
    from orders o
      inner join bonuses b on (b.client_id = o.client_id)
      inner join product2taxplan p2t on (p2t.product_id = o.product_id)
      inner join taxrates r on (r.taxplan_id = p2t.taxplan_id and r.taxserv_id = b.taxserv_id)
    where o.order_id = :v_order_id and b.bonus_id = :i_object_id
    into :v_taxrate_id, :v_tax_procedure;

  execute statement ('select o_cost_eur from '||v_tax_procedure||'(:taxrate_id, :param_id)')
    (taxrate_id := :v_taxrate_id, param_id := :i_param_id)
    into :v_price_eur;

  insert into ordertaxs(order_id, taxrate_id, status_id, price_eur)
    values(:v_order_id, :v_taxrate_id, :v_new_status_id, -:v_price_eur)
    returning ordertax_id
    into :v_ordertax_id;

  execute procedure param_set(:i_param_id, 'NEW.STATUS_SIGN', 'USED');
  select o_updateable, o_new_status_id
    from object_updateable(:i_param_id, :v_now_status_id, :i_object_sign)
    into :v_updateable, :v_new_status_id;

  update bonuses b
    set b.ordertax_id = :v_ordertax_id, b.status_id = :v_new_status_id
    where b.bonus_id = :i_object_id;
end^


CREATE OR ALTER PROCEDURE ACT_CLIENT_STORE (
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'CLIENT')
AS
declare variable V_NOW_STATUS_ID type of ID_STATUS;
declare variable V_NEW_STATUS_ID type of ID_STATUS;
declare variable V_LAST_NAME type of NAME_REF;
declare variable V_FIRST_NAME type of NAME_REF;
declare variable V_UPDATEABLE type of VALUE_BOOLEAN;
begin
  if (coalesce(i_object_id, 0) = 0) then i_object_id = gen_id(seq_client_id, 1);

  update paramheads set object_id = :i_object_id where param_id = :i_param_id;

  execute procedure param_set(:i_param_id, 'ID', :i_object_id);

  select status_id from clients where client_id = :i_object_id into :v_now_status_id;

  if (:v_now_status_id is null) then
  begin
    select o_value from param_get(:i_param_id, 'LAST_NAME') into :v_last_name;
    select o_value from param_get(:i_param_id, 'FIRST_NAME') into :v_first_name;

    insert into clients(client_id, last_name, first_name, status_id)
      values(:i_object_id, :v_last_name, :v_first_name, :v_new_status_id)
      returning status_id
      into :v_new_status_id;
    v_updateable = 1;
  end
  else
  begin
    select o_updateable, o_new_status_id
      from object_updateable(:i_param_id, :v_now_status_id, :i_object_sign)
      into :v_updateable, :v_new_status_id;
  end

  if (v_updateable = 1) then
  begin
    execute procedure param_set(:i_param_id, 'STATUS_ID', :v_new_status_id);
    execute procedure object_put(:i_param_id);
  end
end^


CREATE OR ALTER PROCEDURE ACT_CLIENTNOTIFY_STORE (
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'CLIENTNOTIFY')
AS
declare variable V_NOW_STATUS_ID type of ID_STATUS;
declare variable V_NEW_STATUS_ID type of ID_STATUS;
declare variable V_UPDATEABLE type of VALUE_BOOLEAN;
declare variable V_CLIENT_ID type of ID_CLIENT;
declare variable V_DELIVERYTYPE_SIGN type of SIGN_OBJECT;
declare variable V_DELIVERY_ADDRESS type of ADDRESS_DELIVERY;
declare variable V_NOTIFY_TEXT type of VALUE_ATTR;
begin
  if (coalesce(i_object_id, 0) = 0) then i_object_id = gen_id(seq_clientnotify_id, 1);

  update paramheads set object_id = :i_object_id where param_id = :i_param_id;

  execute procedure param_set(:i_param_id, 'ID', :i_object_id);

  select status_id from clientnotifies where clientnotify_id = :i_object_id into :v_now_status_id;

  if (:v_now_status_id is null) then
  begin
    select o_value from param_get(:i_param_id, 'CLIENT_ID') into :v_client_id;
    select o_value from param_get(:i_param_id, 'DELIVERYTYPE_SIGN') into :v_deliverytype_sign;
    select o_value from param_get(:i_param_id, 'DELIVERY_ADDRESS') into :v_delivery_address;
    select o_value from param_get(:i_param_id, 'NOTIFY_TEXT') into :v_notify_text;
    select o_pattern from param_fillpattern(:i_param_id, :v_notify_text) into :v_notify_text;

    insert into clientnotifies (clientnotify_id, client_id, deliverytype_sign, delivery_address, notify_text, create_dtm)
      values(:i_object_id, :v_client_id, :v_deliverytype_sign, :v_delivery_address, :v_notify_text, current_timestamp)
      returning status_id
      into :v_new_status_id;
    v_updateable = 1;
  end
  else
  begin
    select o_updateable, o_new_status_id
      from object_updateable(:i_param_id, :v_now_status_id, :i_object_sign)
      into :v_updateable, :v_new_status_id;
  end

  if (v_updateable = 1) then
  begin
    execute procedure param_set(:i_param_id, 'STATUS_ID', :v_new_status_id);
    execute procedure object_put(:i_param_id);
  end
end^


CREATE OR ALTER PROCEDURE ACT_DEALERNOTIFY_STORE (
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'DEALERNOTIFY')
AS
declare variable V_NOW_STATUS_ID type of ID_STATUS;
declare variable V_NEW_STATUS_ID type of ID_STATUS;
declare variable V_UPDATEABLE type of VALUE_BOOLEAN;
declare variable V_NOTIFY_TEXT type of VALUE_ATTR;
declare variable V_DEALER_ID type of ID_DEALER;
declare variable V_MESSAGE_ID type of ID_MESSAGE;
begin
  if (coalesce(i_object_id, 0) = 0) then i_object_id = gen_id(seq_dealernotify_id, 1);

  update paramheads set object_id = :i_object_id where param_id = :i_param_id;

  execute procedure param_set(:i_param_id, 'ID', :i_object_id);

  select status_id from dealernotifies where dealernotify_id = :i_object_id into :v_now_status_id;

  if (:v_now_status_id is null) then
  begin
    select o_value from param_get(:i_param_id, 'DEALER_ID') into :v_dealer_id;
    select o_value from param_get(:i_param_id, 'MESSAGE_ID') into :v_message_id;
    select o_value from param_get(:i_param_id, 'NOTIFY_TEXT') into :v_notify_text;
    select o_pattern from param_fillpattern(:i_param_id, :v_notify_text) into :v_notify_text;

    insert into dealernotifies (dealernotify_id, dealer_id, message_id, notify_text)
      values(:i_object_id, :v_dealer_id, :v_message_id, :v_notify_text)
      returning status_id
      into :v_new_status_id;
    v_updateable = 1;
  end
  else
  begin
    select o_updateable, o_new_status_id
      from object_updateable(:i_param_id, :v_now_status_id, :i_object_sign)
      into :v_updateable, :v_new_status_id;
  end

  if (v_updateable = 1) then
  begin
    execute procedure param_set(:i_param_id, 'STATUS_ID', :v_new_status_id);
    execute procedure object_put(:i_param_id);
  end
end^


CREATE OR ALTER PROCEDURE ACT_EVENT_STORE (
    I_PARAM_ID TYPE OF ID_PARAM,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'EVENT')
AS
declare variable V_NOW_STATUS_ID type of ID_STATUS;
declare variable V_NEW_STATUS_ID type of ID_STATUS;
declare variable V_CATALOG_ID type of ID_CATALOG;
declare variable V_VALID_DATE type of DATE_VALID;
declare variable V_UPDATEABLE type of VALUE_BOOLEAN;
declare variable V_EVENT_SIGN type of SIGN_EVENT;
declare variable V_OBJECT_ID type of ID_OBJECT;
begin
  if (coalesce(i_object_id, 0) = 0) then i_object_id = gen_id(seq_event_id, 1);

  update paramheads set object_id = :i_object_id where param_id = :i_param_id;

  execute procedure param_set(:i_param_id, 'ID', :i_object_id);

  select status_id from events where event_id = :i_object_id into :v_now_status_id;

  if (v_now_status_id is null) then
  begin
    select o_value from param_get(:i_param_id, 'EVENT_SIGN') into :v_event_sign;
    select o_value from param_get(:i_param_id, 'OBJECT_ID') into :v_object_id;
    insert into events(event_id, event_sign, object_id, status_id)
      values(:i_object_id, :v_event_sign, :v_object_id, :v_new_status_id)
      returning status_id
      into :v_new_status_id;
    v_updateable = 1;
  end
  else
  begin
    select o_updateable, o_new_status_id
      from object_updateable(:i_param_id, :v_now_status_id, :i_object_sign)
      into :v_updateable, :v_new_status_id;
  end

  if (v_updateable = 1) then
  begin
    execute procedure param_set(:i_param_id, 'STATUS_ID', :v_new_status_id);
    execute procedure object_put(:i_param_id);
  end

end^


CREATE OR ALTER PROCEDURE ACT_MAGAZINE_STORE (
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'MAGAZINE')
AS
declare variable V_NOW_STATUS_ID type of ID_STATUS;
declare variable V_NEW_STATUS_ID type of ID_STATUS;
declare variable V_CATALOG_ID type of ID_CATALOG;
declare variable V_VALID_DATE type of DATE_VALID;
declare variable V_UPDATEABLE type of VALUE_BOOLEAN;
begin
  if (coalesce(i_object_id, 0) = 0) then i_object_id = gen_id(seq_magazine_id, 1);

  update paramheads set object_id = :i_object_id where param_id = :i_param_id;

  execute procedure param_set(:i_param_id, 'ID', :i_object_id);

  select status_id from magazines where magazine_id = :i_object_id into :v_now_status_id;

  if (v_now_status_id is null) then
  begin
    select o_value from param_get(:i_param_id, 'CATALOG_ID') into :v_catalog_id;
    select o_value from param_get(:i_param_id, 'VALID_DATE') into :v_valid_date;
    insert into magazines(magazine_id, catalog_id, valid_date, status_id)
      values(:i_object_id, :v_catalog_id, :v_valid_date, :v_new_status_id)
      returning status_id
      into :v_new_status_id;
    v_updateable = 1;
  end
  else
  begin
    select o_updateable, o_new_status_id
      from object_updateable(:i_param_id, :v_now_status_id, :i_object_sign)
      into :v_updateable, :v_new_status_id;
  end

  if (v_updateable = 1) then
  begin
    execute procedure param_set(:i_param_id, 'STATUS_ID', :v_new_status_id);
    execute procedure object_put(:i_param_id);
  end

end^


CREATE OR ALTER PROCEDURE ACT_MESSAGE_STORE (
    I_PARAM_ID TYPE OF ID_PARAM,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'MESSAGE')
AS
declare variable V_NOW_STATUS_ID type of ID_STATUS;
declare variable V_NEW_STATUS_ID type of ID_STATUS;
declare variable V_UPDATEABLE type of VALUE_BOOLEAN;
declare variable V_FILENAME type of NAME_FILE;
declare variable V_TEMPLATE_ID type of ID_TEMPLATE;
begin
  if (coalesce(i_object_id, 0) = 0) then i_object_id = gen_id(seq_message_id, 1);

  update paramheads set object_id = :i_object_id where param_id = :i_param_id;

  execute procedure param_set(:i_param_id, 'ID', :i_object_id);

  select status_id from messages where message_id = :i_object_id into :v_now_status_id;

  if (:v_now_status_id is null) then
  begin
    select o_value from param_get(:i_param_id, 'FILE_NAME') into :v_filename;
    select o_value from param_get(:i_param_id, 'TEMPLATE_ID') into :v_template_id;

    insert into messages(message_id, template_id, file_name, status_id)
      values(:i_object_id, :v_template_id, :v_filename, :v_new_status_id)
      returning status_id
      into :v_new_status_id;
    v_updateable = 1;
  end
  else
  begin
    select o_updateable, o_new_status_id
      from object_updateable(:i_param_id, :v_now_status_id, :i_object_sign)
      into :v_updateable, :v_new_status_id;
  end


  if (v_updateable = 1) then
  begin
    execute procedure param_set(:i_param_id, 'STATUS_ID', :v_new_status_id);
    execute procedure object_put(:i_param_id);
  end
end^


CREATE OR ALTER PROCEDURE ACT_MONEYBACK_CREATE (
    I_PARAM_ID TYPE OF ID_PARAM,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'MONEYBACK')
AS
declare variable V_REST_EUR type of MONEY_EUR;
declare variable V_AMOUNT_BYR type of MONEY_BYR;
declare variable V_ACCOUNT_ID type of ID_ACCOUNT;
declare variable V_REST_BYR type of MONEY_BYR;
declare variable V_BYR2EUR type of MONEY_BYR;
declare variable V_NOTES type of VALUE_ATTR;
declare variable V_MONEYBACK_KIND type of SIGN_ACTION;
declare variable V_PAYBYFIRM type of BOOLEAN;
begin
  if (coalesce(i_object_id, 0) = 0) then i_object_id = gen_id(seq_moneyback_id, 1);

  update paramheads set object_id = :i_object_id where param_id = :i_param_id;

  execute procedure param_set(:i_param_id, 'ID', :i_object_id);

  select o_value from param_get(:i_param_id, 'ACCOUNT_ID') into :v_account_id;
  select o_value from param_get(:i_param_id, 'KIND') into :v_moneyback_kind;
  select o_value from param_get(:i_param_id, 'PAYBYFIRM', '0') into :v_paybyfirm;

  select sum(ar.rest_byr)
    from accrests ar
    where ar.account_id = :v_account_id
    into :v_amount_byr;

  insert into moneybacks(moneyback_id, account_id, amount_byr, kind, paybyfirm)
    values(:i_object_id, :v_account_id, :v_amount_byr, :v_moneyback_kind, :v_paybyfirm);

  execute procedure object_put(:i_param_id);

  for select ar.rest_eur, ar.byr2eur, ar.rest_byr
    from accrests ar
    where ar.rest_eur <> 0
      and ar.account_id = :v_account_id
    into :v_rest_eur, :v_byr2eur, :v_rest_byr do
  begin
    select o_value from param_get(:i_param_id, 'NOTES') into :v_notes;
    select o_pattern from param_fill(:v_notes, 'AMOUNT_BYR', :v_amount_byr) into :v_notes;
    select o_pattern from param_fill(:v_notes, 'REST_BYR', :v_rest_byr) into :v_notes;
    select o_pattern from param_fill(:v_notes, 'REST_EUR', :v_rest_eur) into :v_notes;
    select o_pattern from param_fill(:v_notes, 'BYR2EUR', :v_byr2eur) into :v_notes;
    select o_pattern from param_fill(:v_notes, 'MONEYBACK_KIND', :v_moneyback_kind) into :v_notes;

    insert into accopers (account_id, amount_eur, byr2eur, notes)
      values (:v_account_id, -:v_rest_eur, :v_byr2eur, :v_notes);
  end
end^


CREATE OR ALTER PROCEDURE ACT_MONEYBACK_STORE (
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'MONEYBACK')
AS
declare variable V_NOW_STATUS_ID type of ID_STATUS;
declare variable V_NEW_STATUS_ID type of ID_STATUS;
declare variable V_UPDATEABLE type of VALUE_BOOLEAN;
declare variable V_AMOUNT_BYR type of MONEY_BYR;
declare variable V_ACCOUNT_ID type of ID_ACCOUNT;
begin
  if (coalesce(i_object_id, 0) = 0) then i_object_id = gen_id(seq_moneyback_id, 1);

  update paramheads set object_id = :i_object_id where param_id = :i_param_id;

  execute procedure param_set(:i_param_id, 'ID', :i_object_id);

  select status_id from moneybacks where moneyback_id = :i_object_id into :v_now_status_id;

  if (:v_now_status_id is null) then
  begin
    select o_value from param_get(:i_param_id, 'STATUS_ID') into :v_new_status_id;
    if (:v_new_status_id is null) then
       select s.status_id
         from param_get(:i_param_id, 'NEW.STATUS_SIGN') p
           inner join statuses s on (s.object_sign = :i_object_sign and s.status_sign = p.o_value)
       into :v_new_status_id;
    select o_value from param_get(:i_param_id, 'ACCOUNT_ID') into :v_account_id;
    select o_value from param_get(:i_param_id, 'AMOUNT_BYR') into :v_amount_byr;

    insert into moneybacks(moneyback_id, account_id, amount_byr, status_id)
      values(:i_object_id, :v_account_id, :v_amount_byr, :v_new_status_id)
      returning status_id
      into :v_new_status_id;
    v_updateable = 1;
  end
  else
  begin
    select o_updateable, o_new_status_id
      from object_updateable(:i_param_id, :v_now_status_id, :i_object_sign)
      into :v_updateable, :v_new_status_id;
  end
  if (v_updateable = 1) then
  begin
    execute procedure param_set(:i_param_id, 'STATUS_ID', :v_new_status_id);
    execute procedure object_put(:i_param_id);
  end
end^


CREATE OR ALTER PROCEDURE ACT_ORDER_4_ORDERITEM_INSTATUS (
    I_PARAM_ID TYPE OF ID_PARAM,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'ORDERITEM')
AS
declare variable V_PARAM_ID type of ID_PARAM;
declare variable V_ACTION_SIGN type of SIGN_ACTION;
declare variable V_OBJECT_ID type of ID_OBJECT;
declare variable V_NEW_STATUS_SIGN type of SIGN_ATTR;
declare variable V_ACTION_ID type of ID_ACTION;
declare variable V_ACTIONTREEITEM_ID type of ID_ACTIONTREEITEM;
declare variable V_NEW_FLAG_SIGN type of SIGN_OBJECT;
declare variable V_STATUS_SIGN_LIST type of LIST_SIGNS;
begin
  select o_value from param_get(:i_param_id, 'STATUS_SIGN_LIST') into :v_status_sign_list;
  select o_value from param_get(:i_param_id, 'NEW.STATUS_SIGN') into :v_new_status_sign;
  select o_value from param_get(:i_param_id, 'NEW.FLAG_SIGN') into :v_new_flag_sign;
  select o_value from param_get(:i_param_id, 'ACTIONTREEITEM_ID') into :v_actiontreeitem_id;

  for select oi.orderitem_id
        from orderitems oi
          inner join statuses s on (s.status_id = oi.status_id)
        where oi.order_id = :i_object_id
          and ','||:v_status_sign_list||',' like '%,'||s.status_sign||',%'
        into :v_object_id do
  begin
    select o_param_id from param_create(:i_object_sign, :v_object_id) into :v_param_id;
    insert into params(param_id, param_name, param_value)
      select :v_param_id, p.param_name, p.param_value
        from params p
          inner join actiontree_params atp on (atp.param_name = p.param_name)
        where p.param_id = :i_param_id
          and atp.actiontreeitem_id = :v_actiontreeitem_id;

    select o_action_sign from action_detect(:i_object_sign, :v_object_id, :v_new_status_sign, :v_new_flag_sign, 0)
      into :v_action_sign;

    if (:v_action_sign is null) then
      select o_value from param_get(:i_param_id, 'ACTION_SIGN') into :v_action_sign;

    if (v_action_sign is not null) then
      execute procedure action_run(:i_object_sign, :v_action_sign, :v_param_id, :v_object_id)
        returning_values :v_action_id;
  end
end^


CREATE OR ALTER PROCEDURE ACT_ORDER_4_ORDERITEM_NINSTATUS (
    I_PARAM_ID TYPE OF ID_PARAM,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT DEFAULT 'ORDERITEM')
AS
declare variable V_PARAM_ID type of ID_PARAM;
declare variable V_ACTION_SIGN type of SIGN_ACTION;
declare variable V_OBJECT_ID type of ID_OBJECT;
declare variable V_NEW_STATUS_SIGN type of SIGN_ATTR;
declare variable V_ACTION_ID type of ID_ACTION;
declare variable V_ACTIONTREEITEM_ID type of ID_ACTIONTREEITEM;
declare variable V_NEW_FLAG_SIGN type of SIGN_OBJECT;
declare variable V_STATUS_SIGN_LIST type of LIST_SIGNS;
begin
  select o_value from param_get(:i_param_id, 'STATUS_SIGN_LIST') into :v_status_sign_list;
  select o_value from param_get(:i_param_id, 'NEW.STATUS_SIGN') into :v_new_status_sign;
  select o_value from param_get(:i_param_id, 'NEW.FLAG_SIGN') into :v_new_flag_sign;
  select o_value from param_get(:i_param_id, 'ACTIONTREEITEM_ID') into :v_actiontreeitem_id;

  for select oi.orderitem_id
        from orderitems oi
          inner join statuses s on (s.status_id = oi.status_id)
        where oi.order_id = :i_object_id
          and ','||:v_status_sign_list||',' like '%,'||s.status_sign||',%'
        into :v_object_id do
  begin
    select o_param_id from param_create(:i_object_sign, :v_object_id) into :v_param_id;
    insert into params(param_id, param_name, param_value)
      select :v_param_id, p.param_name, p.param_value
        from params p
          inner join actiontree_params atp on (atp.param_name = p.param_name)
        where p.param_id = :i_param_id
          and atp.actiontreeitem_id = :v_actiontreeitem_id;

    select o_action_sign from action_detect(:i_object_sign, :v_object_id, :v_new_status_sign, :v_new_flag_sign, 0)
      into :v_action_sign;

    if (:v_action_sign is null) then
      select o_value from param_get(:i_param_id, 'ACTION_SIGN') into :v_action_sign;

    if (v_action_sign is not null) then
      execute procedure action_run(:i_object_sign, :v_action_sign, :v_param_id, :v_object_id)
        returning_values :v_action_id;
  end
end^


CREATE OR ALTER PROCEDURE ACT_ORDER_DEBIT (
    I_PARAM_ID TYPE OF ID_PARAM,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'ORDER')
AS
declare variable V_PARAM_ID type of ID_PARAM;
declare variable V_ACTION_SIGN type of SIGN_ACTION;
declare variable V_OBJECT_ID type of ID_OBJECT;
declare variable V_NEW_STATUS_SIGN type of SIGN_ATTR;
declare variable V_ACTION_ID type of ID_ACTION;
declare variable V_ACTIONTREEITEM_ID type of ID_ACTIONTREEITEM;
declare variable V_NEW_FLAG_SIGN type of SIGN_OBJECT;
begin
  select o_value from param_get(:i_param_id, 'NEW.STATUS_SIGN') into :v_new_status_sign;
  select o_value from param_get(:v_param_id, 'NEW.FLAG_SIGN') into :v_new_flag_sign;
  select o_value from param_get(:i_param_id, 'ACTIONTREEITEM_ID') into :v_actiontreeitem_id;

  for select oi.orderitem_id
        from orderitems oi
        where oi.order_id = :i_object_id
        into :v_object_id do
  begin
    select o_param_id from param_create(:i_object_sign, :v_object_id) into :v_param_id;
    insert into params(param_id, param_name, param_value)
      select :v_param_id, p.param_name, p.param_value
        from params p
          inner join actiontree_params atp on (atp.param_name = p.param_name)
        where p.param_id = :i_param_id
          and atp.actiontreeitem_id = :v_actiontreeitem_id;

    select o_action_sign from action_detect(:i_object_sign, :v_object_id, :v_new_status_sign, :v_new_flag_sign, 0)
      into :v_action_sign;

    if (:v_action_sign is null) then
      select o_value from param_get(:i_param_id, 'ACTION_SIGN') into :v_action_sign;

    if (v_action_sign is not null) then
      execute procedure action_run(:i_object_sign, :v_action_sign, :v_param_id, :v_object_id)
        returning_values :v_action_id;
  end
end^


CREATE OR ALTER PROCEDURE ACT_ORDER_DELETE (
    I_PARAM_ID TYPE OF ID_PARAM,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'ORDER')
AS
declare variable V_PARAM_ID type of ID_PARAM;
declare variable V_ACTION_SIGN type of SIGN_ACTION;
declare variable V_OBJECT_ID type of ID_OBJECT;
declare variable V_NEW_STATUS_SIGN type of SIGN_ATTR;
declare variable V_ACTION_ID type of ID_ACTION;
declare variable V_ACTIONTREEITEM_ID type of ID_ACTIONTREEITEM;
declare variable V_NEW_FLAG_SIGN type of SIGN_OBJECT;
begin
  select o_value from param_get(:i_param_id, 'NEW.STATUS_SIGN') into :v_new_status_sign;
  select o_value from param_get(:v_param_id, 'NEW.FLAG_SIGN') into :v_new_flag_sign;
  select o_value from param_get(:i_param_id, 'ACTIONTREEITEM_ID') into :v_actiontreeitem_id;

  for select oi.orderitem_id
        from orderitems oi
        where oi.order_id = :i_object_id
        into :v_object_id do
  begin
    select o_param_id from param_create(:i_object_sign, :v_object_id) into :v_param_id;
    insert into params(param_id, param_name, param_value)
      select :v_param_id, p.param_name, p.param_value
        from params p
          inner join actiontree_params atp on (atp.param_name = p.param_name)
        where p.param_id = :i_param_id
          and atp.actiontreeitem_id = :v_actiontreeitem_id;

    select o_action_sign from action_detect(:i_object_sign, :v_object_id, :v_new_status_sign, :v_new_flag_sign, 0)
      into :v_action_sign;

    if (:v_action_sign is null) then
      select o_value from param_get(:i_param_id, 'ACTION_SIGN') into :v_action_sign;

    if (v_action_sign is not null) then
      execute procedure action_run(:i_object_sign, :v_action_sign, :v_param_id, :v_object_id)
        returning_values :v_action_id;
  end
end^


CREATE OR ALTER PROCEDURE ACT_ORDER_FOREACH_ORDERITEM (
    I_PARAM_ID TYPE OF ID_PARAM,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'ORDERITEM')
AS
declare variable V_PARAM_ID type of ID_PARAM;
declare variable V_ACTION_SIGN type of SIGN_ACTION;
declare variable V_OBJECT_ID type of ID_OBJECT;
declare variable V_NEW_STATUS_SIGN type of SIGN_ATTR;
declare variable V_ACTION_ID type of ID_ACTION;
declare variable V_ACTIONTREEITEM_ID type of ID_ACTIONTREEITEM;
declare variable V_NEW_FLAG_SIGN type of SIGN_OBJECT;
begin
  select o_value from param_get(:i_param_id, 'NEW.STATUS_SIGN') into :v_new_status_sign;
  select o_value from param_get(:i_param_id, 'NEW.FLAG_SIGN') into :v_new_flag_sign;
  select o_value from param_get(:i_param_id, 'ACTIONTREEITEM_ID') into :v_actiontreeitem_id;

  for select oi.orderitem_id
        from orderitems oi
        where oi.order_id = :i_object_id
        into :v_object_id do
  begin
    select o_param_id from param_create(:i_object_sign, :v_object_id) into :v_param_id;
    insert into params(param_id, param_name, param_value)
      select :v_param_id, p.param_name, p.param_value
        from params p
          inner join actiontree_params atp on (atp.param_name = p.param_name)
        where p.param_id = :i_param_id
          and atp.actiontreeitem_id = :v_actiontreeitem_id;

    select o_action_sign from action_detect(:i_object_sign, :v_object_id, :v_new_status_sign, :v_new_flag_sign, 0)
      into :v_action_sign;

    if (:v_action_sign is null) then
      select o_value from param_get(:i_param_id, 'ACTION_SIGN') into :v_action_sign;

    if (v_action_sign is not null) then
      execute procedure action_run(:i_object_sign, :v_action_sign, :v_param_id, :v_object_id)
        returning_values :v_action_id;
  end
end^


CREATE OR ALTER PROCEDURE ACT_ORDER_FOREACH_ORDERTAX (
    I_PARAM_ID TYPE OF ID_PARAM,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'ORDERTAX')
AS
declare variable V_PARAM_ID type of ID_PARAM;
declare variable V_ACTION_SIGN type of SIGN_ACTION;
declare variable V_OBJECT_ID type of ID_OBJECT;
declare variable V_NEW_STATUS_SIGN type of SIGN_ATTR;
declare variable V_ACTION_ID type of ID_ACTION;
declare variable V_ACTIONTREEITEM_ID type of ID_ACTIONTREEITEM;
declare variable V_NEW_FLAG_SIGN type of SIGN_OBJECT;
begin
  select o_value from param_get(:i_param_id, 'NEW.STATUS_SIGN') into :v_new_status_sign;
  select o_value from param_get(:i_param_id, 'NEW.FLAG_SIGN') into :v_new_flag_sign;
  select o_value from param_get(:i_param_id, 'ACTIONTREEITEM_ID') into :v_actiontreeitem_id;

  for select ordertax_id
        from ordertaxs
        where order_id = :i_object_id
        into :v_object_id do
  begin
    select o_param_id from param_create(:i_object_sign, :v_object_id) into :v_param_id;
    insert into params(param_id, param_name, param_value)
      select :v_param_id, p.param_name, p.param_value
        from params p
          inner join actiontree_params atp on (atp.param_name = p.param_name)
        where p.param_id = :i_param_id
          and atp.actiontreeitem_id = :v_actiontreeitem_id;

    select o_action_sign from action_detect(:i_object_sign, :v_object_id, :v_new_status_sign, :v_new_flag_sign, 0)
      into :v_action_sign;

    if (:v_action_sign is null) then
      select o_value from param_get(:i_param_id, 'ACTION_SIGN') into :v_action_sign;

    if (v_action_sign is not null) then
      execute procedure action_run(:i_object_sign, :v_action_sign, :v_param_id, :v_object_id)
        returning_values :v_action_id;
  end
end^


CREATE OR ALTER PROCEDURE ACT_ORDER_FOREACH_TAXRATE (
    I_PARAM_ID TYPE OF ID_PARAM,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'ORDERTAX')
AS
declare variable V_PARAM_ID type of ID_PARAM;
declare variable V_ACTION_SIGN type of SIGN_ACTION;
declare variable V_NEW_STATUS_SIGN type of SIGN_ATTR;
declare variable V_ACTION_ID type of ID_ACTION;
declare variable V_TAXRATE_ID type of ID_TAX;
declare variable V_TAX_PROCEDURE type of NAME_PROCEDURE;
declare variable V_COST_EUR type of MONEY_EUR;
declare variable V_OBJECT_ID type of ID_OBJECT;
declare variable V_ACTIONTREEITEM_ID type of ID_ACTIONTREEITEM;
declare variable V_NEW_FLAG_SIGN type of SIGN_OBJECT;
declare variable V_CALCPOINT_ID type of ID_CALCPOINT;
begin
  select o_value from param_get(:i_param_id, 'NEW.STATUS_SIGN') into :v_new_status_sign;
  select o_value from param_get(:i_param_id, 'ACTIONTREEITEM_ID') into :v_actiontreeitem_id;
  select o_value from param_get(:i_param_id, 'NEW.FLAG_SIGN') into :v_new_flag_sign;
  select o_value from param_get(:i_param_id, 'CALCPOINT_ID') into :v_calcpoint_id;

  for select tr.taxrate_id, tr.tax_procedure
    from orders o
      inner join calcpoints cp on (cp.object_status_id = o.status_id)
      inner join taxservs ts on (ts.calcpoint_id = cp.calcpoint_id)
      inner join taxrates tr on (tr.taxserv_id = ts.taxserv_id and tr.taxplan_id = o.taxplan_id)
      left join ordertaxs ot on (ot.order_id = o.order_id and ot.taxrate_id = tr.taxrate_id)
    where o.order_id = :i_object_id
      and ot.ordertax_id is null
    into :v_taxrate_id, :v_tax_procedure do
  begin
    v_object_id = gen_id(seq_ordertax_id, 1);

    select o_param_id from param_create(:i_object_sign, :v_object_id) into :v_param_id;

    insert into params(param_id, param_name, param_value)
    select :v_param_id, p.param_name, p.param_value
      from params p
        inner join actiontree_params atp on (atp.param_name = p.param_name)
      where p.param_id = :i_param_id
        and atp.actiontreeitem_id = :v_actiontreeitem_id
        and p.param_name not in (select param_name from params where param_id = :v_param_id);

    execute statement ('select o_cost_eur from '||v_tax_procedure||'(:taxrate_id, :param_id)')
      (taxrate_id := :v_taxrate_id, param_id := :v_param_id)
      into :v_cost_eur;
    select o_action_sign from action_detect(:i_object_sign, :v_object_id, :v_new_status_sign, :v_new_flag_sign, 0)
      into :v_action_sign;

    if (v_action_sign is not null) then
    begin
      execute procedure param_set(:v_param_id, 'TAXRATE_ID', :v_taxrate_id);
      execute procedure action_run(:i_object_sign, :v_action_sign, :v_param_id, :v_object_id)
        returning_values :v_action_id;
    end
  end
end^


CREATE OR ALTER PROCEDURE ACT_ORDER_RENEW (
    I_PARAM_ID TYPE OF ID_PARAM,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'ORDER')
AS
declare variable V_STATUS_ID type of ID_STATUS;
declare variable V_PRODUCT_ID type of ID_PRODUCT;
declare variable V_TAXPLAN_ID type of ID_TAXPLAN;
begin
  select o_value from param_get(:i_param_id, 'PRODUCT_ID') into :v_product_id;
  select o_value from param_get(:i_param_id, 'TAXPLAN_ID') into :v_taxplan_id;

  delete from ordertaxs ot where ot.order_id = :i_object_id;

  select status_id
    from statuses s
    where s.object_sign = :i_object_sign
      and s.status_sign = 'NEW'
    into :v_status_id;

  update orders o
    set o.order_code = null,
        o.status_id = :v_status_id,
        o.state_id = null,
        o.product_id = :v_product_id,
        o.taxplan_id = :v_taxplan_id
    where o.order_id = :i_object_id;

end^


CREATE OR ALTER PROCEDURE ACT_ORDER_STORE (
    I_PARAM_ID TYPE OF ID_PARAM,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'ORDER')
AS
declare variable V_NOW_STATUS_ID type of ID_STATUS;
declare variable V_NEW_STATUS_ID type of ID_STATUS;
declare variable V_UPDATEABLE type of VALUE_BOOLEAN;
declare variable V_CALCPOINT_ID type of ID_CALCPOINT;
declare variable V_NEW_STATE_SIGN type of SIGN_OBJECT;
declare variable V_NEW_STATE_ID type of ID_STATUS;
begin
  if (coalesce(i_object_id, 0) = 0) then i_object_id = gen_id(seq_order_id, 1);

  update paramheads set object_id = :i_object_id where param_id = :i_param_id;

  execute procedure param_set(:i_param_id, 'ID', :i_object_id);

  select oi.status_id from orders oi where oi.order_id = :i_object_id into :v_now_status_id;

  if (:v_now_status_id is null) then
  begin
    insert into orders(order_id, status_id)
      values(:i_object_id, :v_new_status_id)
      returning status_id
      into :v_new_status_id;
    v_updateable = 1;
  end
  else
  begin
    select o_updateable, o_new_status_id
      from object_updateable(:i_param_id, :v_now_status_id, :i_object_sign)
      into :v_updateable, :v_new_status_id;
  end

  select o_value from param_get(:i_param_id,  'NEW.STATE_SIGN') into :v_new_state_sign;
  if (:v_new_state_sign is not null) then
  begin
    v_updateable = 1;
    if (upper(:v_new_state_sign) = 'NULL') then
      v_new_state_id = null;
    else
      select s.status_id
        from statuses s
        where s.object_sign = :i_object_sign
          and s.status_sign = :v_new_state_sign
        into :v_new_state_id;
    execute procedure param_set(:i_param_id, 'STATE_ID', :v_new_state_id);
  end

  if (v_updateable = 1) then
  begin
    select cp.calcpoint_id
      from calcpoints cp
      where cp.object_status_id = :v_new_status_id
      into :v_calcpoint_id;
    execute procedure param_set(:i_param_id, 'CALCPOINT_ID', :v_calcpoint_id);

    execute procedure param_set(:i_param_id, 'STATUS_ID', :v_new_status_id);
    execute procedure object_put(:i_param_id);

    execute procedure orderhistory_update(:i_object_id, :v_new_status_id, :v_new_state_id);
  end
  else
    exception ex_status_conversion_unavail 'From '||:v_now_status_id||' to '||:v_new_status_id;
end^


CREATE OR ALTER PROCEDURE ACT_ORDER_UPDATECOST (
    I_PARAM_ID TYPE OF ID_PARAM,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'ORDERITEM')
AS
declare variable V_PARAM_ID type of ID_PARAM;
declare variable V_ACTION_SIGN type of SIGN_ACTION;
declare variable V_OBJECT_ID type of ID_OBJECT;
declare variable V_NEW_STATUS_SIGN type of SIGN_ATTR;
declare variable V_ACTION_ID type of ID_ACTION;
declare variable V_ACTIONTREEITEM_ID type of ID_ACTIONTREEITEM;
declare variable V_NEW_FLAG_SIGN type of SIGN_OBJECT;
begin
  select o_value from param_get(:i_param_id, 'NEW.STATUS_SIGN') into :v_new_status_sign;
  select o_value from param_get(:v_param_id, 'NEW.FLAG_SIGN') into :v_new_flag_sign;
  select o_value from param_get(:i_param_id, 'ACTIONTREEITEM_ID') into :v_actiontreeitem_id;

  for select oi.orderitem_id
        from orderitems oi
        where oi.order_id = :i_object_id
        into :v_object_id do
  begin
    select o_param_id from param_create(:i_object_sign, :v_object_id) into :v_param_id;
    insert into params(param_id, param_name, param_value)
      select :v_param_id, p.param_name, p.param_value
        from params p
          inner join actiontree_params atp on (atp.param_name = p.param_name)
        where p.param_id = :i_param_id
          and atp.actiontreeitem_id = :v_actiontreeitem_id;

    select o_action_sign from action_detect(:i_object_sign, :v_object_id, :v_new_status_sign, :v_new_flag_sign, 0)
      into :v_action_sign;

    if (:v_action_sign is null) then
      select o_value from param_get(:i_param_id, 'ACTION_SIGN') into :v_action_sign;

    if (v_action_sign is not null) then
      execute procedure action_run(:i_object_sign, :v_action_sign, :v_param_id, :v_object_id)
        returning_values :v_action_id;
  end
end^


CREATE OR ALTER PROCEDURE ACT_ORDERITEM_STORE (
    I_PARAM_ID TYPE OF ID_PARAM,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'ORDERITEM')
AS
declare variable V_NOW_STATUS_ID type of ID_STATUS;
declare variable V_NEW_STATUS_ID type of ID_STATUS;
declare variable V_ORDER_ID type of ID_ORDER;
declare variable V_ARTICLE_ID type of ID_ARTICLE;
declare variable V_UPDATEABLE type of VALUE_BOOLEAN;
declare variable V_NEW_STATE_ID type of ID_STATUS;
declare variable V_NEW_STATE_SIGN type of SIGN_OBJECT;
begin
  if (coalesce(i_object_id, 0) = 0) then i_object_id = gen_id(seq_orderitem_id, 1);

  update paramheads set object_id = :i_object_id where param_id = :i_param_id;

  execute procedure param_set(:i_param_id, 'ID', :i_object_id);

  select status_id from orderitems where orderitem_id = :i_object_id into :v_now_status_id;

  if (:v_now_status_id is null) then
  begin
    select o_value from param_get(:i_param_id, 'STATUS_ID') into :v_new_status_id;
    if (:v_new_status_id is null) then
       select s.status_id
         from param_get(:i_param_id, 'NEW.STATUS_SIGN') p
           inner join statuses s on (s.object_sign = :i_object_sign and s.status_sign = p.o_value)
       into :v_new_status_id;

    select o_value from param_get(:i_param_id, 'ORDER_ID') into :v_order_id;

    insert into orderitems(orderitem_id, order_id, status_id)
      values(:i_object_id, :v_order_id, :v_new_status_id)
      returning status_id
      into :v_new_status_id;
    v_updateable = 1;
  end
  else
  begin
    select o_updateable, o_new_status_id
      from object_updateable(:i_param_id, :v_now_status_id, :i_object_sign)
      into :v_updateable, :v_new_status_id;

    select oi.order_id
      from orderitems oi
      where oi.orderitem_id = :i_object_id
      into :v_order_id;
  end

  select o_value from param_get(:i_param_id,  'NEW.STATE_SIGN') into :v_new_state_sign;
  if (:v_new_state_sign is not null) then
  begin
    v_updateable = 1;
    if (upper(:v_new_state_sign) = 'NULL') then
      v_new_state_id = null;
    else
      select s.status_id
        from statuses s
        where s.object_sign = :i_object_sign
          and s.status_sign = :v_new_state_sign
        into :v_new_state_id;
    execute procedure param_set(:i_param_id, 'STATE_ID', :v_new_state_id);
  end

  if (v_updateable = 1) then
  begin
    execute procedure param_set(:i_param_id, 'STATUS_ID', :v_new_status_id);
    execute procedure object_put(:i_param_id);
  end
end^


CREATE OR ALTER PROCEDURE ACT_ORDERMONEY_CREDIT (
    I_PARAM_ID TYPE OF ID_PARAM,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'ORDERMONEY')
AS
declare variable V_NOW_STATUS_ID type of ID_STATUS;
declare variable V_ORDER_ID type of ID_ORDER;
declare variable V_UPDATEABLE type of VALUE_BOOLEAN;
declare variable V_NEW_STATUS_ID type of ID_STATUS;
declare variable V_ACCOUNT_ID type of ID_ACCOUNT;
begin
  if (coalesce(i_object_id, 0) = 0) then i_object_id = gen_id(seq_ordermoney_id, 1);
    
  update paramheads set object_id = :i_object_id where param_id = :i_param_id;
    
  execute procedure param_set(:i_param_id, 'ID', :i_object_id);
    
  select status_id from ordermoneys where ordermoney_id = :i_object_id into :v_now_status_id;

  if (:v_now_status_id is null) then
  begin
    select o_value from param_get(:i_param_id, 'ACCOUNT_ID') into :v_account_id;
    select o_value from param_get(:i_param_id, 'ORDER_ID') into :v_order_id;

    insert into ordermoneys(ordermoney_id, order_id, account_id, status_id)
      values(:i_object_id, :v_order_id, :v_account_id, :v_new_status_id)
      returning status_id
      into :v_new_status_id;
    v_updateable = 1;
  end
  else
  begin
    select o_updateable, o_new_status_id
      from object_updateable(:i_param_id, :v_now_status_id, :i_object_sign)
      into :v_updateable, :v_new_status_id;
  end

  if ((v_updateable = 1) or exists(select o_value from param_get(:i_param_id, 'UPDATEABLE'))) then
  begin
    execute procedure param_set(:i_param_id, 'STATUS_ID', :v_new_status_id);
    execute procedure object_put(:i_param_id);
  end
end^


CREATE OR ALTER PROCEDURE ACT_ORDERMONEY_DEBIT (
    I_PARAM_ID TYPE OF ID_PARAM,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'ORDERMONEY')
AS
declare variable V_NOW_STATUS_ID type of ID_STATUS;
declare variable V_ORDER_ID type of ID_ORDER;
declare variable V_UPDATEABLE type of VALUE_BOOLEAN;
declare variable V_NEW_STATUS_ID type of ID_STATUS;
declare variable V_ACCOUNT_ID type of ID_ACCOUNT;
begin
  if (coalesce(i_object_id, 0) = 0) then i_object_id = gen_id(seq_ordermoney_id, 1);
    
  update paramheads set object_id = :i_object_id where param_id = :i_param_id;
    
  execute procedure param_set(:i_param_id, 'ID', :i_object_id);
    
  select status_id from ordermoneys where ordermoney_id = :i_object_id into :v_now_status_id;

  if (:v_now_status_id is null) then
  begin
    select o_value from param_get(:i_param_id, 'ACCOUNT_ID') into :v_account_id;
    select o_value from param_get(:i_param_id, 'ORDER_ID') into :v_order_id;

    insert into ordermoneys(ordermoney_id, order_id, account_id, status_id)
      values(:i_object_id, :v_order_id, :v_account_id, :v_new_status_id)
      returning status_id
      into :v_new_status_id;
    v_updateable = 1;
  end
  else
  begin
    select o_updateable, o_new_status_id
      from object_updateable(:i_param_id, :v_now_status_id, :i_object_sign)
      into :v_updateable, :v_new_status_id;
  end

  if ((v_updateable = 1) or exists(select o_value from param_get(:i_param_id, 'UPDATEABLE'))) then
  begin
    execute procedure param_set(:i_param_id, 'STATUS_ID', :v_new_status_id);
    execute procedure object_put(:i_param_id);
  end
end^


CREATE OR ALTER PROCEDURE ACT_ORDERMONEY_STORE (
    I_PARAM_ID TYPE OF ID_PARAM,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'ORDERMONEY')
AS
declare variable V_NOW_STATUS_ID type of ID_STATUS;
declare variable V_ORDER_ID type of ID_ORDER;
declare variable V_UPDATEABLE type of VALUE_BOOLEAN;
declare variable V_NEW_STATUS_ID type of ID_STATUS;
declare variable V_ACCOUNT_ID type of ID_ACCOUNT;
begin
  if (coalesce(i_object_id, 0) = 0) then i_object_id = gen_id(seq_ordermoney_id, 1);
    
  update paramheads set object_id = :i_object_id where param_id = :i_param_id;
    
  execute procedure param_set(:i_param_id, 'ID', :i_object_id);
    
  select status_id from ordermoneys where ordermoney_id = :i_object_id into :v_now_status_id;

  if (:v_now_status_id is null) then
  begin
    select o_value from param_get(:i_param_id, 'ACCOUNT_ID') into :v_account_id;
    select o_value from param_get(:i_param_id, 'ORDER_ID') into :v_order_id;

    insert into ordermoneys(ordermoney_id, order_id, account_id, status_id)
      values(:i_object_id, :v_order_id, :v_account_id, :v_new_status_id)
      returning status_id
      into :v_new_status_id;
    v_updateable = 1;
  end
  else
  begin
    select o_updateable, o_new_status_id
      from object_updateable(:i_param_id, :v_now_status_id, :i_object_sign)
      into :v_updateable, :v_new_status_id;
  end

  if ((v_updateable = 1) or exists(select o_value from param_get(:i_param_id, 'UPDATEABLE'))) then
  begin
    execute procedure param_set(:i_param_id, 'STATUS_ID', :v_new_status_id);
    execute procedure object_put(:i_param_id);
  end
end^


CREATE OR ALTER PROCEDURE ACT_ORDERTAX_STORE (
    I_PARAM_ID TYPE OF ID_PARAM,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'ORDERTAX')
AS
declare variable V_NOW_STATUS_ID type of ID_STATUS;
declare variable V_ORDER_ID type of ID_ORDER;
declare variable V_UPDATEABLE type of VALUE_BOOLEAN;
declare variable V_NEW_STATUS_ID type of ID_STATUS;
declare variable V_TAXRATE_ID type of ID_TAX;
declare variable V_TAXPLAN_ID type of ID_TAX;
declare variable V_TAX_PROCEDURE type of NAME_PROCEDURE;
declare variable V_PRICE_EUR type of MONEY_EUR;
declare variable V_AMOUNT type of VALUE_INTEGER;
declare variable V_CALCPOINT_ID type of ID_CALCPOINT;
begin
  if (coalesce(i_object_id, 0) = 0) then i_object_id = gen_id(seq_ordertax_id, 1);
    
  update paramheads set object_id = :i_object_id where param_id = :i_param_id;
    
  execute procedure param_set(:i_param_id, 'ID', :i_object_id);
    
  select status_id from ordertaxs where ordertax_id = :i_object_id into :v_now_status_id;

  if (:v_now_status_id is null) then
  begin
    select o_value from param_get(:i_param_id, 'TAXRATE_ID') into :v_taxrate_id;
    select o_value from param_get(:i_param_id, 'ORDER_ID') into :v_order_id;

    insert into ordertaxs(ordertax_id, order_id, taxrate_id, status_id)
      values(:i_object_id, :v_order_id, :v_taxrate_id, :v_new_status_id)
      returning status_id
      into :v_new_status_id;
    v_updateable = 1;
  end
  else
  begin
    select o_updateable, o_new_status_id
      from object_updateable(:i_param_id, :v_now_status_id, :i_object_sign)
      into :v_updateable, :v_new_status_id;
  end

  if (v_updateable = 1) then
  begin
    execute procedure param_set(:i_param_id, 'STATUS_ID', :v_new_status_id);
    execute procedure object_put(:i_param_id);
  end
  else
    exception ex_status_conversion_unavail 'From '||:v_now_status_id||' to '||:v_new_status_id;

end^


CREATE OR ALTER PROCEDURE ACT_PAYMENT_STORE (
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL,
    I_OBJECT_ID TYPE OF ID_OBJECT NOT NULL,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'PAYMENT')
AS
declare variable V_NOW_STATUS_ID type of ID_STATUS;
declare variable V_NEW_STATUS_ID type of ID_STATUS;
declare variable V_UPDATEABLE type of VALUE_BOOLEAN;
declare variable V_AMOUNT_BYR type of MONEY_BYR;
declare variable V_MESSAGE_ID type of ID_MESSAGE;
declare variable V_CREATE_DT type of DT_INVOICE;
begin
  if (coalesce(i_object_id, 0) = 0) then i_object_id = gen_id(seq_payment_id, 1);

  update paramheads set object_id = :i_object_id where param_id = :i_param_id;

  execute procedure param_set(:i_param_id, 'ID', :i_object_id);

  select status_id from payments where payment_id = :i_object_id into :v_now_status_id;

  if (:v_now_status_id is null) then
  begin
    select o_value from param_get(:i_param_id, 'STATUS_ID') into :v_new_status_id;
    if (:v_new_status_id is null) then
       select s.status_id
         from param_get(:i_param_id, 'NEW.STATUS_SIGN') p
           inner join statuses s on (s.object_sign = :i_object_sign and s.status_sign = p.o_value)
       into :v_new_status_id;
    select o_value from param_get(:i_param_id, 'MESSAGE_ID') into :v_message_id;
    select o_value from param_get(:i_param_id, 'AMOUNT_BYR') into :v_amount_byr;
    select o_value from param_get(:i_param_id, 'CREATE_DT') into :v_create_dt;

    insert into payments(payment_id, message_id, create_dt, amount_byr, status_id)
      values(:i_object_id, :v_message_id, :v_create_dt, :v_amount_byr, :v_new_status_id)
      returning status_id
      into :v_new_status_id;
    v_updateable = 1;
  end
  else
  begin
    select o_updateable, o_new_status_id
      from object_updateable(:i_param_id, :v_now_status_id, :i_object_sign)
      into :v_updateable, :v_new_status_id;
  end
  if (v_updateable = 1) then
  begin
    execute procedure param_set(:i_param_id, 'STATUS_ID', :v_new_status_id);
    execute procedure object_put(:i_param_id);
  end
end^


CREATE OR ALTER PROCEDURE ACT_PLACE_STORE (
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'PLACE')
AS
declare variable V_NOW_STATUS_ID type of ID_STATUS;
declare variable V_OWNER_PLACE_ID type of ID_PLACE;
declare variable V_PLACETYPE_CODE type of CODE_PLACETYPE;
declare variable V_PLACE_NAME type of NAME_REF;
declare variable V_NEW_STATUS_ID type of ID_STATUS;
declare variable V_UPDATEABLE type of VALUE_BOOLEAN;
begin
  if (coalesce(i_object_id, 0) = 0) then i_object_id = gen_id(seq_place_id, 1);

  update paramheads set object_id = :i_object_id where param_id = :i_param_id;

  execute procedure param_set(:i_param_id, 'ID', :i_object_id);

  select status_id from places where place_id = :i_object_id into :v_now_status_id;

  if (:v_now_status_id is null) then
  begin
    select o_value from param_get(:i_param_id, 'AREA_ID') into :v_owner_place_id;
    select o_value from param_get(:i_param_id, 'PLACETYPE_CODE') into :v_placetype_code;
    select o_value from param_get(:i_param_id, 'PLACE_NAME') into :v_place_name;

    insert into places(place_id, placetype_code, owner_place, place_name)
      values(:i_object_id, :v_placetype_code, :v_owner_place_id, :v_place_name)
      returning status_id
      into :v_new_status_id;
    v_updateable = 1;
  end
  else
  begin
    select o_updateable, o_new_status_id
      from object_updateable(:i_param_id, :v_now_status_id, :i_object_sign)
      into :v_updateable, :v_new_status_id;
  end

  if (v_updateable = 1) then
  begin
    execute procedure param_set(:i_param_id, 'STATUS_ID', :v_new_status_id);
    execute procedure object_put(:i_param_id);
  end
end^


CREATE OR ALTER PROCEDURE ACTION_DETECT (
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT NOT NULL,
    I_OBJECT_ID TYPE OF ID_OBJECT NOT NULL,
    I_NEW_STATUS_SIGN TYPE OF SIGN_OBJECT,
    I_NEW_FLAG_SIGN TYPE OF SIGN_OBJECT,
    I_STRONG_FLAG TYPE OF VALUE_BOOLEAN)
RETURNS (
    O_ACTION_SIGN TYPE OF SIGN_ACTION)
AS
declare variable V_TABLE_NAME type of NAME_PROCEDURE;
declare variable V_IDFIELD_NAME type of NAME_PROCEDURE;
declare variable V_SQL type of SQL_STATEMENT;
declare variable V_NEW_STATUS_ID type of ID_STATUS;
declare variable V_NOW_STATUS_ID type of ID_STATUS;
declare variable V_NOW_STATUS_SIGN type of SIGN_OBJECT;
declare variable V_ERROR_MESSAGE type of RDB$MESSAGE;
declare variable V_ERROR type of VALUE_ATTR;
begin
  i_object_sign = trim(i_object_sign);
  -- get current status_id
  select o.table_name, o.idfield_name
    from objects o
    where o.object_sign = :i_object_sign
    into :v_table_name, :v_idfield_name;

  v_sql = 'select status_id from '||v_table_name||' where '||v_idfield_name||' = :object_id';

  execute statement (:v_sql) (object_id := :i_object_id)
    into :v_now_status_id;

  select s.status_sign
    from statuses s
    where s.status_id = :v_now_status_id
      and s.object_sign = :i_object_sign
    into :v_now_status_sign;

  if (:i_new_status_sign is not null) then
  begin
    -- search action by status_sign
    select s.status_id
      from statuses s
      where s.status_sign = :i_new_status_sign
        and s.object_sign = :i_object_sign
      into :v_new_status_id;
  end
  else
  begin
    -- search action by flag_sign
    select sr.new_status_id
      from status_rules sr
        inner join flags2statuses f2s on (f2s.status_id = sr.new_status_id)
      where sr.old_status_id = :v_now_status_id
        and f2s.flag_sign = :i_new_flag_sign
      into :v_new_status_id;
  when sqlcode -811 do
    begin
      select RDB$MESSAGE
        from RDB$EXCEPTIONS
        where RDB$EXCEPTION_NAME = 'EX_UNDETECTED_ACTIONCODE'
        into :v_error_message;
      v_error = v_error_message||' (объект="'||:i_object_sign||'" id="'||:i_object_id||'" переход из="'||:v_now_status_sign||'" по флагу="'||:i_new_flag_sign||'")';
      exception ex_undetected_actioncode :v_error;
    end
  end

  if (v_now_status_id = v_new_status_id) then
    o_action_sign = :i_object_sign||'_STORE';
  else
  if (v_now_status_id is null) then
  begin
    -- get default action_sign
    select coalesce(s.action_sign, :i_object_sign||'_STORE')
      from statuses s
      where s.object_sign = :i_object_sign
        and s.is_default = 1
      into :o_action_sign;
  end
  else
  if (v_new_status_id is not null) then
  begin
    -- get action_sign
    select sr.action_sign
      from status_rules sr
      where sr.old_status_id = :v_now_status_id
        and sr.new_status_id = :v_new_status_id
      into :o_action_sign;

    if (:o_action_sign is null and :i_strong_flag = 1) then
    begin
      select RDB$MESSAGE
        from RDB$EXCEPTIONS
        where RDB$EXCEPTION_NAME = 'EX_UNDETECTED_ACTIONCODE'
        into :v_error_message;
      v_error = v_error_message||' (объект="'||:i_object_sign||'" id="'||:i_object_id||'" переход из="'||:v_now_status_sign||'" в="'||:i_new_status_sign||'")';
      exception ex_undetected_actioncode :v_error;
    end
  end

  suspend;
end^


CREATE OR ALTER PROCEDURE ACTION_EXECUTE (
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT,
    I_PARAMS TYPE OF VALUE_BLOB,
    I_ACTION_SIGN TYPE OF SIGN_ACTION,
    I_OBJECT_ID TYPE OF ID_OBJECT)
RETURNS (
    O_ACTION_ID TYPE OF ID_ACTION)
AS
declare variable V_NEW_STATUS_SIGN type of SIGN_ATTR;
declare variable V_PARAM_ID type of ID_PARAM;
declare variable V_ACTION_ID type of ID_ACTION;
declare variable V_LOG_ID type of ID_LOG;
declare variable V_NOW_STATUS_ID type of ID_STATUS;
declare variable V_NOW_STATUS_SIGN type of SIGN_OBJECT;
declare variable V_NEW_FLAG_SIGN type of SIGN_OBJECT;
begin
  select o_param_id
    from param_create(:i_object_sign)
    into :v_param_id;

  execute procedure param_unparse(:v_param_id, :i_params);

--  select o_log_id
--    from log_create(:i_object_sign, :v_param_id, null, null, coalesce(:i_object_id, 0))
--    into :v_log_id;

  i_object_id = nullif(i_object_id, 0);
  if (:i_object_id is not null) then
    execute procedure param_set(:v_param_id, 'ID', :i_object_id);
  else
    select o_value from param_get(:v_param_id, 'ID') into :i_object_id;

  select o_value from param_get(:v_param_id, 'NEW.STATUS_SIGN') into :v_new_status_sign;
  select o_value from param_get(:v_param_id, 'NEW.FLAG_SIGN') into :v_new_flag_sign;

  if (i_action_sign is null) then
    select o_action_sign
      from action_detect(:i_object_sign, :i_object_id, :v_new_status_sign, :v_new_flag_sign, 1)
      into :i_action_sign;

  if (i_action_sign is null) then
    i_action_sign= :i_object_sign||'_STORE';

  select o_action_id
    from action_run(:i_object_sign, :i_action_sign, :v_param_id, :i_object_id)
    into :o_action_id;

  delete from paramheads ph
    where ph.param_id = :v_param_id;

  suspend;
end^


CREATE OR ALTER PROCEDURE ACTION_REEXECUTE (
    I_LOG_ID TYPE OF ID_LOG)
AS
declare variable V_PARAMS type of VALUE_BLOB;
declare variable V_OBJECT_SIGN type of SIGN_OBJECT;
declare variable V_ACTION_SIGN type of SIGN_ACTION;
declare variable V_ACTION_ID type of ID_ACTION;
begin
  select l.action_sign, l.params_in
    from logs l
    where l.log_id = :i_log_id 
    into :v_object_sign, :v_params;

  select o_action_id from action_execute(:v_object_sign, :v_params, null, null)
    into :v_action_id;
end^


CREATE OR ALTER PROCEDURE ACTION_RERUN (
    I_LOG_ID TYPE OF ID_LOG)
AS
declare variable V_PARAMS type of VALUE_BLOB;
declare variable V_OBJECT_SIGN type of SIGN_OBJECT;
declare variable V_ACTION_SIGN type of SIGN_ACTION;
declare variable V_ACTION_ID type of ID_ACTION;
begin
  select l.action_sign, l.params_in, ac.object_sign
    from logs l
      inner join actioncodes ac on (ac.action_sign = l.action_sign)
    where l.log_id = :i_log_id 
    into :v_action_sign, :v_params, :v_object_sign;

  if (v_object_sign is null) then
    select l.action_sign, l.params_in
      from logs l
      where l.log_id = :i_log_id
      into :v_object_sign, :v_params;

  select o_action_id from action_execute(:v_object_sign, :v_params, null, null)
    into :v_action_id;
end^


CREATE OR ALTER PROCEDURE ACTION_RERUN_ACTION (
    I_LOG_ID TYPE OF ID_LOG)
AS
declare variable V_PARAMS type of VALUE_BLOB;
declare variable V_OBJECT_SIGN type of SIGN_OBJECT;
declare variable V_ACTION_SIGN type of SIGN_ACTION;
declare variable V_ACTION_ID type of ID_ACTION;
begin
  select l.action_sign, l.params_in, ac.object_sign
    from logs l
      inner join actioncodes ac on (ac.action_sign = l.action_sign)
    where l.log_id = :i_log_id 
    into :v_action_sign, :v_params, :v_object_sign;

  if (v_object_sign is null) then
    select l.action_sign, l.params_in
      from logs l
      where l.log_id = :i_log_id
      into :v_object_sign, :v_params;

  select o_action_id from action_execute(:v_object_sign, :v_params, :v_action_sign, null)
    into :v_action_id;
end^


CREATE OR ALTER PROCEDURE ACTION_RUN (
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT,
    I_ACTION_SIGN TYPE OF SIGN_ACTION,
    I_PARAM_ID TYPE OF ID_PARAM,
    I_OBJECT_ID TYPE OF ID_OBJECT)
RETURNS (
    O_ACTION_ID TYPE OF ID_ACTION)
AS
declare variable V_PARAM_ID type of ID_PARAM;
declare variable V_PARAM_NAME type of SIGN_OBJECT;
declare variable V_PARAM_KIND type of KIND_PARAM;
declare variable V_PARAM_VALUE type of VALUE_ATTR;
declare variable V_PARAM_VALUE_2 type of VALUE_ATTR;
declare variable V_ACTIONTREEITEM_ID type of ID_ACTIONTREEITEM;
declare variable V_CHILD_OBJECT_SIGN type of SIGN_OBJECT;
declare variable V_CHILD_ACTION_SIGN type of SIGN_ACTION;
declare variable V_SQL type of SQL_STATEMENT;
declare variable V_PROCEDURE_NAME type of SIGN_OBJECT;
declare variable V_PARAM_ACTION type of SIGN_ACTION;
declare variable V_VALID_CRITERIAS type of BOOLEAN = 1;
declare variable V_LOG_ID type of ID_LOG;
declare variable V_CHILD_ACTION_ID type of ID_ACTION;
begin
  i_object_sign = trim(i_object_sign);
  i_action_sign = trim(i_action_sign);
  o_action_id = gen_id(seq_action_id, 1);
  select o_log_id
    from log_create(:i_action_sign, :i_param_id, :o_action_id, :o_action_id, coalesce(:i_object_id, 0))
    into :v_log_id;

  i_object_id = nullif(i_object_id, 0);
  if (i_object_id is null) then
    select o_value from param_get(:i_param_id, 'ID') into :i_object_id;
  else
    execute procedure param_set(:i_param_id, 'ID', :i_object_id);

  insert into actions (action_id, action_sign, action_dtm, object_id)
    values(:o_action_id, :i_action_sign, current_timestamp, :i_object_id);

  update paramheads
    set action_id = :o_action_id,
        object_id = :i_object_id
    where param_id = :i_param_id;

  -- get action object_code
  select coalesce(a.procedure_name, a.action_sign)
    from actioncodes a
    where a.action_sign = :i_action_sign
    into :v_procedure_name;

  -- read action input params
  for select acp.param_name, trim(acp.param_kind), acp.param_value
    from actioncode_params acp
      inner join paramkinds pk on (pk.param_kind = acp.param_kind)
    where acp.action_sign = :i_action_sign
      and pk.is_output = 0
    order by pk.order_no
    into :v_param_name, :v_param_kind, :v_param_value
  do execute procedure param_calc_in(:i_object_sign, :i_param_id, :v_param_name, :v_param_kind, :v_param_value, :i_param_id);

  if (i_object_id is not null) then
    execute procedure object_get(:i_object_sign, :i_object_id, :i_param_id);

  v_valid_criterias = 1;
  -- check criterias
  for select acc.param_name, acc.param_action, acc.param_kind, acc.param_value_1, acc.param_value_2
    from actioncode_criterias acc
    where acc.actioncode_sign = :i_action_sign
    into :v_param_name, :v_param_action, :v_param_kind, :v_param_value, :v_param_value_2
  do
  begin
    select o_valid
      from param_criteria (:i_param_id, :v_param_name, :v_param_action, :v_param_kind, :v_param_value, :v_param_value_2)
      into :v_valid_criterias;
    if (:v_valid_criterias = 0) then
      leave;
  end

  if (v_valid_criterias = 1) then
  begin
    if (v_procedure_name = 'CLIENTNOTIFY_STORE') then
      execute procedure act_clientnotify_store(:i_param_id, :i_object_id);
    else
    if (v_procedure_name = 'MONEYBACK_CREATE') then
      execute procedure act_moneyback_create(:i_param_id, :i_object_id);
    else
    if (v_procedure_name = 'ORDER_RENEW') then
      execute procedure act_order_renew(:i_param_id, :i_object_id);
    else
    if (v_procedure_name = 'BONUS_USE') then
      execute procedure act_bonus_use(:i_param_id, :i_object_id);
    else
    if (v_procedure_name = 'BONUS_STORE') then
      execute procedure act_bonus_store(:i_param_id, :i_object_id);
    else
    if (v_procedure_name = 'ACCOUNT_CREDIT') then
      execute procedure act_account_credit(:i_param_id, :i_object_id);
    else
    if (v_procedure_name = 'MONEYBACK_STORE') then
      execute procedure act_moneyback_store(:i_param_id, :i_object_id);
    else
    if (v_procedure_name = 'ACCOUNT_CREDITORDER') then
      execute procedure act_account_creditorder(:i_param_id, :i_object_id);
    else
    if (v_procedure_name = 'ACCOUNT_DEBITORDER') then
      execute procedure act_account_debitorder(:i_param_id, :i_object_id);
    else
    if (v_procedure_name = 'PAYMENT_STORE') then
      execute procedure act_payment_store(:i_param_id, :i_object_id);
    else
    if (v_procedure_name = 'ACCOUNT_STORE') then
      execute procedure act_account_store(:i_param_id, :i_object_id);
    else
    if (v_procedure_name = 'ORDER_FOREACH_ORDERITEM') then
      execute procedure act_order_foreach_orderitem(:i_param_id, :i_object_id);
    else
    if (v_procedure_name = 'ORDER_FOREACH_ORDERTAX') then
      execute procedure act_order_foreach_ordertax(:i_param_id, :i_object_id);
    else
    if (v_procedure_name = 'ORDER_FOREACH_TAXRATE') then
      execute procedure act_order_foreach_taxrate(:i_param_id, :i_object_id);
    else
    if (v_procedure_name = 'ORDERITEM_STORE') then
      execute procedure act_orderitem_store(:i_param_id, :i_object_id);
    else
    if (v_procedure_name = 'CLIENT_STORE') then
      execute procedure act_client_store(:i_param_id, :i_object_id);
    else
    if (v_procedure_name = 'ORDERTAX_STORE') then
      execute procedure act_ordertax_store(:i_param_id, :i_object_id);
    else
    if (v_procedure_name = 'ORDER_STORE') then
      execute procedure act_order_store(:i_param_id, :i_object_id);
    else
    if (v_procedure_name = 'MESSAGE_STORE') then
      execute procedure act_message_store(:i_param_id, :i_object_id);
    else
    if (v_procedure_name = 'MAGAZINE_STORE') then
      execute procedure act_magazine_store(:i_param_id, :i_object_id);
    else
    if (v_procedure_name = 'ACCOUNT_PAYMENTIN') then
      execute procedure act_account_paymentin(:i_param_id, :i_object_id);
    else
    if (v_procedure_name = 'ACCOUNT_PAYMENTOUT') then
      execute procedure act_account_paymentout(:i_param_id, :i_object_id);
    else
    begin
    -- run main action
      v_sql = 'execute procedure act_'||:v_procedure_name||'(:param_id, :object_id)';
      execute statement (:v_sql) (param_id := :i_param_id, object_id := :i_object_id);
    end
  
    if (:i_object_id is null) then
    begin
      select o_value from param_get(:i_param_id, 'ID') into :i_object_id;
      update actions
        set object_id = :i_object_id
        where action_id = :o_action_id;
    end
  
    -- run child actions
    for select a.actiontreeitem_id, a.child_action, c.object_sign
      from actiontree a
        inner join actioncodes c on (c.action_sign = a.child_action)
      where a.action_sign = :i_action_sign
      order by a.order_no
      into :v_actiontreeitem_id, :v_child_action_sign, :v_child_object_sign do
    begin
      v_valid_criterias = 1;
      -- check criterias
      for select atc.param_name, atc.param_action, atc.param_kind, atc.param_value_1, atc.param_value_2
        from actiontree_criterias atc
        where atc.actiontreeitem_id = :v_actiontreeitem_id
        into :v_param_name, :v_param_action, :v_param_kind, :v_param_value, :v_param_value_2
      do
      begin
        select o_valid
          from param_criteria (:i_param_id, :v_param_name, :v_param_action, :v_param_kind, :v_param_value, :v_param_value_2)
          into :v_valid_criterias;
        if (:v_valid_criterias = 0) then
          leave;
      end
      if (:v_valid_criterias = 1) then
      begin
        select o_param_id from param_create(:v_child_object_sign) into :v_param_id;
        execute procedure param_set(:v_param_id, 'ACTIONTREEITEM_ID', :v_actiontreeitem_id);
        -- calc child action input param
        for select atp.param_name, atp.param_kind, atp.param_value
          from actiontree_params atp
            inner join paramkinds pk on (pk.param_kind = atp.param_kind)
          where atp.actiontreeitem_id = :v_actiontreeitem_id
            and pk.is_output = 0
          order by pk.order_no
          into :v_param_name, :v_param_kind, :v_param_value
        do execute procedure param_calc_in(:v_child_object_sign, :v_param_id, :v_param_name, :v_param_kind, :v_param_value, :i_param_id);
  
        -- execute child action
        if (v_child_action_sign like '%FOREACH%') then
          execute procedure action_run(:v_child_object_sign, :v_child_action_sign, :v_param_id, :i_object_id)
            returning_values :v_child_action_id;
        else
          execute procedure action_run(:v_child_object_sign, :v_child_action_sign, :v_param_id, null)
            returning_values :v_child_action_id;
        -- extract output params
        for select atp.param_name, atp.param_kind, atp.param_value
          from actiontree_params atp
            inner join paramkinds pk on (pk.param_kind = atp.param_kind)
          where atp.actiontreeitem_id = :v_actiontreeitem_id
            and pk.is_output = 1
          order by pk.order_no
          into :v_param_name, :v_param_kind, :v_param_value
        do execute procedure param_calc_out(:v_child_object_sign, :v_param_id, :v_param_name, :v_param_kind, :v_param_value, :i_param_id);
      end
    end
  
    execute procedure param_set(:i_param_id, 'ACTION_ID', :o_action_id);
  
    for select acp.param_name, acp.param_kind, acp.param_value
      from actioncode_params acp
        inner join paramkinds pk on (pk.param_kind = acp.param_kind)
      where acp.action_sign = :i_action_sign
        and pk.is_output = 1
      order by pk.order_no
      into :v_param_name, :v_param_kind, :v_param_value
    do execute procedure param_calc_out(:i_object_sign, :i_param_id, :v_param_name, :v_param_kind, :v_param_value, :i_param_id);
    execute procedure log_update(:v_log_id, :i_param_id, 0, coalesce(:i_object_id, 0));
  end
  else
    execute procedure log_update_skiped(:v_log_id, :i_param_id, 0, coalesce(:i_object_id, 0));

  suspend;
-- Exception Handler
  when any do
    begin
      execute procedure log_update(:v_log_id, :i_param_id, sqlcode, coalesce(:i_object_id, 0));
      exception;
    end
end^


CREATE OR ALTER PROCEDURE ADRESS_READ (
    I_OBJECT_ID TYPE OF ID_OBJECT)
RETURNS (
    O_PARAM_NAME TYPE OF SIGN_OBJECT,
    O_PARAM_VALUE TYPE OF VALUE_ATTR)
AS
begin
  select st.streettype_sign
    from adresses a
      inner join streettypes st on (st.streettype_code=a.streettype_code)
    where a.adress_id = :i_object_id
    into :o_param_value;

  o_param_name = 'STREETTYPE_SIGN';
  suspend;

end^


CREATE OR ALTER PROCEDURE ATTR_PUT (
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT NOT NULL,
    I_OBJECT_ID TYPE OF ID_OBJECT NOT NULL,
    I_ATTR_SIGN TYPE OF SIGN_ATTR NOT NULL,
    I_ATTR_VALUE TYPE OF VALUE_ATTR NOT NULL)
AS
declare variable V_ATTR_ID type of ID_ATTR;
declare variable V_FIELD_NAME type of NAME_PROCEDURE;
declare variable V_TABLE_NAME type of NAME_PROCEDURE;
declare variable V_IDFIELD_NAME type of NAME_PROCEDURE;
declare variable V_ATTR_TABLE_NAME type of NAME_PROCEDURE;
declare variable V_SQL type of SQL_STATEMENT;
declare variable V_DOMAIN type of NAME_PROCEDURE;
begin
  select a.attr_id, a.field_name, o.table_name, o.idfield_name, o.attr_table_name, rf.rdb$field_source
    from attrs a
      inner join objects o on (o.object_sign = a.object_sign)
      left join rdb$relation_fields rf on (rf.rdb$field_name = a.field_name and rf.rdb$relation_name = o.table_name)
    where a.object_sign = :i_object_sign
      and a.attr_sign = upper(:i_attr_sign)
    into :v_attr_id, :v_field_name, :v_table_name, :v_idfield_name, :v_attr_table_name, :v_domain;

  if (row_count = 0) then
    exit;

  if (v_field_name is not null) then
  begin
    v_sql =
      'update '||v_table_name||
      ' set '||v_field_name||' = :attr_value'||
      ' where '||v_idfield_name||' = cast(:object_id as '||v_domain||')';
    execute statement (:v_sql) (object_id := :i_object_id, attr_value := :i_attr_value);
  end
  else
  begin
    v_sql =
      'update or insert into '||v_attr_table_name||'(object_id, attr_id, attr_value)'||
      ' values(:object_id, :attr_id, :attr_value)'||
      ' matching(object_id, attr_id)';
    execute statement (:v_sql) (object_id := :i_object_id, attr_id := :v_attr_id, attr_value := :i_attr_value);
  end
end^


CREATE OR ALTER PROCEDURE BARCODE_GEN (
    I_ORDER_ID TYPE OF ID_ORDER NOT NULL,
    I_PACKLIST_NO TYPE OF VALUE_INTEGER)
RETURNS (
    O_BARCODE TYPE OF SIGN_OBJECT)
AS
declare variable V_PREFIX type of VALUE_SHORT;
declare variable V_ORDER_CODE type of CODE_ORDER;
declare variable V_CN integer;
begin
  /* Procedure Text */
  select substring(pa2.attr_value from 8 for 1)||
         lpad(coalesce(pl.packlist_code, '0'), 2, '0')||
         substring(o.order_code from 2), pa1.attr_value
    from orders o
      left join packlists pl on (pl.packlist_no = coalesce(o.packlist_no, :i_packlist_no))
      inner join v_product_attrs pa1 on (pa1.object_id = o.product_id
                                     and pa1.attr_sign = 'BARCODE_SIGN')
      inner join v_product_attrs pa2 on (pa2.object_id = o.product_id
                                     and pa2.attr_sign = 'PARTNER_NUMBER')
    where o.order_id = :i_order_id
    into :o_barcode, :v_prefix;

  v_cn = 11 - mod(8*cast(substring(o_barcode from 1 for 1) as smallint) +
                  6*cast(substring(o_barcode from 2 for 1) as smallint) +
                  4*cast(substring(o_barcode from 3 for 1) as smallint) +
                  2*cast(substring(o_barcode from 4 for 1) as smallint) +
                  3*cast(substring(o_barcode from 5 for 1) as smallint) +
                  5*cast(substring(o_barcode from 6 for 1) as smallint) +
                  9*cast(substring(o_barcode from 7 for 1) as smallint) +
                  7*cast(substring(o_barcode from 8 for 1) as smallint), 11);
  if (v_cn = 10) then
    v_cn = 0;
  else if (v_cn = 11) then
    v_cn = 5;
  else
    v_cn = substring(v_cn from 1 for 1);

  o_barcode = v_prefix||o_barcode||v_cn||'LT';
  suspend;
end^


CREATE OR ALTER PROCEDURE BARCODE_REGEN (
    I_PRODUCT_ID INTEGER,
    I_PACKLIST_NO INTEGER,
    I_PACKLIST_NUM INTEGER,
    I_PACKET_NO VARCHAR(4000))
AS
 BEGIN EXIT; END^


CREATE OR ALTER PROCEDURE BONUS_MAKE (
    I_FIO TYPE OF NAME_REF,
    I_TAXSERV_ID TYPE OF ID_TAX)
RETURNS (
    O_ACTION_ID TYPE OF ID_BONUS)
AS
declare variable V_CLIENT_ID type of ID_CLIENT;
declare variable V_PARAM_ID type of ID_PARAM;
declare variable V_ACTION_ID type of ID_ACTION;
begin
  select client_id
    from v_clients_fio c
    where c.client_fio = :i_fio
    into :v_client_id;

  if (v_client_id is not null) then
  begin
    select o_param_id from param_create('BONUS') into :v_param_id;
    execute procedure param_set(:v_param_id, 'CLIENT_ID', :v_client_id);
    execute procedure param_set(:v_param_id, 'TAXSERV_ID', :i_taxserv_id);

    select o_action_id from action_run('BONUS', 'BONUS_CREATE', :v_param_id, 0) into :o_action_id;
    suspend;
  end
end^


CREATE OR ALTER PROCEDURE BONUS_USE (
    I_ORDER_CODE TYPE OF CODE_ORDER)
RETURNS (
    O_ACTION_ID TYPE OF ID_ACTION)
AS
declare variable V_BONUS_ID type of ID_BONUS;
declare variable V_ORDER_ID type of ID_ORDER;
declare variable V_PARAM_ID type of ID_PARAM;
begin
  select first 1 o.order_id, b.bonus_id
    from orders o
      inner join bonuses b on (b.client_id = o.client_id and b.ordertax_id is null)
    where o.order_code = :i_order_code
    into :v_order_id, v_bonus_id;

  if (v_bonus_id is not null) then
  begin
    select o_param_id from param_create('BONUS') into :v_param_id;
    execute procedure param_set(:v_param_id, 'ID', :v_bonus_id);
    execute procedure param_set(:v_param_id, 'ORDER_ID', :v_order_id);

    select o_action_id from action_run('BONUS', 'BONUS_USE', :v_param_id, 0) into :o_action_id;
    suspend;
  end
end^


CREATE OR ALTER PROCEDURE CLIENT_MERGE (
    I_FROM_CLIENT_ID TYPE OF ID_CLIENT NOT NULL,
    I_TO_CLIENT_ID TYPE OF ID_CLIENT NOT NULL)
AS
declare variable V_FROM_ACCOUNT_ID type of ID_ACCOUNT;
declare variable V_TO_ACCOUNT_ID type of ID_ACCOUNT;
begin
  update orders o
    set o.client_id = :i_to_client_id
    where o.client_id = :i_from_client_id;

  update adresses a
    set a.client_id = :i_to_client_id
    where a.client_id = :i_from_client_id;

  update bonuses b
    set b.client_id = :i_to_client_id
    where b.client_id = :i_from_client_id;

  select c.account_id
    from clients c
    where c.client_id = :i_from_client_id
    into :v_from_account_id;

  select c.account_id
    from clients c
    where c.client_id = :i_to_client_id
    into :v_to_account_id;

  execute procedure account_merge(:v_from_account_id, :v_to_account_id);

  delete from clients c
    where c.client_id = :i_from_client_id;

end^


CREATE OR ALTER PROCEDURE CLIENT_NORMALIZE_MOBIL
AS
declare variable V_CLIENT_ID type of ID_CLIENT;
declare variable V_RECODE_MASK type of MASK_ARTICLECODE;
declare variable V_VALUE type of VALUE_ATTR;
begin
  for select c.client_id, recode(c.mobile_phone, rm.replace_mask)
  from clients c
    inner join recode_masks rm on (rm.object_sign = 'CLIENT'
                               and rm.attr_sign = 'MOBILE_PHONE'
                               and c.mobile_phone similar to rm.search_mask escape '\')
  where c.mobile_phone not like '0_________'
  into :v_client_id, :v_value do
  begin
    update clients c
      set c.mobile_phone = :v_value
      where c.client_id = :v_client_id;
  end
end^


CREATE OR ALTER PROCEDURE CLIENTS_KILL
RETURNS (
    O_CLIENT_ID TYPE OF ID_CLIENT)
AS
begin
  for select first 1000 cl.client_id
        from clients cl
          left join orders o on (o.client_id = cl.client_id)
        where o.order_id is null
        into :o_client_id do
  begin
    begin
      delete from clients where client_id = :o_client_id;
    when any do
      begin
        suspend;
      end
    end
  end
end^


CREATE OR ALTER PROCEDURE COUNTER_NEXTVAL (
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT NOT NULL,
    I_COUNTER_SIGN TYPE OF SIGN_ATTR NOT NULL,
    I_OBJECT_ID TYPE OF ID_OBJECT NOT NULL,
    I_NONAUTONOMOUS TYPE OF BOOLEAN = null)
RETURNS (
    O_NEXTVAL TYPE OF NAME_SHORT)
AS
declare variable V_PEFIX type of NAME_SHORT;
declare variable V_MAX_VALUE type of NAME_SHORT;
begin
  if (i_nonautonomous is null) then
    in autonomous transaction do
    update counters c
      set c.curr_value = c.curr_value + 1
      where c.object_sign = :i_object_sign
        and c.attr_sign = :i_counter_sign
        and c.object_id = :i_object_id
      returning c.curr_value, c.prefix_text, c.max_value
      into :o_nextval, :v_pefix, :v_max_value;
  else
    update counters c
      set c.curr_value = c.curr_value + 1
      where c.object_sign = :i_object_sign
        and c.attr_sign = :i_counter_sign
        and c.object_id = :i_object_id
      returning c.curr_value, c.prefix_text, c.max_value
      into :o_nextval, :v_pefix, :v_max_value;
  if (v_pefix is not null) then
    o_nextval=:v_pefix||lpad(o_nextval, CHAR_LENGTH(:v_max_value), '0');
  suspend;
end^


CREATE OR ALTER PROCEDURE DB_CLEANUP
AS
declare variable V_CNT integer;
begin
  delete from paramheads ph
  where ph.param_id < gen_id(seq_param_id, 0) - 10000;
  select count(*) from paramheads into :v_cnt;
  select count(*) from params into :v_cnt;

  delete from actions a
  where a.action_dtm < current_date - 100
    and a.action_id < gen_id(seq_action_id, 0) - 10000;
  select count(*) from actions into :v_cnt;

  delete from messages m
  where m.message_dtm < current_date - 100;
  delete from messages m
  where m.template_id = 9
    and m.message_dtm < current_date - 7;
  select count(*) from messages into :v_cnt;

  delete from notifies n
  where n.notify_dtm < current_date - 100
    and n.notify_id < gen_id(seq_notify_id, 0) - 10000;
  select count(*) from notifies into :v_cnt;


  delete from Logs l
  where l.log_id < gen_id(seq_log_id, 0) - 10000;
  select count(*) from logs into :v_cnt;
end^


CREATE OR ALTER PROCEDURE LOG_CREATE (
    I_ACTION_SIGN TYPE OF SIGN_ACTION NOT NULL,
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL,
    I_OWNER_ACTION TYPE OF ID_ACTION NOT NULL,
    I_ACTION_ID TYPE OF ID_ACTION NOT NULL,
    I_OBJECT_ID TYPE OF ID_OBJECT NOT NULL)
RETURNS (
    O_LOG_ID TYPE OF ID_LOG)
AS
declare variable V_PARAMS type of VALUE_BLOB;
begin
  o_log_id = gen_id(seq_log_id, 1);
  select cast(list(param_name||'="'||escapestring(param_value)||'"', ascii_char(13)||ascii_char(10)) as value_blob)
    from params
    where param_id = :i_param_id
    group by param_id
    into :v_params;
  in autonomous transaction do
    insert into logs(log_id, action_sign, owner_action, action_id, params_in, object_id)
      values(:o_log_id, :i_action_sign, :i_owner_action, :i_action_id, :v_params, :i_object_id);
  suspend;
end^


CREATE OR ALTER PROCEDURE LOG_UPDATE (
    I_LOG_ID TYPE OF ID_LOG NOT NULL,
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL,
    I_RESULT_CODE TYPE OF VALUE_INTEGER NOT NULL,
    I_OBJECT_ID TYPE OF ID_OBJECT NOT NULL)
AS
declare variable V_PARAMS type of VALUE_BLOB;
begin
  select cast(list(param_name||'="'||escapestring(param_value)||'"', ascii_char(13)||ascii_char(10)) as value_blob)
    from params
    where param_id = :i_param_id
    group by param_id
    into :v_params;

  in autonomous transaction do
    update logs l
      set l.params_out = :v_params,
          l.result_code = :i_result_code,
          l.object_id = :i_object_id
      where l.log_id = :i_log_id;
end^


CREATE OR ALTER PROCEDURE LOG_UPDATE_SKIPED (
    I_LOG_ID TYPE OF ID_LOG,
    I_PARAM_ID TYPE OF ID_PARAM,
    I_RESULT_CODE TYPE OF VALUE_INTEGER,
    I_OBJECT_ID TYPE OF ID_OBJECT)
AS
declare variable V_PARAMS type of VALUE_BLOB;
begin
  v_params = 'execution skipped';

  in autonomous transaction do
    update logs l
      set l.params_out = :v_params,
          l.result_code = :i_result_code,
          l.object_id = :i_object_id
      where l.log_id = :i_log_id;
end^


CREATE OR ALTER PROCEDURE MAGAZINE_DETECT (
    I_CATALOG_NAME TYPE OF NAME_REF NOT NULL)
RETURNS (
    O_MAGAZINE_ID TYPE OF ID_MAGAZINE,
    O_CATALOG_ID TYPE OF ID_CATALOG)
AS
declare variable V_CATALOG_ID type of ID_CATALOG;
begin
  select first 1 m.magazine_id, m.catalog_id
    from catalogs c
      inner join magazines m on (m.catalog_id = c.catalog_id)
    where c.catalog_name = :i_catalog_name
      and m.valid_date > current_date
    order by m.valid_date
    into :o_magazine_id, :o_catalog_id;
  suspend;
end^


CREATE OR ALTER PROCEDURE MESSAGE_BUSY (
    I_TEMPLATE_ID TYPE OF ID_TEMPLATE)
RETURNS (
    O_MESSAGE_ID INTEGER)
AS
begin
  in autonomous transaction do
    update messages m
      set m.busy_id = current_connection
      where m.message_id = (
        select first 1 ms.message_id
          from messages ms
            inner join v_statuses s on (s.status_id = ms.status_id)
            where s.flag_sign = 'NEW'
              and ms.template_id = :i_template_id
              and ms.busy_id is null)
      returning m.message_id
      into :o_message_id;
  suspend;
end^


CREATE OR ALTER PROCEDURE MESSAGE_BUSY_2 (
    I_MESSAGE_ID TYPE OF ID_MESSAGE)
AS
declare variable V_PARAM_ID type of ID_PARAM;
declare variable V_ACTION_ID type of ID_ACTION;
begin
  update messages m
    set m.busy_id = current_connection
    where m.message_id = :i_message_id;
end^


CREATE OR ALTER PROCEDURE MESSAGE_CREATE (
    I_FILE_NAME TYPE OF NAME_FILE,
    I_FILE_SIZE TYPE OF SIZE_FILE,
    I_FILE_DTM TYPE OF DTM_FILE)
RETURNS (
    O_MESSAGE_ID TYPE OF ID_MESSAGE)
AS
declare variable V_ACTION_ID type of ID_ACTION;
declare variable V_PARAM_ID type of ID_PARAM;
declare variable V_TEMPLATE_ID type of ID_TEMPLATE;
declare variable V_FILE_NAME type of NAME_FILE;
declare variable V_OBJECT_SIGN type of SIGN_OBJECT = 'MESSAGE';
begin
  if (not exists(select m.message_id
                   from messages m
                   where m.file_name = :i_file_name
                     and extract(year from m.message_dtm) = extract(year from current_date))) then
  begin
    select o_param_id from param_create(:v_object_sign) into :v_param_id;
    execute procedure param_set(:v_param_id, 'FILE_NAME', :i_file_name);
    execute procedure param_set(:v_param_id, 'FILE_SIZE', :i_file_size);
    execute procedure param_set(:v_param_id, 'FILE_DTM', :i_file_dtm);

    v_file_name = EscapeStringEx(:i_file_name, '-');

    select t.template_id
      from templates t
      where :v_file_name similar to t.filename_mask
      into :v_template_id;

    if (v_template_id is not null) then
    begin
      execute procedure param_set(:v_param_id, 'TEMPLATE_ID', :v_template_id);

      select o_action_id from action_run(:v_object_sign, 'MESSAGE_CREATE', :v_param_id, null)
        into :v_action_id;
      select a.object_id from actions a where a.action_id = :v_action_id
        into :o_message_id;
    end
  end
  suspend;
end^


CREATE OR ALTER PROCEDURE MESSAGE_READ (
    I_OBJECT_ID TYPE OF ID_MESSAGE)
RETURNS (
    O_PARAM_NAME TYPE OF SIGN_OBJECT,
    O_PARAM_VALUE TYPE OF VALUE_ATTR)
AS
begin
  /* Procedure Text */
  for select d.param_sign, recode(m.file_name, d.value_mask)
        from messages m
          inner join detector d on (d.object_sign = 'MESSAGE' and d.object_id = m.template_id)
        where m.message_id = :i_object_id
        into :o_param_name, :o_param_value do
  begin
    suspend;
  end
end^


CREATE OR ALTER PROCEDURE MESSAGE_RELEASE (
    I_TEMPLATE_ID TYPE OF ID_MESSAGE NOT NULL)
AS
begin
  update messages m
    set m.busy_id = null
    where m.busy_id = current_connection
      and m.template_id = :i_template_id;
end^


CREATE OR ALTER PROCEDURE MONEY_EUR2BYR (
    I_AMOUNT_EUR TYPE OF MONEY_EUR,
    I_BYR2EUR TYPE OF MONEY_BYR NOT NULL)
RETURNS (
    O_MONEY_BYR TYPE OF MONEY_BYR)
AS
declare variable V_PRECISION_BYR type of MONEY_BYR = 50;
begin
  o_money_byr = round_precision(coalesce(:i_amount_eur, 0) * :i_byr2eur, :v_precision_byr);
  suspend;
end^


CREATE OR ALTER PROCEDURE MONEY_TO_ORDER (
    I_ORDER_CODE TYPE OF CODE_ORDER)
AS
declare variable V_PARAM_ID type of ID_PARAM;
declare variable V_ACCOUNT_ID type of ID_ACCOUNT;
declare variable V_ORDER_ID type of ID_ORDER;
declare variable V_ACTION_ID type of ID_ACTION;
declare variable V_COST_EUR type of MONEY_EUR;
declare variable V_AMOUNT_EUR type of MONEY_EUR;
declare variable V_REST_EUR type of MONEY_EUR;
begin
  select o.account_id, o.order_id, os.cost_eur
    from orders o
      inner join v_order_summary os on (os.order_id = o.order_id)
    where o.order_code = :i_order_code
    into :v_account_id, :v_order_id, :v_cost_eur;

  select sum(ar.rest_eur)
    from accrests ar
    where ar.account_id = :v_account_id
    into :v_rest_eur;

  if (v_rest_eur > v_cost_eur) then
    v_amount_eur= replace(v_cost_eur, ',', '.');
  else
    v_amount_eur= replace(v_rest_eur, ',', '.');

  select o_param_id from param_create('ACCOUNT', :v_account_id) into :v_param_id;
  execute procedure param_set(:v_param_id, 'ORDER_ID', :v_order_id);

  execute procedure param_set(:v_param_id, 'AMOUNT_EUR', replace(:v_amount_eur, ',','.'));

  select o_action_id
    from action_run('ACCOUNT', 'ACCOUNT_CREDITORDER', :v_param_id, :v_account_id)
    into :v_action_id;

  suspend;
end^


CREATE OR ALTER PROCEDURE MONEYBACK_READ (
    I_OBJECT_ID TYPE OF ID_OBJECT)
RETURNS (
    O_PARAM_NAME TYPE OF SIGN_OBJECT,
    O_PARAM_VALUE TYPE OF VALUE_ATTR)
AS
declare variable V_STATUS_SIGN type of SIGN_OBJECT;
declare variable V_STATUS_NAME type of NAME_OBJECT;
begin
  select s.status_sign, s.status_name
    from moneybacks mb
      inner join statuses s on (s.status_id = mb.status_id)
    where mb.moneyback_id = :i_object_id
    into :v_status_sign, :v_status_name;

  o_param_name = 'STATUS_SIGN';
  o_param_value = v_status_sign;
  suspend;
  o_param_name = 'STATUS_NAME';
  o_param_value = v_status_name;
  suspend;

  o_param_name = 'KIND_NAME';
  select r.recoded_value
    from moneybacks mb
      inner join recodes r on (r.object_sign = 'MONEYBACK'
                           and r.attr_sign = 'KIND'
                           and r.original_value = mb.kind)
    where mb.moneyback_id = :i_object_id
    into :o_param_value;
  suspend;
end^


CREATE OR ALTER PROCEDURE MONEYBACK_X_PURPOSE (
    I_DEST_PARAM_ID TYPE OF ID_PARAM,
    I_PARAM_NAME TYPE OF SIGN_ATTR,
    I_SRC_PARAM_ID TYPE OF ID_PARAM)
AS
declare variable V_KIND type of VALUE_ATTR;
declare variable V_PURPOSE type of VALUE_ATTR;
declare variable V_ORDER_ID type of ID_ORDER;
declare variable V_CLIENT_ID type of ID_CLIENT;
declare variable V_ACCOUNT_ID type of ID_ACCOUNT;
declare variable V_ORDER_CODE type of CODE_ORDER;
declare variable V_CLIENT_PARAM_ID type of ID_PARAM;
begin
  select o_value from param_get(:i_src_param_id, 'KIND') into :v_kind;
  select o_value from param_get(:i_src_param_id, 'ORDER_ID') into :v_order_id;
  select o_value from param_get(:i_src_param_id, 'ACCOUNT_ID') into :v_account_id;
  if (v_order_id is not null) then
  begin
    select o.order_code, o.client_id
      from orders o
      where o.order_id = :v_order_id
      into :v_order_code, :v_client_id;
    execute procedure param_set(:i_dest_param_id, 'ORDER_CODE', :v_order_code);
  end

  if (v_client_id is null) then
    select c.client_id
      from clients c
      where c.account_id = :v_account_id
      into :v_client_id;

  if (v_kind = 'BELPOST') then
  begin
    v_purpose = '[ORDER_CODE]';
  end
  else if (v_kind = 'BANK') then
  begin
    if (v_order_code is null) then
      v_purpose = 'Возврат денежных средств со счета для зачисления на картсчет [CLIENT_BANK_CLIENT_ACCOUNT] '||
        '[CLIENT_LAST_NAME] [CLIENT_FIRST_NAME] [CLIENT_MID_NAME] паспорт [CLIENT_PASSPORT_NUM] выдан '||
        '[CLIENT_PASSPORT_ISSUER] [CLIENT_PASSPORT_ISSUED] [CLIENT_PERSONAL_NUM]';
    else
      v_purpose = 'Возврат денежных средств за полученный и возвращенный товар по '||
        'каталогу OTTO заявка [ORDER_CODE] для зачисления на картсчет [CLIENT_BANK_CLIENT_ACCOUNT] '||
        '[CLIENT_LAST_NAME] [CLIENT_FIRST_NAME] [CLIENT_MID_NAME] паспорт [CLIENT_PASSPORT_NUM] выдан '||
        '[CLIENT_PASSPORT_ISSUER] [CLIENT_PASSPORT_ISSUED] [CLIENT_PERSONAL_NUM]';

    select o_param_id from param_create('CLIENT', :v_client_id) into :v_client_param_id;
    execute procedure object_get('CLIENT', :v_client_id, :v_client_param_id);
    execute procedure param_merge(:i_dest_param_id, :v_client_param_id, 'CLIENT_');
    delete from paramheads ph where ph.param_id = :v_client_param_id;
  end

  select o_pattern from param_fillpattern(:i_dest_param_id, :v_purpose) into :v_purpose;

  execute procedure param_set(:i_dest_param_id, :i_param_name, :v_purpose);
end^


CREATE OR ALTER PROCEDURE NOTIFY_CREATE (
    I_MESSAGE_ID TYPE OF ID_MESSAGE,
    I_NOTIFY_TEXT TYPE OF VALUE_ATTR,
    I_PARAMS TYPE OF VALUE_BLOB,
    I_STATE TYPE OF VALUE_CHAR)
RETURNS (
    O_NOTIFY_ID TYPE OF ID_NOTIFY)
AS
declare variable V_PARAM_ID type of ID_PARAM;
begin
  if (nullif(i_params, '') is not null) then
  begin
    select o_param_id from param_create('NOTIFY', :i_message_id) into :v_param_id;
    execute procedure param_unparse(:v_param_id, :i_params);
    select o_pattern from param_fillpattern(:v_param_id, :i_notify_text) into :i_notify_text;
    delete from paramheads ph where ph.param_id = :v_param_id;
  end

  insert into notifies(message_id, notify_text, notify_class)
    values(:i_message_id, :i_notify_text, upper(:i_state))
    returning notify_id
    into :o_notify_id;

  suspend;
end^


CREATE OR ALTER PROCEDURE OBJECT_GET (
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT NOT NULL,
    I_OBJECT_ID TYPE OF ID_OBJECT NOT NULL,
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL)
AS
declare variable V_PROCEDURE_NAME type of NAME_PROCEDURE;
declare variable V_PIVOT type of SQL_STATEMENT;
declare variable V_SQL type of SQL_STATEMENT;
begin
  execute procedure param_set(:i_param_id, 'ID', :i_object_id);
  select o_sql from pivot_record(:i_object_sign) into v_pivot;
  v_sql =
    'insert into params(param_id, param_name, param_value) '||
    'select cast(:i_param_id as id_param), pv.attr_sign, pv.attr_value '||
    ' from ('||:v_pivot||') pv '||
    ' left join params p on (p.param_name = pv.attr_sign and p.param_id = :i_param_id)'||
    ' where p.param_id is null';
  execute statement (:v_sql) (i_param_id := :i_param_id, id := :i_object_id);

  select o.procedure_read
    from objects o
    where o.object_sign = :i_object_sign
    into :v_procedure_name;
  if (v_procedure_name is not null) then
  begin
    v_sql =
      'insert into params(param_id, param_name, param_value) '||
      'select cast(:i_param_id as id_param), o_param_name, o_param_value '||
      ' from '||:v_procedure_name||' (:id) pv '||
      ' left join params p on (p.param_name = pv.o_param_name and p.param_id = :i_param_id)'||
      ' where p.param_id is null';
    execute statement (:v_sql) (id := :i_object_id, i_param_id := :i_param_id);
  end

end^


CREATE OR ALTER PROCEDURE OBJECT_PUT (
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL)
AS
declare variable V_TABLE_NAME type of NAME_PROCEDURE;
declare variable V_IDFIELD_NAME type of NAME_PROCEDURE;
declare variable V_ATTRTABLE_NAME type of NAME_PROCEDURE;
declare variable V_ATTR_VALUE type of VALUE_ATTR;
declare variable V_FIELD_NAME type of NAME_PROCEDURE;
declare variable V_SQL type of SQL_STATEMENT;
declare variable V_OBJECT_ID type of ID_OBJECT;
begin
  select ph.object_id, o.table_name, o.idfield_name, o.attr_table_name
    from paramheads ph
      inner join objects o on (o.object_sign = ph.object_sign)
    where ph.param_id = :i_param_id
    into :v_object_id, :v_table_name, :v_idfield_name, :v_attrtable_name;

  for select p.param_value, a.field_name
    from params p
      inner join paramheads ph on (ph.param_id = p.param_id)
      inner join attrs a on (a.attr_sign = p.param_name and a.object_sign = ph.object_sign and coalesce(a.direction,'W')='W')
    where p.param_id = :i_param_id
      and a.field_name is not null
    into :v_attr_value, :v_field_name
  do begin
    v_sql =
      'update '||v_table_name||
      ' set '||v_field_name||' = :v_attr_value'||
      ' where '||v_idfield_name||' = :object_id';
    execute statement (:v_sql) (object_id := :v_object_id, v_attr_value := :v_attr_value);
  end


--  if (exists(select *
--    from attrs a
--      inner join paramheads ph on (ph.object_sign = a.object_sign)
--      where ph.param_id = :i_param_id
--        and a.field_name is null)) then
  if (v_attrtable_name is not null) then
  begin
    v_sql =
      'merge into '||v_attrtable_name||' oa
       using (select object_id, attr_id, attr_value
        from v_attrinparam
        where param_id = :i_param_id) ap
      on (oa.object_id = ap.object_id and oa.attr_id = ap.attr_id)
      when matched then
        update set oa.attr_value = ap.attr_value
      when not matched then
        insert (object_id, attr_id, attr_value)
          values (ap.object_id, ap.attr_id, ap.attr_value)';
    execute statement (v_sql) (i_param_id := :i_param_id);
  end
end^


CREATE OR ALTER PROCEDURE OBJECT_READ (
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT NOT NULL,
    I_OBJECT_ID TYPE OF ID_OBJECT NOT NULL)
RETURNS (
    O_PARAM_NAME TYPE OF SIGN_OBJECT,
    O_PARAM_VALUE TYPE OF VALUE_ATTR)
AS
declare variable V_PIVOT type of SQL_STATEMENT;
declare variable V_SQL type of SQL_STATEMENT;
declare variable V_PROCEDURE_NAME type of NAME_PROCEDURE;
begin
  if (i_object_id is null) then
    exit;
  select o_sql from pivot_record(:i_object_sign) into v_pivot;
  v_sql =
    'select pv.attr_sign, pv.attr_value '||
    ' from ('||:v_pivot||') pv ';
  for execute statement (:v_sql) (id := :i_object_id)
    into :o_param_name, :o_param_value do
    suspend;

  select o.procedure_read
    from objects o
    where o.object_sign = :i_object_sign
    into :v_procedure_name;
  if (v_procedure_name is not null) then
  begin
    v_sql = 'select o_param_name, o_param_value '||
    ' from '||:v_procedure_name||' (:id)';
    for execute statement (:v_sql) (id := :i_object_id)
      into :o_param_name, :o_param_value do
      suspend;
  end

end^


CREATE OR ALTER PROCEDURE OBJECT_UPDATEABLE (
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL,
    I_NOW_STATUS_ID TYPE OF ID_STATUS NOT NULL,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT NOT NULL)
RETURNS (
    O_UPDATEABLE TYPE OF VALUE_BOOLEAN,
    O_NEW_STATUS_ID TYPE OF ID_STATUS)
AS
declare variable V_NEW_STATUS_SIGN type of SIGN_OBJECT = 0;
declare variable V_FLAG_SIGN type of SIGN_FLAG;
declare variable V_CHANGED type of BOOLEAN;
begin

  select o_value from param_get(:i_param_id, 'NEW.STATUS_SIGN') into :v_new_status_sign;
  select status_id
    from statuses s
    where s.object_sign = :i_object_sign
      and s.status_sign = :v_new_status_sign
    into :o_new_status_id;

  if (o_new_status_id is null) then
    select o_value from param_get(:i_param_id, 'NEW.STATUS_ID') into :o_new_status_id;

  if (o_new_status_id is null) then
    o_new_status_id = i_now_status_id;

  if (o_new_status_id = i_now_status_id) then
    select case count(*)
            when 0 then 1
            else 0
           end
      from flags2statuses f2s
      where f2s.status_id = :i_now_status_id
        and f2s.flag_sign = 'READONLY'
      into :o_updateable;
  else
    select case count(*)
             when 0 then 0
             else 1
           end
      from status_rules r
      where r.old_status_id = :i_now_status_id
        and r.new_status_id = :o_new_status_id
      into :o_updateable;

  if (o_updateable = 0) then
    select coalesce(o_value, 0) from param_get(:i_param_id, 'CHANGED') into :o_updateable;

  suspend;
end^


CREATE OR ALTER PROCEDURE ORDER_ANUL (
    I_ORDER_ID TYPE OF ID_ORDER)
RETURNS (
    O_NEW_STATUS_SIGN TYPE OF SIGN_OBJECT)
AS
declare variable V_ORDERITEMS_CNT type of VALUE_INTEGER;
declare variable V_ORDER_STATUS_ID type of ID_STATUS;
declare variable V_ORDER_STATUS_SIGN type of SIGN_OBJECT;
declare variable V_PARAM_ID type of ID_PARAM;
declare variable V_ACTION_ID type of ID_ACTION;
begin
  select count(*) from orderitems oi
    inner join flags2statuses f2s on (f2s.status_id = oi.status_id and f2s.flag_sign = 'CREDIT')
    where oi.order_id = :i_order_id
    into :v_orderitems_cnt;

  select s.status_id, s.status_sign
    from orders o
      inner join statuses s on (s.status_id = o.status_id)
    where o.order_id = :i_order_id
    into :v_order_status_id, :v_order_status_sign;

  if (:v_orderitems_cnt = 0 and :v_order_status_sign not in ('CANCELLED', 'ANULLED', 'REJECTED')) then
  begin
    select o_param_id from param_create('ORDER', :i_order_id) into :v_param_id;
    select o_action_id from action_run('ORDER', 'ORDER_CANCELLED', :v_param_id, :i_order_id) into :v_action_id;
  end

  select s.status_sign
    from orders o
      inner join statuses s on (s.status_id = o.status_id)
    where o.order_id = :i_order_id
    into :o_new_status_sign;
  suspend;
end^


CREATE OR ALTER PROCEDURE ORDER_READ (
    I_OBJECT_ID TYPE OF ID_OBJECT)
RETURNS (
    O_PARAM_NAME TYPE OF SIGN_OBJECT,
    O_PARAM_VALUE TYPE OF VALUE_ATTR)
AS
declare variable V_PRODUCT_NAME type of VALUE_ATTR;
declare variable V_CLIENT_FIO type of VALUE_ATTR;
declare variable V_ADRESS_TEXT type of VALUE_ATTR;
declare variable V_STATUS_SIGN type of SIGN_ATTR;
declare variable V_ACCOUNT_ID type of ID_ACCOUNT;
declare variable V_STATUS_FLAG_LIST type of LIST_SIGNS;
declare variable V_STATUS_NAME type of NAME_OBJECT;
begin
  select p.product_name, vc.client_fio,
         ca.postindex||'. '||ca.place_text||', '||ca.adress_text adress_text,
         s.status_sign, s.flag_sign_list, s.status_name
    from orders o
      left join products p on (p.product_id = o.product_id)
      left join v_clients_fio vc on (vc.client_id = o.client_id)
      left join v_clientadress ca on (ca.adress_id = o.adress_id)
      left join statuses s on (s.status_id = o.status_id)
    where o.order_id = :i_object_id
    into :v_product_name, :v_client_fio, :v_adress_text,
         :v_status_sign, :v_status_flag_list, :v_status_name;

  o_param_name = 'STATUS_SIGN';
  o_param_value = v_status_sign;
  suspend;
  o_param_name = 'STATUS_FLAG_LIST';
  o_param_value = v_status_flag_list;
  suspend;
  o_param_name = 'STATUS_NAME';
  o_param_value = v_status_name;
  suspend;


  if (:v_product_name is not null) then
  begin
    o_param_name = 'PRODUCT_NAME';
    o_param_value = :v_product_name;
    suspend;
  end

  if (v_client_fio is not null) then
  begin
    o_param_name = 'CLIENT_FIO';
    o_param_value = :v_client_fio;
    suspend;
  end

  if (:v_adress_text is not null) then
  begin
    o_param_name = 'ADRESS_TEXT';
    o_param_value = :v_adress_text;
    suspend;
  end

  select a.account_id
    from orders o
      inner join clients cl on (cl.client_id = o.client_id)
      inner join accounts a on (a.account_id = cl.account_id)
    where o.order_id = :i_object_id
    into :v_account_id;
  if (:v_account_id is not null) then
  begin
    o_param_name = 'ACCOUNT_ID';
    o_param_value = :v_account_id;
    suspend;
  end

end^


CREATE OR ALTER PROCEDURE ORDER_UNDO_DELIVERING (
    I_ORDER_ID TYPE OF ID_ORDER)
AS
begin
  update orders o
    set o.status_id = (select s.status_id from statuses s where s.object_sign = 'ORDER' and s.status_sign = 'PACKED')
    where o.order_id = :i_order_id;
  update orderitems oi
    set oi.status_id = (select s.status_id from statuses s where s.object_sign = 'ORDERITEM' and s.status_sign = 'PACKED')
    where oi.order_id = :i_order_id
      and oi.status_id = (select s.status_id from statuses s where s.object_sign = 'ORDERITEM' and s.status_sign = 'DELIVERING');
end^


CREATE OR ALTER PROCEDURE ORDER_UPDATECOST (
    I_ORDER_ID TYPE OF ID_ORDER NOT NULL)
AS
declare variable V_ORDERITEMS_COST type of MONEY_EUR;
declare variable V_ORDERTAXS_COST type of MONEY_EUR;
declare variable V_ORDERMONEYS_COST type of MONEY_EUR;
begin
  select coalesce(sum(oi.cost_eur), 0)
    from orderitems oi
    where oi.order_id = :i_order_id
    into :v_orderitems_cost;

  select coalesce(sum(ot.cost_eur), 0)
    from ordertaxs ot
    where ot.order_id = :i_order_id
    into :v_ordertaxs_cost;

  select coalesce(sum(om.amount_eur), 0)
    from ordermoneys om
    where om.order_id = :i_order_id
    into :v_ordermoneys_cost;

  update orders o
    set o.cost_eur = :v_orderitems_cost+:v_ordertaxs_cost-:v_ordermoneys_cost
    where o.order_id = :i_order_id;
end^


CREATE OR ALTER PROCEDURE ORDER_X_ACTIVEITEMSCOUNT (
    I_DEST_PARAM_ID TYPE OF ID_PARAM NOT NULL,
    I_PARAM_NAME TYPE OF SIGN_ATTR NOT NULL,
    I_SRC_PARAM_ID TYPE OF ID_PARAM)
AS
declare variable V_OBJECT_ID type of ID_OBJECT;
declare variable V_AMOUNT type of VALUE_INTEGER;
begin
  select o_value from param_get(:i_src_param_id, 'ID') into :v_object_id;

  select sum(oi.amount)
    from orderitems oi
    where oi.order_id = :v_object_id
    into :v_amount;

  execute procedure param_set(:i_dest_param_id, :i_param_name, :v_amount);
end^


CREATE OR ALTER PROCEDURE ORDER_X_UNINVOICED (
    I_DEST_PARAM_ID TYPE OF ID_PARAM,
    I_PARAM_NAME TYPE OF SIGN_ATTR,
    I_SRC_PARAM_ID TYPE OF ID_PARAM)
AS
declare variable V_OBJECT_ID type of ID_OBJECT;
declare variable V_ORDERITEMS_COST_EUR type of MONEY_EUR;
declare variable V_ORDERTAXS_COST_EUR type of MONEY_EUR;
declare variable V_ORDERMONEYS_COST_EUR type of MONEY_EUR;
begin
  select o_value from param_get(:i_src_param_id, 'ID') into :v_object_id;

  select sum(oi.cost_eur)
    from orderitems oi
    where oi.order_id = :v_object_id
    into :v_orderitems_cost_eur;

  select sum(ot.cost_eur)
    from ordertaxs ot
    where ot.order_id = :v_object_id
    into :v_ordertaxs_cost_eur;

  select sum(om.amount_eur)
    from ordermoneys om
    where om.order_id = :v_object_id
    into :v_ordermoneys_cost_eur;

  execute procedure param_set(:i_dest_param_id, :i_param_name,
    :v_orderitems_cost_eur+:v_ordertaxs_cost_eur-:v_ordermoneys_cost_eur);
end^


CREATE OR ALTER PROCEDURE ORDERHISTORY_UPDATE (
    I_ORDER_ID TYPE OF ID_ORDER,
    I_STATUS_ID TYPE OF ID_STATUS,
    I_STATE_ID TYPE OF ID_STATUS)
AS
declare variable V_STATUS_ID type of ID_STATUS;
declare variable V_STATE_ID type of ID_STATUS;
begin
  select first 1 coalesce(oh.status_id, 0), coalesce(oh.state_id, 0)
    from orderhistory oh
    where oh.order_id = :i_order_id
    order by oh.action_dtm desc
    into :v_status_id, :v_state_id;
  if ((:i_status_id <> coalesce(:v_status_id, 0)) or (coalesce(:i_state_id, 0) <> coalesce(:v_state_id, 0))) then
  begin
    insert into orderhistory(order_id, status_id, state_id)
      values (:i_order_id, :i_status_id, :i_state_id);
  end
end^


CREATE OR ALTER PROCEDURE ORDERITEM_READ (
    I_OBJECT_ID TYPE OF ID_OBJECT)
RETURNS (
    O_PARAM_NAME TYPE OF SIGN_OBJECT,
    O_PARAM_VALUE TYPE OF VALUE_ATTR)
AS
declare variable V_ARTICLE_ID type of ID_ARTICLE;
declare variable V_WEIGHT type of VALUE_INTEGER;
declare variable V_STATUS_SIGN type of SIGN_OBJECT;
declare variable V_STATUS_FLAG_LIST type of LIST_SIGNS;
declare variable V_STATE_SIGN type of SIGN_OBJECT;
declare variable V_STATE_FLAG_LIST type of LIST_SIGNS;
declare variable V_STATUS_NAME type of NAME_OBJECT;
declare variable V_STATE_NAME type of NAME_OBJECT;
begin
  select s.status_sign, s.flag_sign_list, s.status_name,
         ss.status_sign, ss.flag_sign_list, ss.status_name
    from orderitems oi
      inner join statuses s on (s.status_id = oi.status_id)
      left join statuses ss on (ss.status_id = oi.state_id)
    where oi.orderitem_id = :i_object_id
    into :v_status_sign, :v_status_flag_list, :v_status_name,
         :v_state_sign, :v_state_flag_list, :v_state_name;

  o_param_name = 'STATUS_SIGN';
  o_param_value = v_status_sign;
  suspend;

  o_param_name = 'STATUS_FLAG_LIST';
  o_param_value = v_status_flag_list;
  suspend;

  o_param_name = 'STATUS_NAME';
  o_param_value = v_status_name;
  suspend;


  if (v_state_sign is not null) then
  begin
    o_param_name = 'STATE_SIGN';
    o_param_value = v_state_sign;
    suspend;

    o_param_name = 'STATE_FLAG_LIST';
    o_param_value = v_state_flag_list;
    suspend;

    o_param_name = 'STATE_NAME';
    o_param_value = v_state_name;
    suspend;
  end
end^


CREATE OR ALTER PROCEDURE ORDERITEM_X_GETSTATEID (
    I_DEST_PARAM_ID TYPE OF ID_PARAM,
    I_PARAM_NAME TYPE OF SIGN_ATTR,
    I_SRC_PARAM_ID TYPE OF ID_PARAM)
AS
declare variable V_UNPAID_INVOICE_COUNT type of VALUE_INTEGER;
declare variable V_STATE_ID type of ID_STATUS;
declare variable V_STATE_SIGN type of SIGN_OBJECT;
declare variable V_STORE_DATE type of VALUE_BOOLEAN;
begin
  select o_value from param_get(:i_src_param_id, 'NEW.STATE_SIGN') into :v_state_sign;

  select s.status_id, s.store_date
    from statuses s
    where s.status_sign = :v_state_sign
      and s.object_sign = 'ORDERITEM'
    into :v_state_id, :v_store_date;

  execute procedure param_set(:i_dest_param_id, :i_param_name, :v_state_id);
  if (:v_store_date = 1) then
  begin
    execute procedure param_set(:i_dest_param_id, 'DTM.'||:v_state_sign, current_timestamp);
  end
end^


CREATE OR ALTER PROCEDURE ORDERTAX_READ (
    I_OBJECT_ID TYPE OF ID_OBJECT)
RETURNS (
    O_PARAM_NAME TYPE OF SIGN_OBJECT,
    O_PARAM_VALUE TYPE OF VALUE_ATTR)
AS
declare variable V_TAXSERV_ID type of ID_TAX;
declare variable V_TAXSERV_NAME type of NAME_REF;
declare variable V_STATUS_SIGN type of SIGN_OBJECT;
declare variable V_STATUS_NAME type of NAME_OBJECT;
declare variable V_COST_EUR type of MONEY_EUR;
declare variable V_BYR2EUR type of MONEY_BYR;
begin
  select ts.taxserv_id, ts.taxserv_name, s.status_sign, s.status_name,
         ot.cost_eur, o.byr2eur
    from ordertaxs ot
      inner join taxrates tr on (tr.taxrate_id = ot.taxrate_id)
      inner join taxservs ts on (ts.taxserv_id = tr.taxserv_id)
      inner join statuses s on (s.status_id = ot.status_id)
      inner join orders o on (o.order_id = ot.order_id)
    where ot.ordertax_id = :i_object_id
    into :v_taxserv_id, :v_taxserv_name, :v_status_sign, :v_status_name,
         :v_cost_eur, :v_byr2eur;

  o_param_name = 'TAXSERV_ID';
  o_param_value = :v_taxserv_id;
  suspend;
  o_param_name = 'TAXSERV_NAME';
  o_param_value = :v_taxserv_name;
  suspend;
  o_param_name = 'STATUS_SIGN';
  o_param_value = v_status_sign;
  suspend;
  o_param_name = 'STATUS_NAME';
  o_param_value = v_status_name;
  suspend;
  o_param_name = 'COST_BYR';
  select o_money_byr from money_eur2byr(:v_cost_eur, :v_byr2eur) into o_param_value;
  suspend;
end^


CREATE OR ALTER PROCEDURE PACKLIST_UPSERT (
    I_PACKLIST_NO TYPE OF VALUE_INTEGER NOT NULL,
    I_PACKLIST_CODE TYPE OF VALUE_INTEGER NOT NULL)
AS
begin
  update or insert into packlists (packlist_no, packlist_code)
    values (:i_packlist_no, :i_packlist_code)
    matching (packlist_no);
end^


CREATE OR ALTER PROCEDURE PARAM_CALC_IN (
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT,
    I_DEST_PARAM_ID TYPE OF ID_PARAM,
    I_PARAM_NAME TYPE OF SIGN_OBJECT,
    I_PARAM_KIND TYPE OF KIND_PARAM,
    I_PARAM_VALUE TYPE OF VALUE_ATTR,
    I_SRC_PARAM_ID TYPE OF ID_PARAM)
AS
declare variable V_PARAM_VALUE type of VALUE_ATTR;
declare variable V_SQL type of SQL_STATEMENT;
declare variable V_TABLE_NAME type of NAME_PROCEDURE;
begin
  if (exists (select param_value from params
                where param_id = :i_dest_param_id
                  and param_name = :i_param_name)) then exit;

  if (:i_param_kind = 'I') then
    exception ex_mandatory_param_expected 'Mandatory parameter '||:i_param_name||' expected';
  else
  if (:i_param_kind = 'V') then
    execute procedure param_set(:i_dest_param_id, :i_param_name, :i_param_value);
  else
  if (:i_param_kind = 'A') then
  begin
    select param_value from params
      where param_name = :i_param_value
        and param_id = :i_src_param_id
      into :v_param_value;
    if (row_count = 1) then
      execute procedure param_set(:i_dest_param_id, :i_param_name, :v_param_value);
  end
  else
  if (:i_param_kind = 'X') then
  begin
    v_sql = 'execute procedure '||:i_object_sign||'_X_'||:i_param_value||' (:dest_param_id, :pattern, :src_param_id)';
    execute statement (:v_sql) (dest_param_id := :i_dest_param_id, pattern := :i_param_name, src_param_id := :i_src_param_id);
  end
  else
  if (:i_param_kind = 'B') then
  begin
    if (i_object_sign = 'ACCOUNT') then
      execute procedure account_x_search(:i_dest_param_id, :i_param_value, :i_src_param_id);
    else
    begin
      v_sql = 'execute procedure '||:i_object_sign||'_X_SEARCH (:dest_param_id, :pattern, :src_param_id)';
      execute statement (:v_sql) (dest_param_id := :i_dest_param_id, pattern := :i_param_value, src_param_id := :i_src_param_id);
    end
  end
  else
  if (:i_param_kind = 'F') then
  begin
    select o_pattern from param_fillpattern(:i_src_param_id, :i_param_value) into :v_sql;
    execute statement (:v_sql) into :v_param_value;
    execute procedure param_set (:i_dest_param_id, :i_param_name, :v_param_value);
  end
end^


CREATE OR ALTER PROCEDURE PARAM_CALC_OUT (
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT,
    I_SRC_PARAM_ID TYPE OF ID_PARAM,
    I_PARAM_NAME TYPE OF SIGN_OBJECT,
    I_PARAM_KIND TYPE OF KIND_PARAM,
    I_PARAM_VALUE TYPE OF VALUE_ATTR,
    I_DEST_PARAM_ID TYPE OF ID_PARAM)
AS
declare variable V_PARAM_VALUE type of VALUE_ATTR;
declare variable V_SQL type of SQL_STATEMENT;
declare variable V_ATTR_ID type of ID_ATTR;
begin
  if (:i_param_kind = 'O') then
  begin
    select param_value
      from params
      where param_id = :i_src_param_id
        and param_name = :i_param_name
      into :v_param_value;
    if (v_param_value is not null) then
      update or insert into params (param_id, param_name, param_value)
        values (:i_dest_param_id, :i_param_value, :v_param_value)
        matching (param_id, param_name);
  end
end^


CREATE OR ALTER PROCEDURE PARAM_CLONE (
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL,
    I_OBJECT_ID TYPE OF ID_OBJECT NOT NULL,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT NOT NULL)
RETURNS (
    O_PARAM_ID TYPE OF ID_PARAM)
AS
begin
  o_param_id = gen_id(seq_param_id, 1);
  insert into paramheads(param_id, object_sign, object_id)
    select :o_param_id, :i_object_sign, :i_object_id
      from paramheads ph
      where ph.param_id = :i_param_id;

  insert into params(param_id, param_name, param_value)
    select :o_param_id, param_name, param_value
      from params
      where param_id = :i_param_id;

  update params
    set param_value = :o_param_id
    where param_id = :o_param_id
      and param_name = 'PARAM_ID';

  if (i_object_id is not null) then
    update params
      set param_value = :i_object_id
      where param_id = :o_param_id
        and param_name = 'ID';

  suspend;
end^


CREATE OR ALTER PROCEDURE PARAM_CREATE (
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT NOT NULL,
    I_OBJECT_ID TYPE OF ID_OBJECT = null,
    I_ACTION_ID TYPE OF ID_ACTION = null)
RETURNS (
    O_PARAM_ID TYPE OF ID_PARAM)
AS
begin
  o_param_id = gen_id(seq_param_id, 1);

  insert into paramheads(param_id, object_sign, object_id, action_id)
    values(:o_param_id, :i_object_sign, :i_object_id, :i_action_id);

  insert into params(param_id, param_name, param_value)
    values(:o_param_id, 'PARAM_ID', :o_param_id);

  if (i_object_id is not null) then
    insert into params(param_id, param_name, param_value)
      values(:o_param_id, 'ID', :i_object_id);

  if (i_action_id is not null) then
    insert into params(param_id, param_name, param_value)
      values(:o_param_id, 'ACTION_ID', :i_action_id);

  suspend;
end^


CREATE OR ALTER PROCEDURE PARAM_CRITERIA (
    I_PARAM_ID TYPE OF ID_PARAM,
    I_PARAM_NAME TYPE OF SIGN_OBJECT,
    I_PARAM_ACTION TYPE OF SIGN_ACTION,
    I_PARAM_DATATYPE TYPE OF KIND_PARAM,
    I_PARAM_VALUE_1 TYPE OF VALUE_ATTR,
    I_PARAM_VALUE_2 TYPE OF VALUE_ATTR)
RETURNS (
    O_VALID TYPE OF BOOLEAN)
AS
declare variable V_VALUE type of VALUE_ATTR;
declare variable V_PARAM_NUMERIC_1 numeric(15,2);
declare variable V_NUMERIC numeric(15,2);
declare variable V_PARAM_NUMERIC_2 numeric(15,2);
begin
  o_valid = 0;
  if (not exists (select param_value
                    from params
                    where param_name = :i_param_name
                      and param_id = :i_param_id)) then
  begin
    if (:i_param_action = 'NOT EXISTS') then
      o_valid = 1;
  end
  else
  begin
    select param_value
      from params
      where param_name = :i_param_name
        and param_id = :i_param_id
      into :v_value;
    if (:i_param_datatype = 'N') then
    begin
      if (v_value is not null) then
        v_numeric = to_float(:v_value);
      else
        v_numeric = null;
      if (:i_param_value_1 <> 'NULL') then
        v_param_numeric_1 = to_float(:i_param_value_1);
      else
        v_param_numeric_2 = null;
      if (:i_param_value_2 is not null) then
        v_param_numeric_2 = to_float(:i_param_value_2);
      else
        v_param_numeric_2 = null;

      if ((i_param_action = '=') and (v_numeric  = v_param_numeric_1)) then
        o_valid = 1;
      else
      if ((:i_param_action = '<>') and (v_numeric <> v_param_numeric_1)) then
        o_valid = 1;
      else
      if ((:i_param_action = '>') and (v_numeric > v_param_numeric_1)) then
        o_valid = 1;
      else
      if ((:i_param_action = '<') and (v_numeric < v_param_numeric_1)) then
        o_valid = 1;
      else
      if ((:i_param_action = '>=') and (v_numeric >= v_param_numeric_1)) then
        o_valid = 1;
      else
      if ((:i_param_action = '<=') and (v_numeric <= v_param_numeric_1)) then
        o_valid = 1;
      else
      if ((:i_param_action = 'IS') and (:v_numeric is null)) then
        o_valid = 1;
      else
      if ((:i_param_action = 'IS NOT') and (:v_numeric is not null)) then
        o_valid = 1;
      else
      if ((:i_param_action = 'BETWEEN_[]') and (v_numeric between v_param_numeric_1 and v_param_numeric_2)) then
        o_valid = 1;
    end
    else
    if (:i_param_datatype = 'S') then
    begin
      if ((:i_param_action = '=') and (cast(:v_value as value_attr) = cast(:i_param_value_1 as value_attr))) then
        o_valid = 1;
      else
      if ((:i_param_action = '<>') and (cast(:v_value as value_attr) <> cast(:i_param_value_1 as value_attr))) then
        o_valid = 1;
      else
      if ((:i_param_action = 'IS') and (:v_value is null)) then
        o_valid = 1;
      else
      if ((:i_param_action = 'IS NOT') and (:v_value is not null)) then
        o_valid = 1;
      else
      if ((:i_param_action = 'IN') and (','||cast(:i_param_value_1 as value_attr)||',' like '%,'||cast(:v_value as value_attr)||',%')) then
        o_valid = 1;
      else
      if ((:i_param_action = 'NOT IN') and (','||cast(:i_param_value_1 as value_attr)||',' not like '%,'||cast(:v_value as value_attr)||',%')) then
        o_valid = 1;
    end
  end
  suspend;
end^


CREATE OR ALTER PROCEDURE PARAM_DEL (
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL,
    I_PARAM_NAME TYPE OF SIGN_OBJECT)
AS
begin
  if (:i_param_name is null) then
    delete from params
      where param_id = :i_param_id
        and param_name <> 'PARAM_ID';
  else
    delete from params
      where param_id = :i_param_id
        and param_name = :i_param_name;
end^


CREATE OR ALTER PROCEDURE PARAM_FILL (
    I_PATTERN TYPE OF VALUE_ATTR NOT NULL,
    I_PARAM_NAME TYPE OF OBJ_CODE NOT NULL,
    I_PARAM_VALUE TYPE OF VALUE_ATTR)
RETURNS (
    O_PATTERN TYPE OF VALUE_ATTR)
AS
begin
  o_pattern = replace(i_pattern, '['||:i_param_name||']', coalesce(:i_param_value, ''));
  suspend;
end^


CREATE OR ALTER PROCEDURE PARAM_FILLPATTERN (
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL,
    I_PATTERN TYPE OF VALUE_ATTR)
RETURNS (
    O_PATTERN TYPE OF VALUE_ATTR)
AS
declare variable V_PARAM_NAME type of SIGN_ATTR;
declare variable V_PARAM_VALUE type of VALUE_ATTR;
begin
  o_pattern = i_pattern;
  for select p.param_name, coalesce(p.param_value, '')
        from params p
        where p.param_id = :i_param_id
        into :v_param_name, :v_param_value do
      o_pattern = replace(o_pattern, '['||:v_param_name||']', :v_param_value);
  suspend;
end^


CREATE OR ALTER PROCEDURE PARAM_GET (
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL,
    I_PARAM_NAME TYPE OF SIGN_OBJECT NOT NULL,
    I_DEFAULT_VALUE TYPE OF VALUE_ATTR = null)
RETURNS (
    O_VALUE TYPE OF VALUE_ATTR)
AS
begin
  select param_value
    from params
    where param_id = :i_param_id
      and param_name = upper(:i_param_name)
    into :o_value;
  o_value = coalesce(:o_value, :i_default_value);
  suspend;
end^


CREATE OR ALTER PROCEDURE PARAM_MERGE (
    I_DEST_PARAM_ID TYPE OF ID_PARAM NOT NULL,
    I_SRC_PARAM_ID TYPE OF ID_PARAM NOT NULL,
    I_PREFIX TYPE OF SIGN_OBJECT)
AS
begin
  insert into params
  select :i_dest_param_id, :i_prefix||p.param_name, p.param_value
    from params p
    where p.param_id = :i_src_param_id;
end^


CREATE OR ALTER PROCEDURE PARAM_PARSE (
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL)
RETURNS (
    O_PARAMS TYPE OF VALUE_BLOB)
AS
begin
  select list(p.param_name||'='||escapestring(p.param_value), ascii_char(13)||ascii_char(10))
    from params p
    where p.param_id = :i_param_id
    group by p.param_id
    into o_params;
  suspend;
end^


CREATE OR ALTER PROCEDURE PARAM_PARSE_4ACTION (
    I_ACTION_ID TYPE OF ID_PARAM)
RETURNS (
    O_PARAMS TYPE OF VALUE_BLOB)
AS
begin
  select list(p.param_name||'='||escapestring(p.param_value), ascii_char(13)||ascii_char(10))
    from params p
      inner join paramheads ph on (ph.param_id = p.param_id)
    where ph.action_id = :i_action_id
    group by p.param_id
    into o_params;
  suspend;
end^


CREATE OR ALTER PROCEDURE PARAM_SET (
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL,
    I_PARAM_NAME TYPE OF SIGN_OBJECT NOT NULL,
    I_PARAM_VALUE TYPE OF VALUE_ATTR)
AS
begin
  update or insert into params (param_id, param_name, param_value)
    values(:i_param_id, upper(:i_param_name), cast(:i_param_value as value_attr))
    matching (param_id, param_name);
end^


CREATE OR ALTER PROCEDURE PARAM_UNPARSE (
    I_PARAM_ID TYPE OF ID_PARAM,
    I_PARAMS TYPE OF VALUE_BLOB)
AS
declare variable V_LINE type of VALUE_ATTR;
declare variable V_PARAM_SIGN type of SIGN_OBJECT;
declare variable V_PARAM_VALUE type of VALUE_ATTR;
begin
  for select o_line from splitblob(:i_params, ascii_char(13)||ascii_char(10))
    where o_line <> ''
    into :v_line
  do begin
    select trim(o_head), trim(o_tile) from splitstring(:v_line, '=')
      into :v_param_sign, :v_param_value;
    if (v_param_value like '"%"') then
      v_param_value = substring(v_param_value from 2 for strlen(v_param_value)-2);

    update or insert into params(param_id, param_name, param_value)
      values(:i_param_id, :v_param_sign, unescapestring(:v_param_value))
      matching (param_id, param_name);
  end
end^


CREATE OR ALTER PROCEDURE PIVOT_RECORD (
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT NOT NULL)
RETURNS (
    O_SQL TYPE OF SQL_STATEMENT)
AS
declare variable V_ATTR_SIGN type of SIGN_OBJECT;
declare variable V_TABLE_NAME type of NAME_PROCEDURE;
declare variable V_FIELD_NAME type of NAME_PROCEDURE;
declare variable V_IDFIELD_NAME type of NAME_PROCEDURE;
declare variable V_ATTR_TABLE_NAME type of NAME_PROCEDURE;
begin
  select o.table_name, o.idfield_name, o.attr_table_name
    from objects o
    where o.object_sign = :i_object_sign
    into :v_table_name, :v_idfield_name, :v_attr_table_name;

  o_sql = 'select ''ID'' As Attr_sign, '||:v_idfield_name||' as Attr_value '||ascii_char(13)||ascii_char(10)||
      ' from '||v_table_name||' where '||v_idfield_name||' = :id'||ascii_char(13)||ascii_char(10);
  for select a.attr_sign, a.field_name
    from attrs a
    where a.field_name is not null
      and a.object_sign = :i_object_sign
      and coalesce(a.direction, 'R') = 'R'
    into :v_attr_sign, :v_field_name
  do begin
    o_sql = o_sql||'union'||ascii_char(13)||ascii_char(10)||
      'select '''||:v_attr_sign||''', cast('||:v_field_name||' as varchar(4000))'||ascii_char(13)||ascii_char(10)||
      ' from '||v_table_name||
      ' where '||v_idfield_name||' = :id '||
      ' and '||v_field_name||' is not null'||ascii_char(13)||ascii_char(10);
  end
  o_sql = o_sql||'union'||ascii_char(13)||ascii_char(10)||
    'select ''STATUS_SIGN'', statuses.status_sign'||ascii_char(13)||ascii_char(10)||
    ' from  '||v_table_name||' tbl '||
    '   inner join statuses on (statuses.status_id = tbl.status_id)'||
    ' where '||v_idfield_name||' = :id '||ascii_char(13)||ascii_char(10);

  if (v_attr_table_name is not null) then
    o_sql = o_sql||'union'||ascii_char(13)||ascii_char(10)||
      'select a.attr_sign, av.attr_value '||ascii_char(13)||ascii_char(10)||
      ' from '||v_attr_table_name||' av '||ascii_char(13)||ascii_char(10)||
      ' inner join attrs a on (a.attr_id = av.attr_id and coalesce(a.direction, ''R'') = ''R'')'||ascii_char(13)||ascii_char(10)||
      ' where object_id = :id';
  suspend;
end^


CREATE OR ALTER PROCEDURE PLACE_DETECT (
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL)
RETURNS (
    O_PLACE_ID TYPE OF ID_PLACE,
    O_AREA_ID TYPE OF ID_PLACE,
    O_REGION_ID TYPE OF ID_PLACE)
AS
declare variable V_PLACE_NAME type of NAME_REF;
declare variable V_VALUE type of NAME_REF;
declare variable V_PLACETYPE_CODE type of CODE_PLACETYPE;
begin
  -- ischem placetype
  select o_value from param_get(:i_param_id, 'PLACETYPE_SIGN') into :v_value;
  if (v_value is null) then
    v_placetype_code = 4;
  else
  begin
    select pt.placetype_code from placetypes pt
      where pt.adrtype_short = :v_value
      into :v_placetype_code;
    if (:v_placetype_code is null) then
      exception ex_unknown_placetype '=хшчтхёЄэvщ Єшя эрёхыхээюую яєэъЄр "'||v_value||'"';
  end

  -- ischem gorod
  select o_value from param_get(:i_param_id, 'PLACE_NAME') into :v_place_name;
  if (v_placetype_code = 4) then
  begin
    select p.place_id, nullif(p.owner_place, 0)
      from places p
      where lower(p.place_name) = lower(:v_place_name)
        and p.placetype_code = 4
      into :o_place_id, :o_region_id;
  end
  else
  -- ischem prochie naselennye punkty
  begin
    -- ischem raion
    select o_value from param_get(:i_param_id, 'AREA_NAME') into :v_value;
    if (v_value is null) then
      exception ex_areaname_expected '+ЄёєЄёЄтєхЄ эрчтрэшх Ёрщюэр';
    select p.place_id, p.owner_place
      from places p
      where lower(place_name) = lower(:v_value)
        and p.placetype_code = 3
      into :o_area_id, :o_region_id;

    select p.place_id
      from places p
      where lower(p.place_name) = lower(:v_place_name)
        and p.owner_place = :o_area_id
        and p.placetype_code > 4
      into :o_place_id;
  end

  suspend;
end^


CREATE OR ALTER PROCEDURE PLACE_READ (
    I_OBJECT_ID TYPE OF ID_OBJECT)
RETURNS (
    O_PARAM_NAME TYPE OF SIGN_OBJECT,
    O_PARAM_VALUE TYPE OF VALUE_ATTR)
AS
declare variable V_REGION_NAME type of NAME_OBJECT;
declare variable V_AREA_NAME type of NAME_OBJECT;
declare variable V_PLACETYPE_SIGN type of NAME_SHORT;
begin
  select p.area_name, p.region_name, p.placetype_sign
    from v_places p
    where p.place_id = :i_object_id
    into :v_area_name, :v_region_name, :v_placetype_sign;

  if (:v_area_name is not null) then
  begin
    o_param_name = 'AREA_NAME';
    o_param_value = :v_area_name;
    suspend;
  end

  if (:v_region_name is not null) then
  begin
    o_param_name = 'REGION_NAME';
    o_param_value = :v_region_name;
    suspend;
  end

  o_param_name = 'PLACETYPE_SIGN';
  o_param_value = :v_placetype_sign;
  suspend;

end^


CREATE OR ALTER PROCEDURE PLUGIN_VALUE (
    I_PLUGIN_SIGN TYPE OF SIGN_PLUGIN NOT NULL,
    I_PARAM_SIGN TYPE OF SIGN_ATTR NOT NULL)
RETURNS (
    O_VALUE TYPE OF VALUE_ATTR)
AS
begin
  select param_value
    from plugin_params pp
      inner join plugins p on (p.plugin_id = pp.plugin_id)
    where p.plugin_sign = upper(:i_plugin_sign)
      and pp.param_sign = :i_param_sign
    into :o_value;
  suspend;
end^


CREATE OR ALTER PROCEDURE SEARCH (
    I_VALUE TYPE OF NAME_REF,
    I_FROM_CLAUSE TYPE OF SQL_STATEMENT,
    I_FIELDNAME_ID TYPE OF NAME_PROCEDURE,
    I_FIELDNAME_NAME TYPE OF NAME_PROCEDURE,
    I_WHERE_CLAUSE TYPE OF SQL_STATEMENT,
    I_THRESHOLD TYPE OF VALUE_SMALLINT = 80)
RETURNS (
    O_OBJECT_ID TYPE OF ID_OBJECT,
    O_OBJECT_NAME TYPE OF NAME_REF,
    O_VALID TYPE OF VALUE_SMALLINT)
AS
declare variable V_SQL type of SQL_STATEMENT;
declare variable V_MASK type of MASK_NGRAMM;
declare variable V_SEARCH_ID type of ID_SEARCH;
declare variable V_STRLEN type of VALUE_SMALLINT;
begin
  if (:i_value is null) then exit;
  -- try find fitness
  v_sql = 'select '||:i_fieldname_id||', '||:i_fieldname_name||', 100'||
          ' from '||:i_from_clause||
          ' where (lower('||:i_fieldname_name||') = lower(:i_value)'||
          ' or cast('||:i_fieldname_id||' as varchar(100)) = :i_value)'||
          ' and '||coalesce(:i_where_clause, '1=1');

  for execute statement (:v_sql) (i_value := :i_value)
    into :o_object_id, :o_object_name, :o_valid do
      suspend;
  if (o_object_id is null) then
  begin
    -- fuzzy search by NGramm
    v_search_id = gen_id(seq_search_id, 1);
    v_strlen = char_length(:i_value);

    for select o_mask from search_get_ngramm(:i_value) into :v_mask
    do begin
      v_sql = 'insert into searches(search_id, object_id, object_name) '||
              'select :v_search_id, '||:i_fieldname_id||', '||:i_fieldname_name||
              ' from '||:i_from_clause||
              ' where lower('||:i_fieldname_name||') like :v_mask '||
              ' and '||coalesce(:i_where_clause, '1=1');
      execute statement (:v_sql) (v_search_id := :v_search_id, v_mask := :v_mask);
    end

    for select object_id id, max(object_name) name, count(object_id)*100/:v_strlen valid
      from searches s
      where search_id = :v_search_id
      group by object_id
      having count(object_id)*100/:v_strlen > :i_threshold
      order by valid desc
      into :o_object_id, :o_object_name, :o_valid
    do begin
      suspend;
    end

    delete from searches where search_id = :v_search_id;
  end
end^


CREATE OR ALTER PROCEDURE SEARCH_GET_NGRAMM (
    I_VALUE TYPE OF NAME_REF NOT NULL,
    I_NGRAMM_LEN TYPE OF VALUE_INTEGER = 3)
RETURNS (
    O_MASK TYPE OF MASK_NGRAMM)
AS
declare variable V_STRLEN type of VALUE_INTEGER;
declare variable V_POS type of VALUE_INTEGER;
declare variable V_MASKLEN type of VALUE_INTEGER;
begin
  i_value = lower(:i_value);
  v_strlen = char_length(:i_value);
  if (v_strlen <= :i_ngramm_len) then
  begin
    o_mask = '%'||:i_value||'%';
    suspend;
  end
  else
  begin
    v_pos = 1;
    while (v_pos <= v_strlen) do
    begin
      o_mask = substring(:i_value from :v_pos for :i_ngramm_len);
      v_masklen = char_length(o_mask);
      if (v_masklen = i_ngramm_len) then
        o_mask = '%'||o_mask||'%';
      else
        o_mask = substring(:i_value from 1 for i_ngramm_len - v_masklen)||'%'||o_mask;
      suspend;
      v_pos = v_pos + 1;
    end
  end
end^


CREATE OR ALTER PROCEDURE SETTING_GET (
    I_SETTING_SIGN TYPE OF SIGN_ATTR,
    I_ON_DATE TYPE OF DTM_VALID = current_timestamp)
RETURNS (
    O_VALUE TYPE OF VALUE_ATTR)
AS
begin
  select first 1 s.setting_value
    from settings s
    where s.setting_sign = :i_setting_sign
      and s.valid_dtm > :i_on_date
    order by s.valid_dtm
    into :o_value;
  suspend;
end^


CREATE OR ALTER PROCEDURE SETTING_SET (
    I_SETTING_SIGN TYPE OF SIGN_ATTR NOT NULL,
    I_VALUE TYPE OF VALUE_ATTR)
RETURNS (
    O_SETTING_ID TYPE OF ID_SETTING)
AS
declare variable V_VALID_DTM type of DTM_VALID;
begin
  v_valid_dtm = current_timestamp;
  update settings s
    set s.valid_dtm = addsecond(:v_valid_dtm, -1)
    where s.setting_sign = :i_setting_sign
      and s.valid_dtm = '9999.12.31';
  insert into settings (setting_sign, setting_value)
    values(:i_setting_sign, :i_value)
    returning setting_id
    into :o_setting_id;
  suspend;
end^


CREATE OR ALTER PROCEDURE SPLITBLOB (
    I_BLOB TYPE OF VALUE_BLOB,
    I_DEVIDER TYPE OF DEVIDER)
RETURNS (
    O_LINE TYPE OF VALUE_ATTR)
AS
declare variable V_POS type of VALUE_INTEGER;
declare variable V_STR type of VALUE_ATTR;
begin
  v_pos = 1;
  v_str = substring(:i_blob from v_pos for 4000);
  while (char_length(v_str) > 0) do
  begin
    select o_head from splitstring(:v_str, :i_devider) into :o_line;
    v_pos = v_pos + char_length(:o_line) + 2;
    suspend;
    v_str = substring(:i_blob from v_pos for 4000);
  end
end^


CREATE OR ALTER PROCEDURE SPLITSTRING (
    I_STRING TYPE OF VALUE_ATTR,
    I_DEVIDER TYPE OF DEVIDER)
RETURNS (
    O_HEAD TYPE OF VALUE_ATTR,
    O_TILE TYPE OF VALUE_ATTR)
AS
begin
  o_head = nullif(copyfront_withkey(:i_string, :i_devider), '');
  if (o_head is null) then
    o_head = i_string;
  else
  begin
    o_tile = nullif(substring(:i_string from strlen(o_Head)+1), '');
    o_head = nullif(copyfront_withoutkey(:o_Head, :i_devider), '');
  end
  suspend;
end^


CREATE OR ALTER PROCEDURE STATUS_CHECK_CONVERSION (
    I_NOW_STATUS_ID TYPE OF ID_STATUS NOT NULL,
    I_NEW_STATUS_ID TYPE OF ID_STATUS NOT NULL)
RETURNS (
    O_NEW_STATUS_ID TYPE OF ID_STATUS)
AS
declare variable V_CNT type of VALUE_INTEGER;
begin
  if (i_now_status_id <> i_new_status_id) then
    select r.new_status_id
      from status_rules r
      where r.old_status_id = :i_now_status_id
        and r.new_status_id = :i_new_status_id
      into :o_new_status_id;
  else
    o_new_status_id = i_new_status_id;
  suspend;
end^


CREATE OR ALTER PROCEDURE STATUS_CONVERSION_BY_FLAG (
    I_NOW_STATUS_ID TYPE OF ID_STATUS,
    I_NEW_FLAG_SIGN TYPE OF SIGN_FLAG,
    I_PARAM_ID TYPE OF ID_PARAM)
RETURNS (
    O_NEW_STATUS_ID TYPE OF ID_STATUS)
AS
begin
  select r.new_status_id
    from status_rules r
      inner join flags2statuses f2s on (f2s.status_id = r.new_status_id)
      inner join statuses s on (s.status_id = r.old_status_id)
    where r.old_status_id = :i_now_status_id
      and f2s.flag_sign = :i_new_flag_sign
    into :o_new_status_id;

  if (row_count = 0) then
    exception ex_status_conversion_unavail;

  suspend;

  when sqlcode -811 do
    exception ex_to_many_conversion_rules '2 or more new_status_id detected on conversion from STATUS_ID='||:i_now_status_id
      ||' by FLAG_SIGN='||:i_new_flag_sign;
  when any do
    exception;
end^


CREATE OR ALTER PROCEDURE STATUS_GET_CONVERSION (
    I_NOW_STATUS_ID TYPE OF ID_STATUS NOT NULL,
    I_NEW_FLAG_SIGN TYPE OF SIGN_FLAG NOT NULL,
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL)
RETURNS (
    O_NEW_STATUS_ID TYPE OF ID_STATUS)
AS
begin
  select r.new_status_id
    from status_rules r
      inner join flags2statuses f2s on (f2s.status_id = r.new_status_id)
      inner join statuses s on (s.status_id = r.old_status_id)
    where r.old_status_id = :i_now_status_id
      and f2s.flag_sign = :i_new_flag_sign
    into :o_new_status_id;

  if (row_count = 0) then
    exception ex_status_conversion_unavail;

  suspend;

  when sqlcode -811 do
    exception ex_to_many_conversion_rules '2 or more new_status_id detected on conversion from STATUS_ID='||:i_now_status_id
      ||' by FLAG_SIGN='||:i_new_flag_sign;
  when any do
    exception;
end^


CREATE OR ALTER PROCEDURE STATUS_GET_DEFAULT (
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT NOT NULL)
RETURNS (
    O_STATUS_ID TYPE OF ID_STATUS)
AS
begin
  select s.status_id
    from statuses s
    where s.object_sign = :i_object_sign
      and s.is_default = 1
    into :o_status_id;
  suspend;
end^


CREATE OR ALTER PROCEDURE STATUS_STORE_DATE (
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_STATUS_ID TYPE OF ID_STATUS)
AS
declare variable V_OBJECT_SIGN type of SIGN_OBJECT;
declare variable V_STATUS_SIGN type of SIGN_ATTR;
declare variable V_STORE_DATE type of BOOLEAN;
begin
  select s.object_sign, s.status_sign, s.store_date
    from statuses s
    where s.status_id = :i_status_id
    into :v_object_sign, :v_status_sign, :v_store_date;
  if (v_store_date = 1) then
  begin
    execute procedure attr_put(:v_object_sign, :i_object_id, 'DTM.'||:v_status_sign, current_timestamp);
  end
end^


CREATE OR ALTER PROCEDURE TAX_ENTERED_SUM (
    I_TAXRATE_ID TYPE OF ID_TAX,
    I_PARAM_ID TYPE OF ID_PARAM)
RETURNS (
    O_COST_EUR TYPE OF MONEY_EUR)
AS
declare variable V_PRICE_EUR type of MONEY_EUR;
declare variable V_PARAM_NAME type of SIGN_OBJECT;
begin
  select ta.attr_value
    from taxrate_attrs ta
      inner join attrs a on (a.attr_id = ta.attr_id)
    where ta.object_id = :i_taxrate_id
      and a.attr_sign = 'PARAM_NAME'
    into :v_param_name;
  select o_value from param_get(:i_param_id, :v_param_name) into :v_price_eur;
  execute procedure param_set(:i_param_id, 'PRICE_EUR', :v_price_eur);
  execute procedure param_set(:i_param_id, 'AMOUNT', 1);
  o_cost_eur = v_price_eur;
  suspend;
end^


CREATE OR ALTER PROCEDURE TAX_FIXED_SUM (
    I_TAXRATE_ID TYPE OF ID_TAX NOT NULL,
    I_PARAM_ID TYPE OF ID_PARAM)
RETURNS (
    O_COST_EUR TYPE OF MONEY_EUR)
AS
declare variable V_PRICE_EUR type of MONEY_EUR;
begin
  select ta.attr_value
    from taxrate_attrs ta
      inner join attrs a on (a.attr_id = ta.attr_id)
    where ta.object_id = :i_taxrate_id
      and a.attr_sign = 'VALUE'
    into :v_price_eur;
  execute procedure param_set(:i_param_id, 'PRICE_EUR', :v_price_eur);
  execute procedure param_set(:i_param_id, 'AMOUNT', 1);
  o_cost_eur = v_price_eur;
  suspend;
end^


CREATE OR ALTER PROCEDURE TAX_USE_REST (
    I_TAXRATE_ID TYPE OF ID_TAX,
    I_PARAM_ID TYPE OF ID_PARAM)
RETURNS (
    O_COST_EUR TYPE OF MONEY_EUR)
AS
declare variable V_AMOUNT type of VALUE_INTEGER;
declare variable V_ORDER_ID type of ID_ORDER;
declare variable V_PRICE_AMOUNT type of VALUE_INTEGER;
declare variable V_PRICE_EUR type of MONEY_EUR;
declare variable V_TAX_AMOUNT type of VALUE_INTEGER;
declare variable V_FREE_AMOUNT type of VALUE_INTEGER;
begin
  select o_value from param_get(:i_param_id, 'ORDER_ID') into :v_order_id;

  select a.rest_eur
    from accounts a
      inner join clients c on (c.account_id = a.account_id)
      inner join orders o on (o.client_id = c.client_id)
    where o.order_id = :v_order_id
    into :o_cost_eur;
--  if (o_cost_eur) then

  execute procedure param_set(:i_param_id, 'PRICE_EUR', :v_price_eur);
  execute procedure param_set(:i_param_id, 'AMOUNT', :v_tax_amount);
  o_cost_eur = :v_price_eur*:v_tax_amount;
  suspend;
end^


CREATE OR ALTER PROCEDURE TAX_WEIGHT (
    I_TAXRATE_ID TYPE OF ID_TAX,
    I_PARAM_ID TYPE OF ID_PARAM)
RETURNS (
    O_COST_EUR TYPE OF MONEY_EUR)
AS
declare variable V_AMOUNT type of VALUE_INTEGER;
declare variable V_ORDER_ID type of ID_ORDER;
declare variable V_PRICE_AMOUNT type of VALUE_INTEGER;
declare variable V_PRICE_EUR type of MONEY_EUR;
declare variable V_TAX_AMOUNT type of VALUE_INTEGER;
declare variable V_WEIGHT_TRASHOLD type of VALUE_INTEGER;
begin
  select o_value from param_get(:i_param_id, 'ORDER_ID') into :v_order_id;

  select ta.attr_value
    from v_taxrate_attrs ta
    where ta.object_id = :i_taxrate_id
      and ta.attr_sign = 'PRICE'
    into :v_price_eur;

  select ta.attr_value
    from v_taxrate_attrs ta
    where ta.object_id = :i_taxrate_id
      and ta.attr_sign = 'PRICE_AMOUNT'
    into :v_price_amount;

  select ta.attr_value
    from v_taxrate_attrs ta
    where ta.object_id = :i_taxrate_id
      and ta.attr_sign = 'WEIGHT_TRASHOLD'
    into :v_weight_trashold;

  select o.weight
    from orders o
    where o.order_id = :v_order_id
    into :v_amount;

  if (v_amount - v_weight_trashold > 0) then
  begin
    v_tax_amount = (v_amount-v_weight_trashold)/ v_price_amount;
    if (v_tax_amount * v_price_amount < v_amount) then
     v_tax_amount = v_tax_amount + 1;
  end
  else
    v_tax_amount = 0;

  execute procedure param_set(:i_param_id, 'PRICE_EUR', :v_price_eur);
  execute procedure param_set(:i_param_id, 'AMOUNT', :v_tax_amount);
  o_cost_eur = :v_price_eur*:v_tax_amount;
  suspend;
end^


CREATE OR ALTER PROCEDURE TAXRATE_CALC (
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL)
RETURNS (
    O_TAXRATE_ID TYPE OF ID_TAX,
    O_VALUE_EUR TYPE OF MONEY_EUR)
AS
declare variable V_TAXPLAN_ID type of ID_TAX;
declare variable V_TAXSERV_ID type of ID_TAXSERV;
declare variable V_TAX_PROCEDURE type of NAME_PROCEDURE;
declare variable V_SQL type of SQL_STATEMENT;
begin
  select o_value from param_get(:i_param_id, 'TAXPLAN_ID') into :v_taxplan_id;
  select o_value from param_get(:i_param_id, 'TAXSERV_ID') into :v_taxserv_id;

  select tr.taxrate_id, tr.tax_procedure
    from taxrates tr
    where tr.taxplan_id = :v_taxplan_id
      and tr.taxserv_id = :v_taxserv_id
    into :o_taxrate_id, :v_tax_procedure;

  v_sql = 'select o_value_eur from '||v_tax_procedure||'(:taxrate_id, :param_id)';
  execute statement (:v_sql) (taxrate_id := :o_taxrate_id, param_id := :i_param_id)
    into :o_value_eur;
  suspend;
end^



SET TERM ; ^


/******************************************************************************/
/***                                 Roles                                  ***/
/******************************************************************************/

CREATE ROLE USERS;
