

/******************************************************************************/
/***                           Unique Constraints                           ***/
/******************************************************************************/

ALTER TABLE ARTICLECODES ADD CONSTRAINT UNQ1_ARTICLECODES UNIQUE (MAGAZINE_ID, ARTICLE_CODE);
ALTER TABLE ARTICLES ADD CONSTRAINT UNQ1_ARTICLES UNIQUE (ARTICLECODE_ID, DIMENSION);
ALTER TABLE MESSAGES ADD CONSTRAINT UNQ1_MESSAGES UNIQUE (FILE_NAME);


/******************************************************************************/
/***                              Primary Keys                              ***/
/******************************************************************************/

ALTER TABLE ACCOPERS ADD CONSTRAINT PK_ACCOPERS PRIMARY KEY (ACCOPER_ID);
ALTER TABLE ACCOUNTS ADD CONSTRAINT PK_ACCOUNTS PRIMARY KEY (ACCOUNT_ID);
ALTER TABLE ACTIONCODES ADD CONSTRAINT PK_ACTIONCODES PRIMARY KEY (ACTION_SIGN);
ALTER TABLE ACTIONCODE_CRITERIAS ADD CONSTRAINT PK_ACTIONCODE_CRITERIAS PRIMARY KEY (ACTIONCODE_SIGN, PARAM_NAME);
ALTER TABLE ACTIONCODE_PARAMS ADD CONSTRAINT PK_ACTIONCODE_PARAMS PRIMARY KEY (ACTION_SIGN, PARAM_NAME, PARAM_KIND);
ALTER TABLE ACTIONS ADD CONSTRAINT PK_ACTIONS PRIMARY KEY (ACTION_ID);
ALTER TABLE ACTIONTREE ADD CONSTRAINT PK_ACTIONTREE PRIMARY KEY (ACTIONTREEITEM_ID);
ALTER TABLE ACTIONTREE_CRITERIAS ADD CONSTRAINT PK_ACTIONTREE_CRITERIAS PRIMARY KEY (ACTIONTREEITEM_ID, PARAM_NAME);
ALTER TABLE ACTIONTREE_PARAMS ADD CONSTRAINT PK_ACTIONTREE_PARAMS PRIMARY KEY (ACTIONTREEITEM_ID, PARAM_NAME, PARAM_KIND);
ALTER TABLE ACTION_ATTRS ADD CONSTRAINT PK_ACTION_ATTRS PRIMARY KEY (OBJECT_ID, ATTR_ID);
ALTER TABLE ADRESSES ADD CONSTRAINT PK_ADRESSES PRIMARY KEY (ADRESS_ID);
ALTER TABLE ARTICLECODES ADD CONSTRAINT PK_ARTICLECODES PRIMARY KEY (ARTICLECODE_ID);
ALTER TABLE ARTICLECODE_ATTRS ADD CONSTRAINT PK_ARTICLECODE_ATTRS PRIMARY KEY (OBJECT_ID, ATTR_ID);
ALTER TABLE ARTICLEMASKS ADD CONSTRAINT PK_ARTICLEMASKS PRIMARY KEY (CATALOG_ID, ARTICLE_CODE_MASK);
ALTER TABLE ARTICLES ADD CONSTRAINT PK_ARTICLES PRIMARY KEY (ARTICLE_ID);
ALTER TABLE ARTICLESIGNS ADD CONSTRAINT PK_ARTICLESIGNS PRIMARY KEY (ARTICLESIGN_ID);
ALTER TABLE ARTICLE_ATTRS ADD CONSTRAINT PK_ARTICLE_ATTRS PRIMARY KEY (OBJECT_ID, ATTR_ID);
ALTER TABLE ATTRS ADD CONSTRAINT PK_ATTRS PRIMARY KEY (ATTR_ID);
ALTER TABLE BUILDS ADD CONSTRAINT PK_BUILDS PRIMARY KEY (BUILD);
ALTER TABLE CALCPOINTS ADD CONSTRAINT PK_CALCPOINTS PRIMARY KEY (CALCPOINT_ID);
ALTER TABLE CATALOG2PLUGIN ADD CONSTRAINT PK_CATALOG2PLUGIN PRIMARY KEY (CATALOG_ID, PLUGIN_ID);
ALTER TABLE CATALOGS ADD CONSTRAINT PK_CATALOGS PRIMARY KEY (CATALOG_ID);
ALTER TABLE CLIENTS ADD CONSTRAINT PK_CLIENTS PRIMARY KEY (CLIENT_ID);
ALTER TABLE CLIENT_ATTRS ADD CONSTRAINT PK_CLIENT_ATTRS PRIMARY KEY (OBJECT_ID, ATTR_ID);
ALTER TABLE COUNTERS ADD CONSTRAINT PK_COUNTERS PRIMARY KEY (OBJECT_SIGN, ATTR_SIGN, OBJECT_ID);
ALTER TABLE DETECTOR ADD CONSTRAINT PK_DETECTOR PRIMARY KEY (OBJECT_SIGN, OBJECT_ID, PARAM_SIGN);
ALTER TABLE EVENTCODES ADD CONSTRAINT PK_EVENTCODES PRIMARY KEY (EVENT_SIGN);
ALTER TABLE EVENTS ADD CONSTRAINT PK_EVENTS PRIMARY KEY (EVENT_ID);
ALTER TABLE FLAGS ADD CONSTRAINT PK_FLAGS PRIMARY KEY (FLAG_SIGN);
ALTER TABLE FLAGS2STATUSES ADD CONSTRAINT PK_FLAGS2STATUSES PRIMARY KEY (STATUS_ID, FLAG_SIGN);
ALTER TABLE LOGS ADD CONSTRAINT PK_LOGS PRIMARY KEY (LOG_ID);
ALTER TABLE MAGAZINES ADD CONSTRAINT PK_MAGAZINES PRIMARY KEY (MAGAZINE_ID);
ALTER TABLE MESSAGES ADD CONSTRAINT PK_MESSAGES PRIMARY KEY (MESSAGE_ID);
ALTER TABLE MESSAGE_ATTRS ADD CONSTRAINT PK_MESSAGE_ATTRS PRIMARY KEY (OBJECT_ID, ATTR_ID);
ALTER TABLE NOTIFIES ADD CONSTRAINT PK_NOTIFIES PRIMARY KEY (NOTIFY_ID);
ALTER TABLE OBJECTS ADD CONSTRAINT PK_OBJECTS PRIMARY KEY (OBJECT_SIGN);
ALTER TABLE ORDERITEMS ADD CONSTRAINT PK_ORDERITEMS PRIMARY KEY (ORDERITEM_ID);
ALTER TABLE ORDERITEM_ATTRS ADD CONSTRAINT PK_ORDERITEM_ATTRS PRIMARY KEY (OBJECT_ID, ATTR_ID);
ALTER TABLE ORDERMONEYS ADD CONSTRAINT PK_ORDERMONEYS PRIMARY KEY (ORDERMONEY_ID);
ALTER TABLE ORDERS ADD CONSTRAINT PK_ORDERS PRIMARY KEY (ORDER_ID);
ALTER TABLE ORDERTAXS ADD CONSTRAINT PK_ORDERTAXS PRIMARY KEY (ORDERTAX_ID);
ALTER TABLE ORDER_ATTRS ADD CONSTRAINT PK_ORDER_ATTRS PRIMARY KEY (OBJECT_ID, ATTR_ID);
ALTER TABLE PARAMACTIONS ADD CONSTRAINT PK_PARAMACTIONS PRIMARY KEY (PARAM_KIND, PARAM_ACTION);
ALTER TABLE PARAMHEADS ADD CONSTRAINT PK_PARAMHEADS PRIMARY KEY (PARAM_ID);
ALTER TABLE PARAMKINDS ADD CONSTRAINT PK_PARAMKINDS PRIMARY KEY (PARAM_KIND);
ALTER TABLE PARAMS ADD CONSTRAINT PK_PARAMS PRIMARY KEY (PARAM_NAME, PARAM_ID);
ALTER TABLE PAYMENTS ADD CONSTRAINT PK_PAYMENTS PRIMARY KEY (PAYMENT_ID);
ALTER TABLE PLACES ADD CONSTRAINT PK_PLACES PRIMARY KEY (PLACE_ID);
ALTER TABLE PLACETYPES ADD CONSTRAINT PK_PLACETYPES PRIMARY KEY (PLACETYPE_CODE);
ALTER TABLE PLUGINS ADD CONSTRAINT PK_PLUGINS PRIMARY KEY (PLUGIN_ID);
ALTER TABLE PLUGIN_PARAMS ADD CONSTRAINT PK_PLUGIN_PARAMS PRIMARY KEY (PLUGIN_ID, PARAM_SIGN);
ALTER TABLE PORT2TEMPLATE ADD CONSTRAINT PK_PORT2TEMPLATE PRIMARY KEY (PORT_ID, TEMPLATE_ID);
ALTER TABLE PORTS ADD CONSTRAINT PK_PORTS PRIMARY KEY (PORT_ID);
ALTER TABLE PRODUCTS ADD CONSTRAINT PK_PRODUCTS PRIMARY KEY (PRODUCT_ID);
ALTER TABLE PRODUCT_ATTRS ADD CONSTRAINT PK_PRODUCT_ATTRS PRIMARY KEY (OBJECT_ID, ATTR_ID);
ALTER TABLE RECODES ADD CONSTRAINT PK_RECODES PRIMARY KEY (OBJECT_SIGN, ATTR_SIGN, ORIGINAL_VALUE);
ALTER TABLE SESSIONS ADD CONSTRAINT PK_SESSIONS PRIMARY KEY (SESSION_ID);
ALTER TABLE SETTINGS ADD CONSTRAINT PK_SETTINGS PRIMARY KEY (SETTING_ID);
ALTER TABLE SETTINGSIGNS ADD CONSTRAINT PK_SETTINGSIGNS PRIMARY KEY (SETTING_SIGN);
ALTER TABLE STATUSES ADD CONSTRAINT PK_STATUSES PRIMARY KEY (STATUS_ID);
ALTER TABLE STATUS_RULES ADD CONSTRAINT PK_STATUS_RULES PRIMARY KEY (OLD_STATUS_ID, NEW_STATUS_ID);
ALTER TABLE STREETTYPES ADD CONSTRAINT PK_STREETTYPES PRIMARY KEY (STREETTYPE_CODE);
ALTER TABLE TAXPLANS ADD CONSTRAINT PK_TAXPLANS PRIMARY KEY (TAXPLAN_ID);
ALTER TABLE TAXRATES ADD CONSTRAINT PK_TAXRATES PRIMARY KEY (TAXRATE_ID);
ALTER TABLE TAXRATE_ATTRS ADD CONSTRAINT PK_TAXRATE_ATTRS PRIMARY KEY (OBJECT_ID, ATTR_ID);
ALTER TABLE TAXSERVS ADD CONSTRAINT PK_TAXSERVS PRIMARY KEY (TAXSERV_ID);
ALTER TABLE TEMPLATES ADD CONSTRAINT PK_TEMPLATES PRIMARY KEY (TEMPLATE_ID);
ALTER TABLE USERS ADD CONSTRAINT PK_USERS PRIMARY KEY (USER_SIGN);
ALTER TABLE VALUTES ADD CONSTRAINT PK_VALUTES PRIMARY KEY (VALUTE_CODE);
ALTER TABLE VENDORS ADD CONSTRAINT PK_VENDORS PRIMARY KEY (VENDOR_ID);


/******************************************************************************/
/***                              Foreign Keys                              ***/
/******************************************************************************/

ALTER TABLE ACCOPERS ADD CONSTRAINT FK_ACCOPERS_ACCOUNT FOREIGN KEY (ACCOUNT_ID) REFERENCES ACCOUNTS (ACCOUNT_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE ACCOPERS ADD CONSTRAINT FK_ACCOPERS_ORDER FOREIGN KEY (ORDER_ID) REFERENCES ORDERS (ORDER_ID) ON UPDATE CASCADE;
ALTER TABLE ACCOPERS ADD CONSTRAINT FK_ACCOPERS_ORDERMONEY FOREIGN KEY (ORDERMONEY_ID) REFERENCES ORDERMONEYS (ORDERMONEY_ID) ON UPDATE CASCADE;
ALTER TABLE ACCOUNTS ADD CONSTRAINT FK_ACCOUNTS_STATUS FOREIGN KEY (STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE CASCADE;
ALTER TABLE ACTIONCODES ADD CONSTRAINT FK_ACTIONCODES_OBJECT FOREIGN KEY (OBJECT_SIGN) REFERENCES OBJECTS (OBJECT_SIGN) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE ACTIONCODE_CRITERIAS ADD CONSTRAINT FK_ACTIONCODE_CRITERIAS_ACTION FOREIGN KEY (ACTIONCODE_SIGN) REFERENCES ACTIONCODES (ACTION_SIGN) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE ACTIONCODE_CRITERIAS ADD CONSTRAINT FK_ACTIONCODE_CRITERIAS_PRMACT FOREIGN KEY (PARAM_KIND, PARAM_ACTION) REFERENCES PARAMACTIONS (PARAM_KIND, PARAM_ACTION) ON UPDATE CASCADE;
ALTER TABLE ACTIONCODE_PARAMS ADD CONSTRAINT FK_ACTIONCODE_PARAMS_ACTION FOREIGN KEY (ACTION_SIGN) REFERENCES ACTIONCODES (ACTION_SIGN) ON DELETE CASCADE ON UPDATE CASCADE
  USING INDEX FK_ACTIONCODE_PARAMS_1;
ALTER TABLE ACTIONCODE_PARAMS ADD CONSTRAINT FK_ACTIONCODE_PARAMS_PARAMKIND FOREIGN KEY (PARAM_KIND) REFERENCES PARAMKINDS (PARAM_KIND) ON UPDATE CASCADE;
ALTER TABLE ACTIONS ADD CONSTRAINT FK_ACTIONS_ACTIONCODE FOREIGN KEY (ACTION_SIGN) REFERENCES ACTIONCODES (ACTION_SIGN) ON UPDATE CASCADE;
ALTER TABLE ACTIONTREE ADD CONSTRAINT FK_ACTIONTREE_ACTION FOREIGN KEY (ACTION_SIGN) REFERENCES ACTIONCODES (ACTION_SIGN) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE ACTIONTREE ADD CONSTRAINT FK_ACTIONTREE_CHILD FOREIGN KEY (CHILD_ACTION) REFERENCES ACTIONCODES (ACTION_SIGN) ON UPDATE CASCADE;
ALTER TABLE ACTIONTREE_CRITERIAS ADD CONSTRAINT FK_ACTTREECRIT_ACTTIONTREEITEM FOREIGN KEY (ACTIONTREEITEM_ID) REFERENCES ACTIONTREE (ACTIONTREEITEM_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE ACTIONTREE_CRITERIAS ADD CONSTRAINT FK_ACTTREECRIT_PARAMACTION FOREIGN KEY (PARAM_KIND, PARAM_ACTION) REFERENCES PARAMACTIONS (PARAM_KIND, PARAM_ACTION) ON UPDATE CASCADE;
ALTER TABLE ACTIONTREE_PARAMS ADD CONSTRAINT FK_ACTIONTREE_PARAMS_ACTIONTREE FOREIGN KEY (ACTIONTREEITEM_ID) REFERENCES ACTIONTREE (ACTIONTREEITEM_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE ACTIONTREE_PARAMS ADD CONSTRAINT FK_ACTIONTREE_PARAMS_PARAMKIND FOREIGN KEY (PARAM_KIND) REFERENCES PARAMKINDS (PARAM_KIND) ON UPDATE CASCADE;
ALTER TABLE ACTION_ATTRS ADD CONSTRAINT FK_ACTION_ATTRS_ACTION FOREIGN KEY (OBJECT_ID) REFERENCES ACTIONS (ACTION_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE ACTION_ATTRS ADD CONSTRAINT FK_ACTION_ATTRS_ATTR FOREIGN KEY (ATTR_ID) REFERENCES ATTRS (ATTR_ID) ON UPDATE CASCADE;
ALTER TABLE ADRESSES ADD CONSTRAINT FK_ADRESSES_CLIENT FOREIGN KEY (CLIENT_ID) REFERENCES CLIENTS (CLIENT_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE ADRESSES ADD CONSTRAINT FK_ADRESSES_PLACE FOREIGN KEY (PLACE_ID) REFERENCES PLACES (PLACE_ID) ON UPDATE CASCADE;
ALTER TABLE ADRESSES ADD CONSTRAINT FK_ADRESSES_STATUS FOREIGN KEY (STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE CASCADE;
ALTER TABLE ADRESSES ADD CONSTRAINT FK_ADRESSES_STREETTYPE FOREIGN KEY (STREETTYPE_CODE) REFERENCES STREETTYPES (STREETTYPE_CODE) ON UPDATE CASCADE;
ALTER TABLE ARTICLECODES ADD CONSTRAINT FK_ARTICLECODES_ARTICLESIGN FOREIGN KEY (ARTICLESIGN_ID) REFERENCES ARTICLESIGNS (ARTICLESIGN_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE ARTICLECODES ADD CONSTRAINT FK_ARTICLECODES_MAGAZINE FOREIGN KEY (MAGAZINE_ID) REFERENCES MAGAZINES (MAGAZINE_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE ARTICLECODES ADD CONSTRAINT FK_ARTICLECODES_STATUS FOREIGN KEY (STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE CASCADE;
ALTER TABLE ARTICLECODE_ATTRS ADD CONSTRAINT FK_ARTCODE_ATTRS_ARTICLECODE FOREIGN KEY (OBJECT_ID) REFERENCES ARTICLECODES (ARTICLECODE_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE ARTICLECODE_ATTRS ADD CONSTRAINT FK_ARTICLECODE_ATTRS_ATTR FOREIGN KEY (ATTR_ID) REFERENCES ATTRS (ATTR_ID) ON UPDATE CASCADE;
ALTER TABLE ARTICLEMASKS ADD CONSTRAINT FK_ARTICLEMASKS_CATALOG FOREIGN KEY (CATALOG_ID) REFERENCES CATALOGS (CATALOG_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE ARTICLES ADD CONSTRAINT FK_ARTICLES_ARTICLECODE FOREIGN KEY (ARTICLECODE_ID) REFERENCES ARTICLECODES (ARTICLECODE_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE ARTICLES ADD CONSTRAINT FK_ARTICLES_STATUS FOREIGN KEY (STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE CASCADE;
ALTER TABLE ARTICLESIGNS ADD CONSTRAINT FK_ARTICLESIGNS_STATUS FOREIGN KEY (STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE CASCADE;
ALTER TABLE ARTICLE_ATTRS ADD CONSTRAINT FK_ARTICLE_ATTRS_ARTICLE FOREIGN KEY (OBJECT_ID) REFERENCES ARTICLES (ARTICLE_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE ARTICLE_ATTRS ADD CONSTRAINT FK_ARTICLE_ATTRS_ATTR FOREIGN KEY (ATTR_ID) REFERENCES ATTRS (ATTR_ID) ON UPDATE CASCADE;
ALTER TABLE ATTRS ADD CONSTRAINT FK_ATTRS_OBJECT FOREIGN KEY (OBJECT_SIGN) REFERENCES OBJECTS (OBJECT_SIGN) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE CALCPOINTS ADD CONSTRAINT FK_CALCPOINTS_OBJECT FOREIGN KEY (OBJECT_SIGN) REFERENCES OBJECTS (OBJECT_SIGN) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE CALCPOINTS ADD CONSTRAINT FK_CALCPOINTS_OBJECTSTATUS FOREIGN KEY (OBJECT_STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE CASCADE;
ALTER TABLE CATALOG2PLUGIN ADD CONSTRAINT FK_CATALOG2PLUGIN_CATALOG FOREIGN KEY (CATALOG_ID) REFERENCES CATALOGS (CATALOG_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE CATALOG2PLUGIN ADD CONSTRAINT FK_CATALOG2PLUGIN_PLUGIN FOREIGN KEY (PLUGIN_ID) REFERENCES PLUGINS (PLUGIN_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE CATALOGS ADD CONSTRAINT FK_CATALOGS_STATUS FOREIGN KEY (STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE CASCADE;
ALTER TABLE CATALOGS ADD CONSTRAINT FK_CATALOGS_VENDOR FOREIGN KEY (VENDOR_ID) REFERENCES VENDORS (VENDOR_ID) ON UPDATE CASCADE;
ALTER TABLE CLIENTS ADD CONSTRAINT FK_CLIENTS_ACCOUNT FOREIGN KEY (ACCOUNT_ID) REFERENCES ACCOUNTS (ACCOUNT_ID) ON UPDATE CASCADE;
ALTER TABLE CLIENTS ADD CONSTRAINT FK_CLIENTS_STATUS FOREIGN KEY (STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE CASCADE;
ALTER TABLE CLIENT_ATTRS ADD CONSTRAINT FK_CLIENT_ATTRS_ATTR FOREIGN KEY (ATTR_ID) REFERENCES ATTRS (ATTR_ID) ON UPDATE CASCADE;
ALTER TABLE CLIENT_ATTRS ADD CONSTRAINT FK_CLIENT_ATTRS_OBJECT FOREIGN KEY (OBJECT_ID) REFERENCES CLIENTS (CLIENT_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE COUNTERS ADD CONSTRAINT FK_COUNTERS_OBJECT FOREIGN KEY (OBJECT_SIGN) REFERENCES OBJECTS (OBJECT_SIGN) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE EVENTCODES ADD CONSTRAINT FK_EVENTCODES_OBJECT FOREIGN KEY (OBJECT_SIGN) REFERENCES OBJECTS (OBJECT_SIGN) ON UPDATE CASCADE;
ALTER TABLE EVENTS ADD CONSTRAINT FK_EVENTS_EVENT FOREIGN KEY (EVENT_SIGN) REFERENCES EVENTCODES (EVENT_SIGN) ON UPDATE CASCADE;
ALTER TABLE EVENTS ADD CONSTRAINT FK_EVENTS_STATUS FOREIGN KEY (STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE CASCADE;
ALTER TABLE FLAGS2STATUSES ADD CONSTRAINT FK_FLAGS2STATUSES_FLAG FOREIGN KEY (FLAG_SIGN) REFERENCES FLAGS (FLAG_SIGN) ON UPDATE CASCADE;
ALTER TABLE FLAGS2STATUSES ADD CONSTRAINT FK_FLAGS2STATUSES_STATUS FOREIGN KEY (STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE MAGAZINES ADD CONSTRAINT FK_MAGAZINES_CATALOG FOREIGN KEY (CATALOG_ID) REFERENCES CATALOGS (CATALOG_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE MESSAGES ADD CONSTRAINT FK_MESSAGES_PORT FOREIGN KEY (PORT_ID) REFERENCES PORTS (PORT_ID) ON UPDATE CASCADE;
ALTER TABLE MESSAGES ADD CONSTRAINT FK_MESSAGES_STATUS FOREIGN KEY (STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE CASCADE;
ALTER TABLE MESSAGES ADD CONSTRAINT FK_MESSAGES_TEMPLATE FOREIGN KEY (TEMPLATE_ID) REFERENCES TEMPLATES (TEMPLATE_ID) ON UPDATE CASCADE;
ALTER TABLE MESSAGE_ATTRS ADD CONSTRAINT FK_MESSAGE_ATTRS_ATTR FOREIGN KEY (ATTR_ID) REFERENCES ATTRS (ATTR_ID) ON UPDATE CASCADE;
ALTER TABLE MESSAGE_ATTRS ADD CONSTRAINT FK_MESSAGE_ATTRS_MESSAGE FOREIGN KEY (OBJECT_ID) REFERENCES MESSAGES (MESSAGE_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE NOTIFIES ADD CONSTRAINT FK_NOTIFIES_MESSAGE FOREIGN KEY (MESSAGE_ID) REFERENCES MESSAGES (MESSAGE_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE ORDERHISTORY ADD CONSTRAINT FK_ORDERHISTORY_ORDER FOREIGN KEY (ORDER_ID) REFERENCES ORDERS (ORDER_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE ORDERHISTORY ADD CONSTRAINT FK_ORDERHISTORY_STATE FOREIGN KEY (STATE_ID) REFERENCES STATUSES (STATUS_ID) ON DELETE SET NULL ON UPDATE CASCADE;
ALTER TABLE ORDERHISTORY ADD CONSTRAINT FK_ORDERHISTORY_STATUS FOREIGN KEY (STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE ORDERITEMS ADD CONSTRAINT FK_ORDERITEMS_ORDER FOREIGN KEY (ORDER_ID) REFERENCES ORDERS (ORDER_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE ORDERITEMS ADD CONSTRAINT FK_ORDERITEMS_STATUS FOREIGN KEY (STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE CASCADE;
ALTER TABLE ORDERITEM_ATTRS ADD CONSTRAINT FK_ORDERITEM_ATTRS_ATTR FOREIGN KEY (ATTR_ID) REFERENCES ATTRS (ATTR_ID) ON UPDATE CASCADE;
ALTER TABLE ORDERITEM_ATTRS ADD CONSTRAINT FK_ORDERITEM_ATTRS_OBJECT FOREIGN KEY (OBJECT_ID) REFERENCES ORDERITEMS (ORDERITEM_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE ORDERMONEYS ADD CONSTRAINT FK_ORDERMONEYS_ACCOUNT FOREIGN KEY (ACCOUNT_ID) REFERENCES ACCOUNTS (ACCOUNT_ID) ON UPDATE CASCADE;
ALTER TABLE ORDERMONEYS ADD CONSTRAINT FK_ORDERMONEYS_ORDER FOREIGN KEY (ORDER_ID) REFERENCES ORDERS (ORDER_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE ORDERMONEYS ADD CONSTRAINT FK_ORDERMONEYS_STATUS FOREIGN KEY (STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE CASCADE;
ALTER TABLE ORDERS ADD CONSTRAINT FK_ORDERS_ACCOUNT FOREIGN KEY (ACCOUNT_ID) REFERENCES ACCOUNTS (ACCOUNT_ID) ON UPDATE CASCADE;
ALTER TABLE ORDERS ADD CONSTRAINT FK_ORDERS_ADRESS FOREIGN KEY (ADRESS_ID) REFERENCES ADRESSES (ADRESS_ID) ON UPDATE CASCADE;
ALTER TABLE ORDERS ADD CONSTRAINT FK_ORDERS_CLIENT FOREIGN KEY (CLIENT_ID) REFERENCES CLIENTS (CLIENT_ID) ON UPDATE CASCADE;
ALTER TABLE ORDERS ADD CONSTRAINT FK_ORDERS_PRODUCT FOREIGN KEY (PRODUCT_ID) REFERENCES PRODUCTS (PRODUCT_ID) ON UPDATE CASCADE;
ALTER TABLE ORDERS ADD CONSTRAINT FK_ORDERS_STATE FOREIGN KEY (STATE_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE CASCADE;
ALTER TABLE ORDERS ADD CONSTRAINT FK_ORDERS_STATUS FOREIGN KEY (STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE CASCADE;
ALTER TABLE ORDERS ADD CONSTRAINT FK_ORDERS_TAXPLAN FOREIGN KEY (TAXPLAN_ID) REFERENCES TAXPLANS (TAXPLAN_ID) ON UPDATE CASCADE;
ALTER TABLE ORDERTAXS ADD CONSTRAINT FK_ORDERTAXS_ORDER FOREIGN KEY (ORDER_ID) REFERENCES ORDERS (ORDER_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE ORDERTAXS ADD CONSTRAINT FK_ORDERTAXS_STATUS FOREIGN KEY (STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE CASCADE;
ALTER TABLE ORDERTAXS ADD CONSTRAINT FK_ORDERTAXS_TAXRATE FOREIGN KEY (TAXRATE_ID) REFERENCES TAXRATES (TAXRATE_ID) ON UPDATE CASCADE;
ALTER TABLE ORDER_ATTRS ADD CONSTRAINT FK_ORDER_ATTRS_ATTR FOREIGN KEY (ATTR_ID) REFERENCES ATTRS (ATTR_ID) ON UPDATE CASCADE;
ALTER TABLE ORDER_ATTRS ADD CONSTRAINT FK_ORDER_ATTRS_OBJECT FOREIGN KEY (OBJECT_ID) REFERENCES ORDERS (ORDER_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE PARAMHEADS ADD CONSTRAINT FK_PARAMHEADS_ACTION FOREIGN KEY (ACTION_ID) REFERENCES ACTIONS (ACTION_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE PARAMHEADS ADD CONSTRAINT FK_PARAMHEADS_OBJECT FOREIGN KEY (OBJECT_SIGN) REFERENCES OBJECTS (OBJECT_SIGN) ON UPDATE CASCADE;
ALTER TABLE PARAMS ADD CONSTRAINT FK_PARAMS_PARAM FOREIGN KEY (PARAM_ID) REFERENCES PARAMHEADS (PARAM_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE PAYMENTS ADD CONSTRAINT FK_PAYMENTS_MESSAGE FOREIGN KEY (MESSAGE_ID) REFERENCES MESSAGES (MESSAGE_ID) ON UPDATE CASCADE;
ALTER TABLE PAYMENTS ADD CONSTRAINT FK_PAYMENTS_STATUS FOREIGN KEY (STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE CASCADE;
ALTER TABLE PLACES ADD CONSTRAINT FK_PLACES_OWNER FOREIGN KEY (OWNER_PLACE) REFERENCES PLACES (PLACE_ID) ON UPDATE CASCADE;
ALTER TABLE PLACES ADD CONSTRAINT FK_PLACES_PLACETYPE FOREIGN KEY (PLACETYPE_CODE) REFERENCES PLACETYPES (PLACETYPE_CODE) ON UPDATE CASCADE;
ALTER TABLE PLACES ADD CONSTRAINT FK_PLACES_STATUS FOREIGN KEY (STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE CASCADE;
ALTER TABLE PLUGIN_PARAMS ADD CONSTRAINT FK_PLUGIN_PARAMS_PLUGIN FOREIGN KEY (PLUGIN_ID) REFERENCES PLUGINS (PLUGIN_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE PRODUCTS ADD CONSTRAINT FK_PRODUCTS_STATUS FOREIGN KEY (STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE CASCADE;
ALTER TABLE PRODUCTS ADD CONSTRAINT FK_PRODUCTS_VENDOR FOREIGN KEY (VENDOR_ID) REFERENCES VENDORS (VENDOR_ID) ON UPDATE CASCADE;
ALTER TABLE PRODUCT_ATTRS ADD CONSTRAINT FK_PRODUCT_ATTRS_ATTR FOREIGN KEY (ATTR_ID) REFERENCES ATTRS (ATTR_ID) ON UPDATE CASCADE;
ALTER TABLE PRODUCT_ATTRS ADD CONSTRAINT FK_PRODUCT_ATTRS_PRODUCT FOREIGN KEY (OBJECT_ID) REFERENCES PRODUCTS (PRODUCT_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE RECODES ADD CONSTRAINT FK_RECODES_OBJECT FOREIGN KEY (OBJECT_SIGN) REFERENCES OBJECTS (OBJECT_SIGN) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE SETTINGS ADD CONSTRAINT FK_SETTINGS_SETTINGSIGN FOREIGN KEY (SETTING_SIGN) REFERENCES SETTINGSIGNS (SETTING_SIGN) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE STATUSES ADD CONSTRAINT FK_STATUSES_ACTION FOREIGN KEY (ACTION_SIGN) REFERENCES ACTIONCODES (ACTION_SIGN) ON UPDATE CASCADE;
ALTER TABLE STATUSES ADD CONSTRAINT FK_STATUSES_OBJECT FOREIGN KEY (OBJECT_SIGN) REFERENCES OBJECTS (OBJECT_SIGN) ON UPDATE CASCADE;
ALTER TABLE STATUS_RULES ADD CONSTRAINT FK_STATUS_RULES_ACTIONCODE FOREIGN KEY (ACTION_SIGN) REFERENCES ACTIONCODES (ACTION_SIGN) ON DELETE SET NULL ON UPDATE CASCADE;
ALTER TABLE STATUS_RULES ADD CONSTRAINT FK_STATUS_RULES_NEWSTATUS FOREIGN KEY (NEW_STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE CASCADE;
ALTER TABLE STATUS_RULES ADD CONSTRAINT FK_STATUS_RULES_OLDSTATUS FOREIGN KEY (OLD_STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE TAXPLANS ADD CONSTRAINT FK_TAXPLANS_STATUS FOREIGN KEY (STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE CASCADE;
ALTER TABLE TAXRATES ADD CONSTRAINT FK_TAXRATES_TAXPLAN FOREIGN KEY (TAXPLAN_ID) REFERENCES TAXPLANS (TAXPLAN_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE TAXRATES ADD CONSTRAINT FK_TAXRATES_TAXSERV FOREIGN KEY (TAXSERV_ID) REFERENCES TAXSERVS (TAXSERV_ID) ON DELETE CASCADE ON UPDATE CASCADE
  USING INDEX FK_TAXRATES_SERVS;
ALTER TABLE TAXRATE_ATTRS ADD CONSTRAINT FK_TAXRATE_ATTRS_ATTR FOREIGN KEY (ATTR_ID) REFERENCES ATTRS (ATTR_ID) ON UPDATE CASCADE;
ALTER TABLE TAXRATE_ATTRS ADD CONSTRAINT FK_TAXRATE_ATTRS_TAXRATE FOREIGN KEY (OBJECT_ID) REFERENCES TAXRATES (TAXRATE_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE TAXSERVS ADD CONSTRAINT FK_TAXSERVS_CALCPOINT FOREIGN KEY (CALCPOINT_ID) REFERENCES CALCPOINTS (CALCPOINT_ID) ON UPDATE CASCADE;
ALTER TABLE TAXSERVS ADD CONSTRAINT FK_TAXSERVS_STATUS FOREIGN KEY (STATUS_ID) REFERENCES STATUSES (STATUS_ID) ON UPDATE CASCADE;


/******************************************************************************/
/***                                Indices                                 ***/
/******************************************************************************/

CREATE INDEX ARTICLECODES_IDX1 ON ARTICLECODES (ARTICLE_SIGN);
CREATE INDEX SEARCHES_IDX1 ON SEARCHES (SEARCH_ID, OBJECT_ID);
CREATE INDEX IDX_TMP_SEARCHES_1 ON TMP_SEARCHES (SEARCH_ID, OBJECT_ID);


/******************************************************************************/
/***                                Triggers                                ***/
/******************************************************************************/


SET TERM ^ ;



/******************************************************************************/
/***                        Database event triggers                         ***/
/******************************************************************************/



/* Trigger: CLOSE_SESSION */
CREATE OR ALTER TRIGGER CLOSE_SESSION
ACTIVE ON DISCONNECT POSITION 0
AS
  declare variable v_field_name rdb$field_name;
  declare variable v_table_name rdb$relation_name;
  declare variable v_sql sql_statement;
begin
--  in autonomous transaction do
  update sessions s
    set s.finish_dtm = current_timestamp
    where s.session_id = current_connection;

  update messages m
    set busy_id = null
    where busy_id = current_connection;

  delete from sessions s
    where s.session_id = current_connection;

end
^

/* Trigger: REGISTER_SESSION */
CREATE OR ALTER TRIGGER REGISTER_SESSION
INACTIVE ON CONNECT POSITION 0
AS
begin
  delete from sessions where session_id >= current_connection;

  insert into sessions(session_id, user_name, start_dtm, finish_dtm)
    values(current_connection, current_user, current_timestamp, null);
end
^

/******************************************************************************/
/***                          Triggers for tables                           ***/
/******************************************************************************/



/* Trigger: ACCOPERS_AI0 */
CREATE OR ALTER TRIGGER ACCOPERS_AI0 FOR ACCOPERS
ACTIVE AFTER INSERT POSITION 0
AS
begin
  update accounts a
    set a.rest_eur = a.rest_eur + new.amount_eur, a.rest_date = current_timestamp
    where a.account_id = new.account_id;
end
^

/* Trigger: ACCOPERS_BI */
CREATE OR ALTER TRIGGER ACCOPERS_BI FOR ACCOPERS
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.accoper_id is null) then
    new.accoper_id = gen_id(seq_accoper_id,1);
  new.accoper_dtm = current_timestamp;
end
^

/* Trigger: ACCOUNTS_BI0 */
CREATE OR ALTER TRIGGER ACCOUNTS_BI0 FOR ACCOUNTS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.account_id is null) then
    new.account_id = gen_id(seq_account_id, 1);
  if (new.status_id is null) then
    select o_status_id from status_get_default('ACCOUNT') into new.status_id;
  if (new.rest_eur is null) then
  begin
    new.rest_eur = 0;
    new.rest_date = current_timestamp;
  end
end
^

/* Trigger: ACCOUNTS_BU0 */
CREATE OR ALTER TRIGGER ACCOUNTS_BU0 FOR ACCOUNTS
ACTIVE BEFORE UPDATE POSITION 0
AS
begin
  new.rest_date = current_timestamp;
end
^

/* Trigger: ACTIONCODES_BIU0 */
CREATE OR ALTER TRIGGER ACTIONCODES_BIU0 FOR ACTIONCODES
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
  if (new.procedure_name is not null) then
  begin
    if (not exists(select rdb$procedure_id
      from rdb$procedures
      where rdb$procedure_name = upper('ACT_'||new.procedure_name))) then
    exception ex_procedure_not_found 'Procedure ACT_'||new.procedure_name||' not found';
  end
end
^

/* Trigger: ACTIONS_BI0 */
CREATE OR ALTER TRIGGER ACTIONS_BI0 FOR ACTIONS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  new.user_sign = user;
end
^

/* Trigger: ACTIONTREE_BI0 */
CREATE OR ALTER TRIGGER ACTIONTREE_BI0 FOR ACTIONTREE
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.actiontreeitem_id is null) then
    new.actiontreeitem_id = gen_id(seq_actiontreeitem_id, 1);
end
^

/* Trigger: ADRESSES_BI0 */
CREATE OR ALTER TRIGGER ADRESSES_BI0 FOR ADRESSES
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.adress_id is null) then
    new.adress_id = gen_id(seq_adress_id, 1);
  if (new.status_id is null) then
    select o_status_id from status_get_default('ADRESS') into new.status_id;
  new.status_dtm = current_timestamp;
end
^

/* Trigger: ADRESSES_BU0 */
CREATE OR ALTER TRIGGER ADRESSES_BU0 FOR ADRESSES
ACTIVE BEFORE UPDATE POSITION 0
AS
begin
  if (new.status_id <> old.status_id) then
    new.status_dtm = current_timestamp;
end
^

/* Trigger: ARTICLECODES_BI0 */
CREATE OR ALTER TRIGGER ARTICLECODES_BI0 FOR ARTICLECODES
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.articlecode_id is null) then
    new.articlecode_id = gen_id(seq_articlecode_id, 1);
  if (new.status_id is null) then
    select o_status_id from status_get_default('ARTICLECODE') into new.status_id;
  if (new.status_id is null) then
    exception ex_default_status_undefined 'Undefined default status for ARTICLECODE';

  if (new.article_sign is null) then
    select recode(new.article_code, am.article_sign_mask)
      from articlemasks am
        inner join magazines m on (m.catalog_id = am.catalog_id and m.magazine_id = new.magazine_id)
      where new.article_code similar to am.article_code_mask
      into new.article_sign;
end
^

/* Trigger: ARTICLESIGNS_BI0 */
CREATE OR ALTER TRIGGER ARTICLESIGNS_BI0 FOR ARTICLESIGNS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.articlesign_id is null) then
    new.articlesign_id = gen_id(seq_articlesign_id, 1);
  if (new.status_id is null) then
  begin
    select o_status_id from status_get_default('ARTICLESIGN') into new.status_id;
    if (new.status_id is null) then
      exception ex_default_status_undefined 'Undefined default status for ARTICLESIGN';
  end
end
^

/* Trigger: ARTICLES_BI0 */
CREATE OR ALTER TRIGGER ARTICLES_BI0 FOR ARTICLES
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  new.article_id = gen_id(seq_article_id, 1);
  select o_status_id from status_get_default('ARTICLE') into new.status_id;
  if (new.status_id is null) then
    exception ex_default_status_undefined 'Undefined default status for ARTICLE';
  new.status_dtm = current_timestamp;
end
^

/* Trigger: ARTICLES_BU0 */
CREATE OR ALTER TRIGGER ARTICLES_BU0 FOR ARTICLES
ACTIVE BEFORE UPDATE POSITION 0
AS
begin
  if (old.status_id <> new.status_id) then
    new.status_dtm = current_timestamp;
end
^

/* Trigger: ATTRS_BIU0 */
CREATE OR ALTER TRIGGER ATTRS_BIU0 FOR ATTRS
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
  if (new.field_name is not null) then
  begin
    if (not exists(select *
                 from objects o
                   inner join rdb$relation_fields r on (r.rdb$relation_name = o.table_name)
                 where r.rdb$field_name = new.field_name)) then
      exception ex_unknown_fieldname;
  end
end
^

/* Trigger: BUILDS_BI0 */
CREATE OR ALTER TRIGGER BUILDS_BI0 FOR BUILDS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  new.install_dtm = current_timestamp;
end
^

/* Trigger: CALCPOINTS_BI0 */
CREATE OR ALTER TRIGGER CALCPOINTS_BI0 FOR CALCPOINTS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.calcpoint_id is null) then
    new.calcpoint_id = gen_id(seq_calcpoint_id, 1);
  if (not exists (select *
                from statuses s
                where s.status_id = new.object_status_id
                  and s.object_sign = new.object_sign)) then
    exception ex_wrong_object_status_id;
end
^

/* Trigger: CLIENTS_BI0 */
CREATE OR ALTER TRIGGER CLIENTS_BI0 FOR CLIENTS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.client_id is null) then
    new.client_id = gen_id(seq_client_id, 1);
  if (new.status_id is null) then
    select o_status_id from status_get_default('CLIENT') into new.status_id;
end
^

/* Trigger: COUNTERS_BU0 */
CREATE OR ALTER TRIGGER COUNTERS_BU0 FOR COUNTERS
ACTIVE BEFORE UPDATE POSITION 0
AS
begin
  new.curr_value = old.curr_value + 1;
  if (new.curr_value not between new.min_value and new.max_value) then
    new.curr_value = new.min_value;
end
^

/* Trigger: EVENTS_BI */
CREATE OR ALTER TRIGGER EVENTS_BI FOR EVENTS
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.event_id is null) then
    new.event_id = gen_id(seq_event_id,1);
  if (new.status_id is null) then
    select o_status_id from status_get_default('EVENT') into new.status_id;
  new.status_dtm = current_timestamp;
end
^

/* Trigger: EVENTS_BU0 */
CREATE OR ALTER TRIGGER EVENTS_BU0 FOR EVENTS
ACTIVE BEFORE UPDATE POSITION 0
AS
begin
  if (old.status_id <> new.status_id) then
    new.status_dtm = current_timestamp;
end
^

/* Trigger: FLAGS2STATUSES_AIUD0 */
CREATE OR ALTER TRIGGER FLAGS2STATUSES_AIUD0 FOR FLAGS2STATUSES
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 0
AS
begin
  merge into statuses s
    using (select status_id, ','||list(flag_sign)||',' as flag_sign_list
             from flags2statuses
--             where status_id = old.status_id
             group by status_id) f2s
    on (s.status_id = f2s.status_id)
    when matched then
      update set s.flag_sign_list = f2s.flag_sign_list;
end
^

/* Trigger: LOGS_BI0 */
CREATE OR ALTER TRIGGER LOGS_BI0 FOR LOGS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.log_id is null) then
    new.log_id = gen_id(seq_log_id, 1);
end
^

/* Trigger: MAGAZINES_BI0 */
CREATE OR ALTER TRIGGER MAGAZINES_BI0 FOR MAGAZINES
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.magazine_id is null) then
    new.magazine_id = gen_id(seq_magazine_id, 1);

  if (new.status_id is null) then
    select o_status_id from status_get_default('MAGAZINE') into new.status_id;

  if (new.magazine_name is null) then
    select trim(c.catalog_name)||' до '||new.valid_date
      from catalogs c
      where c.catalog_id = new.catalog_id
    into new.magazine_name;
end
^

/* Trigger: MESSAGES_BI0 */
CREATE OR ALTER TRIGGER MESSAGES_BI0 FOR MESSAGES
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.message_id is null) then
    new.message_id = gen_id(seq_message_id, 1);
  if (new.status_id is null) then
    select o_status_id from status_get_default('MESSAGE') into new.status_id;
end
^

/* Trigger: NOTIFIES_BI0 */
CREATE OR ALTER TRIGGER NOTIFIES_BI0 FOR NOTIFIES
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  new.notify_id = gen_id(seq_notify_id, 1);
  new.notify_dtm = current_timestamp;
end
^

/* Trigger: OBJECTS_BIU0 */
CREATE OR ALTER TRIGGER OBJECTS_BIU0 FOR OBJECTS
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
  if (new.table_name is not null) then
  begin
    if (not exists (select * from rdb$Relations r where r.rdb$relation_name = new.table_name)) then
      exception ex_unknown_tablename 'Unknown table name '||new.table_name;

  if (not exists (select * from rdb$relation_fields f
                    where f.rdb$field_name = new.idfield_name
                      and f.rdb$relation_name = new.table_name)) then
      exception ex_unknown_fieldname 'Unknown field name '||new.idfield_name;
  end

  if (new.attr_table_name is not null) then
    if (not exists (select * from rdb$Relations r where r.rdb$relation_name = new.attr_table_name)) then
      exception ex_unknown_tablename 'Unknown table name '||new.attr_table_name;

end
^

/* Trigger: ORDERHISTORY_BI0 */
CREATE OR ALTER TRIGGER ORDERHISTORY_BI0 FOR ORDERHISTORY
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  new.action_dtm = current_timestamp;
  new.user_sign = user;
end
^

/* Trigger: ORDERITEMS_BI0 */
CREATE OR ALTER TRIGGER ORDERITEMS_BI0 FOR ORDERITEMS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  new.article_code = upper(new.article_code);
  if (new.orderitem_id is null) then
    new.orderitem_id = gen_id(seq_orderitem_id, 1);
  if (new.status_id is null) then
    select o_status_id from status_get_default('ORDERITEM') into new.status_id;
  new.status_dtm = current_timestamp;

  new.amount = 1;
  new.cost_eur = new.price_eur;
end
^

/* Trigger: ORDERITEMS_BU0 */
CREATE OR ALTER TRIGGER ORDERITEMS_BU0 FOR ORDERITEMS
ACTIVE BEFORE UPDATE POSITION 0
AS
declare variable v_flaglist list_signs;
begin
  new.article_code = upper(new.article_code);
  if (new.status_id <> old.status_id) then
  begin
    new.status_dtm = current_timestamp;
    new.state_id = null;
  end
  if (exists (select *
                from flags2statuses f2s
                where f2s.status_id = new.status_id
                  and f2s.flag_sign = 'CREDIT')) then
    new.amount = 1;
  else
    new.amount = 0;
  new.cost_eur = new.amount * new.price_eur;
end
^

/* Trigger: ORDERMONEYS_BI0 */
CREATE OR ALTER TRIGGER ORDERMONEYS_BI0 FOR ORDERMONEYS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.ordermoney_id is null) then
    new.ordermoney_id = gen_id(seq_ordermoney_id, 1);
  if (new.status_id is null) then
    select o_status_id from status_get_default('ORDERMONEY') into new.status_id;
  new.status_dtm = current_timestamp;
  new.created_dtm = current_timestamp;
end
^

/* Trigger: ORDERS_BI0 */
CREATE OR ALTER TRIGGER ORDERS_BI0 FOR ORDERS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.order_id is null) then
    new.order_id = gen_id(seq_order_id, 1);
  if (new.status_id is null) then
    select o_status_id from status_get_default('ORDER') into new.status_id;
  if (new.create_dtm is null) then
    new.create_dtm = current_timestamp;
  new.status_dtm = current_timestamp;
  new.user_sign = current_user;
end
^

/* Trigger: ORDERS_BU0 */
CREATE OR ALTER TRIGGER ORDERS_BU0 FOR ORDERS
ACTIVE BEFORE UPDATE POSITION 0
AS
begin
  if (old.status_id <> new.status_id) then
  begin
    new.status_dtm = current_timestamp;
    new.state_id = null;
  end
end
^

/* Trigger: ORDERTAXS_BI0 */
CREATE OR ALTER TRIGGER ORDERTAXS_BI0 FOR ORDERTAXS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.ordertax_id is null) then
    new.ordertax_id = gen_id(seq_ordertax_id, 1);

  if (new.status_id is null) then
    select o_status_id from status_get_default('ORDERTAX') into new.status_id;
  new.status_dtm = current_timestamp;

  if (new.price_eur is not null and new.amount is not null) then
    new.cost_eur = new.price_eur * new.amount;

end
^

/* Trigger: ORDERTAXS_BU0 */
CREATE OR ALTER TRIGGER ORDERTAXS_BU0 FOR ORDERTAXS
ACTIVE BEFORE UPDATE POSITION 0
AS
begin
  if (old.status_id <> new.status_id) then
    new.status_dtm = current_timestamp;
  if (not exists (select *
                from flags2statuses f2s
                where f2s.status_id = new.status_id
                  and f2s.flag_sign = 'CREDIT')) then
    new.amount = 0;
  new.cost_eur= new.price_eur * new.amount;
end
^

/* Trigger: PAYMENTS_BI0 */
CREATE OR ALTER TRIGGER PAYMENTS_BI0 FOR PAYMENTS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.payment_id is null) then
    new.payment_id = gen_id(seq_payment_id, 1);
  if (new.status_id is null) then
    select o_status_id from status_get_default('PAYMENT') into new.status_id;
  new.status_dtm = current_timestamp;
end
^

/* Trigger: PLACES_BI0 */
CREATE OR ALTER TRIGGER PLACES_BI0 FOR PLACES
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.status_id is null) then
    select o_status_id from status_get_default('PLACE') into new.status_id;

  if (new.place_id is null) then
    select coalesce(max(p.place_id), new.owner_place*100) + 1 from places p
      where p.owner_place = new.owner_place
      into new.place_id;
end
^

/* Trigger: PLUGINS_BI0 */
CREATE OR ALTER TRIGGER PLUGINS_BI0 FOR PLUGINS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.plugin_id is null) then
    new.plugin_id = gen_id(seq_plugin_id, 1);
end
^

/* Trigger: PRODUCTS_BI0 */
CREATE OR ALTER TRIGGER PRODUCTS_BI0 FOR PRODUCTS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.status_id is null) then
    select o_status_id from status_get_default('PRODUCT') into new.status_id;
  new.status_dtm = current_timestamp;
end
^

/* Trigger: PRODUCTS_BU0 */
CREATE OR ALTER TRIGGER PRODUCTS_BU0 FOR PRODUCTS
ACTIVE BEFORE UPDATE POSITION 0
AS
begin
  if (new.status_id <> old.status_id) then
    new.status_dtm = current_timestamp;
end
^

/* Trigger: SETTINGS_BI0 */
CREATE OR ALTER TRIGGER SETTINGS_BI0 FOR SETTINGS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.setting_id is null) then
    new.setting_id = gen_id(seq_setting_id, 1);
  if (new.valid_dtm is null) then
    new.valid_dtm = '9999.12.31';
end
^

/* Trigger: TAXPLANS_BI0 */
CREATE OR ALTER TRIGGER TAXPLANS_BI0 FOR TAXPLANS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.taxplan_id is null) then
    new.taxplan_id = gen_id(seq_taxplan_id, 1);

  if (new.status_id is null) then
    select o_status_id from status_get_default('TAXPLAN') into new.status_id;
  new.status_dtm = current_timestamp;

end
^

/* Trigger: TAXPLANS_BU0 */
CREATE OR ALTER TRIGGER TAXPLANS_BU0 FOR TAXPLANS
ACTIVE BEFORE UPDATE POSITION 0
AS
begin
  if (new.status_id <> old.status_id) then
    new.status_dtm = current_timestamp;
end
^

/* Trigger: TAXRATES_BI0 */
CREATE OR ALTER TRIGGER TAXRATES_BI0 FOR TAXRATES
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.taxrate_id is null) then
    new.taxrate_id = gen_id(seq_taxrate_id, 1);
  select o_status_id from status_get_default('TAXRATE') into new.status_id;
  if (new.status_id is null) then
    exception ex_default_status_undefined 'Undefined default status for TAXRATE';
end
^

/* Trigger: TAXSERVS_BI0 */
CREATE OR ALTER TRIGGER TAXSERVS_BI0 FOR TAXSERVS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.taxserv_id is null) then
    new.taxserv_id = gen_id(seq_taxserv_id, 1);
  select o_status_id from status_get_default('TAXSERV') into new.status_id;
  if (new.status_id is null) then
    exception ex_default_status_undefined 'Undefined default status for TAXSERV';
end
^

SET TERM ; ^



/******************************************************************************/
/***                           Stored Procedures                            ***/
/******************************************************************************/


SET TERM ^ ;

CREATE OR ALTER PROCEDURE AALL_CLEAR (
    I_CLEAR_ARTICLES SMALLINT)
AS
declare variable V_OBJECT_ID type of ID_OBJECT;
begin

  update accopers ao
    set ao.order_id = null, ao.ordermoney_id = null;

  delete from payments;
  v_object_id = gen_id(seq_payment_id, -(gen_id(seq_payment_id, 0)));

  delete from orders;
  v_object_id = gen_id(seq_order_id, -(gen_id(seq_order_id, 0)));
  v_object_id = gen_id(seq_orderitem_id, -(gen_id(seq_orderitem_id, 0)));
  v_object_id = gen_id(seq_ordertax_id, -(gen_id(seq_ordertax_id, 0)));

  delete from clients;
  v_object_id = gen_id(seq_client_id, -(gen_id(seq_client_id, 0)));
  v_object_id = gen_id(seq_adress_id, -(gen_id(seq_adress_id, 0)));

  delete from accounts;
  v_object_id = gen_id(seq_account_id, -(gen_id(seq_account_id, 0)));
  v_object_id = gen_id(seq_accoper_id, -(gen_id(seq_accoper_id, 0)));


  delete from places where place_id > 1000000;
  v_object_id = gen_id(seq_place_id, -(gen_id(seq_place_id, 0))+1000000);


  delete from messages;
  v_object_id = gen_id(seq_message_id, -(gen_id(seq_message_id, 0)));
  v_object_id = gen_id(seq_notify_id, -(gen_id(seq_notify_id, 0)));

  delete from actions;
  v_object_id = gen_id(seq_action_id, -(gen_id(seq_action_id, 0)));

  delete from paramheads;
  v_object_id = gen_id(seq_param_id, -(gen_id(seq_param_id, 0)));

  delete from logs;
  v_object_id = gen_id(seq_log_id, -(gen_id(seq_log_id, 0)));

  delete from events;
  v_object_id = gen_id(seq_event_id, -(gen_id(seq_event_id, 0)));

  delete from sessions;
  if (i_clear_articles is not null) then
  begin
    delete from magazines where magazine_id > 1;
    v_object_id = gen_id(seq_magazine_id, -(gen_id(seq_magazine_id, 0))+1);

    delete from articlecodes;
    v_object_id = gen_id(seq_article_id, -(gen_id(seq_article_id, 0)));
    v_object_id = gen_id(seq_articlecode_id, -(gen_id(seq_articlecode_id, 0)));
    v_object_id = gen_id(seq_articlesign_id, -(gen_id(seq_articlesign_id, 0)));
  end

end^


CREATE OR ALTER PROCEDURE ACCOUNT_X_SEARCH (
    I_DEST_PARAM_ID TYPE OF ID_PARAM NOT NULL,
    I_PARAM_NAME TYPE OF SIGN_ATTR NOT NULL,
    I_SRC_PARAM_ID TYPE OF ID_PARAM NOT NULL)
AS
declare variable V_ACCOUNT_ID type of ID_ACCOUNT;
declare variable V_OBJECT_ID type of ID_OBJECT;
begin
  if (i_param_name = 'CLIENT_ID') then
  begin
    select o_value from param_get(:i_src_param_id, 'CLIENT_ID') into :v_object_id;
    if (v_object_id is null) then
      exception ex_mandatory_param_expected 'Mandatory param CLIENT_ID expected';
    select c.account_id
      from clients c
      where c.client_id = :v_object_id
      into :v_account_id;
    execute procedure param_set(:i_dest_param_id, 'ID', :v_account_id);
  end
  else
  if (i_param_name = 'ORDER_ID') then
  begin
    select o_value from param_get(:i_src_param_id, 'ORDER_ID') into :v_object_id;
    if (v_object_id is null) then
      exception ex_mandatory_param_expected 'Mandatory param ORDER_ID expected';
    select c.account_id
      from orders o
        inner join clients c on (c.client_id = o.client_id)
      where o.order_id = :v_object_id
      into :v_account_id;
    execute procedure param_set(:i_dest_param_id, 'ID', :v_account_id);
  end

end^


CREATE OR ALTER PROCEDURE ACT_ACCOUNT_CREDIT (
    I_PARAM_ID TYPE OF ID_PARAM,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'ACCOUNT')
AS
declare variable V_AMOUNT_EUR type of MONEY_EUR;
declare variable V_BYR2EUR type of MONEY_BYR;
declare variable V_ORDER_ID type of ID_ORDER;
declare variable V_NOTES type of VALUE_ATTR;
begin
  update paramheads set object_id = :i_object_id where param_id = :i_param_id;

  execute procedure param_set(:i_param_id, 'ID', :i_object_id);

  select o_value from param_get(:i_param_id, 'AMOUNT_EUR') into :v_amount_eur;
  select o_value from param_get(:i_param_id, 'BYR2EUR') into :v_byr2eur;
  select o_value from param_get(:i_param_id, 'ORDER_ID') into :v_order_id;
  select o_value from param_get(:i_param_id, 'NOTES') into :v_notes;

  select o_pattern from param_fillpattern(:i_param_id, :v_notes) into :v_notes;

  insert into accopers (account_id, amount_eur, byr2eur, order_id, notes)
    values(:i_object_id, -:v_amount_eur, :v_byr2eur, :v_order_id, :v_notes);
end^


CREATE OR ALTER PROCEDURE ACT_ACCOUNT_CREDITORDER (
    I_PARAM_ID TYPE OF ID_PARAM,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'ACCOUNT')
AS
declare variable V_AMOUNT_EUR type of MONEY_EUR;
declare variable V_BYR2EUR type of MONEY_BYR;
declare variable V_ORDER_ID type of ID_ORDER;
declare variable V_NOTES type of VALUE_ATTR;
declare variable V_ACC_AMOUNT_EUR type of MONEY_EUR;
declare variable V_ACC_BYR2EUR type of MONEY_BYR;
begin
  update paramheads set object_id = :i_object_id where param_id = :i_param_id;

  execute procedure param_set(:i_param_id, 'ID', :i_object_id);

  select o_value from param_get(:i_param_id, 'AMOUNT_EUR') into :v_amount_eur;
  select o_value from param_get(:i_param_id, 'ORDER_ID') into :v_order_id;

  for select ao.byr2eur, sum(ao.amount_eur)
        from accopers ao
        where ao.account_id = :i_object_id
        group by ao.byr2eur
        having sum(ao.amount_eur) > 0
        into :v_acc_byr2eur, :v_acc_amount_eur do
  begin
    if (v_amount_eur < :v_acc_amount_eur) then
      v_acc_amount_eur = v_amount_eur;
    v_amount_eur = v_amount_eur - v_acc_amount_eur;

    select o_value from param_get(:i_param_id, 'NOTES') into :v_notes;
    select o_pattern from param_fillpattern(:i_param_id, :v_notes) into :v_notes;

    insert into accopers (account_id, amount_eur, byr2eur, order_id, notes)
      values(:i_object_id, -:v_acc_amount_eur, :v_acc_byr2eur, :v_order_id, :v_notes);
    insert into ordermoneys (account_id, amount_eur, byr2eur, order_id)
      values(:i_object_id, :v_acc_amount_eur, :v_acc_byr2eur, :v_order_id);
    if (v_amount_eur = 0) then break;
  end
end^


CREATE OR ALTER PROCEDURE ACT_ACCOUNT_DEBIT (
    I_PARAM_ID TYPE OF ID_PARAM,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'ACCOUNT')
AS
declare variable V_AMOUNT_EUR type of MONEY_EUR;
declare variable V_BYR2EUR type of MONEY_BYR;
declare variable V_ORDER_ID type of ID_ORDER;
declare variable V_NOTES type of VALUE_ATTR;
declare variable V_AMOUNT_BYR type of MONEY_BYR;
begin

  update paramheads set object_id = :i_object_id where param_id = :i_param_id;

  execute procedure param_set(:i_param_id, 'ID', :i_object_id);

  select o_value from param_get(:i_param_id, 'AMOUNT_EUR') into :v_amount_eur;
  select o_value from param_get(:i_param_id, 'BYR2EUR') into :v_byr2eur;
  select o_value from param_get(:i_param_id, 'ORDER_ID') into :v_order_id;
  select o_value from param_get(:i_param_id, 'NOTES') into :v_notes;

  select o_pattern from param_fillpattern(:i_param_id, :v_notes) into :v_notes;

  insert into accopers (account_id, amount_eur, byr2eur, order_id, notes)
    values(:i_object_id, :v_amount_eur, :v_byr2eur, :v_order_id, :v_notes);
end^


CREATE OR ALTER PROCEDURE ACT_ACCOUNT_DEBITORDER (
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL,
    I_OBJECT_ID TYPE OF ID_OBJECT NOT NULL,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'ACCOUNT')
AS
declare variable V_AMOUNT_EUR type of MONEY_EUR;
declare variable V_ORDER_ID type of ID_ORDER;
declare variable V_NOTES type of VALUE_ATTR;
declare variable V_ACC_AMOUNT_EUR type of MONEY_EUR;
declare variable V_ACC_BYR2EUR type of MONEY_BYR;
declare variable V_ORDERITEMS_COST_EUR type of MONEY_EUR;
declare variable V_ORDERTAXS_COST_EUR type of MONEY_EUR;
declare variable V_ORDERMONEYS_COST_EUR type of MONEY_EUR;
begin
  update paramheads set object_id = :i_object_id where param_id = :i_param_id;

  execute procedure param_set(:i_param_id, 'ID', :i_object_id);

  select o_value from param_get(:i_param_id, 'ORDER_ID') into :v_order_id;

  select sum(oi.cost_eur)
    from orderitems oi
    where oi.order_id = :v_order_id
    into :v_orderitems_cost_eur;
  select sum(ot.cost_eur)
    from ordertaxs ot
    where ot.order_id = :v_order_id
    into :v_ordertaxs_cost_eur;
  select sum(om.amount_eur)
    from ordermoneys om
    where om.order_id = :v_order_id
    into :v_ordermoneys_cost_eur;
  v_amount_eur = v_ordermoneys_cost_eur - v_orderitems_cost_eur - v_ordertaxs_cost_eur;

  -- esli pereplata po zayavke
  if (v_amount_eur > 0) then
  begin
    for select om.byr2eur, sum(om.amount_eur)
          from ordermoneys om
          where om.order_id = :v_order_id
          group by om.byr2eur
          having sum(om.amount_eur) > 0
          order by om.byr2eur
          into :v_acc_byr2eur, :v_acc_amount_eur do
    begin
      if (v_amount_eur < v_acc_amount_eur) then
        v_acc_amount_eur = v_amount_eur;
      select o_value from param_get(:i_param_id, 'NOTES') into :v_notes;
      select o_pattern from param_fillpattern(:i_param_id, :v_notes) into :v_notes;

      insert into accopers (account_id, amount_eur, byr2eur, order_id, notes)
        values(:i_object_id, :v_acc_amount_eur, :v_acc_byr2eur, :v_order_id, :v_notes);
      insert into ordermoneys (account_id, amount_eur, byr2eur, order_id)
        values(:i_object_id, -:v_acc_amount_eur, :v_acc_byr2eur, :v_order_id);
    end
  end
  else
  -- esli po zayavke dolg
  if (v_amount_eur < 0) then
  begin
    for select om.byr2eur, sum(om.amount_eur)
          from ordermoneys om
          where om.order_id = :v_order_id
          group by om.byr2eur
          having sum(om.amount_eur) > 0
          order by om.byr2eur desc
          into :v_acc_byr2eur, :v_acc_amount_eur do
    begin
      if (v_amount_eur < v_acc_amount_eur) then
        v_acc_amount_eur = v_amount_eur;

      select o_value from param_get(:i_param_id, 'NOTES') into :v_notes;
      select o_pattern from param_fillpattern(:i_param_id, :v_notes) into :v_notes;

      insert into accopers (account_id, amount_eur, byr2eur, order_id, notes)
        values(:i_object_id, :v_acc_amount_eur, :v_acc_byr2eur, :v_order_id, :v_notes);
      insert into ordermoneys (account_id, amount_eur, byr2eur, order_id)
        values(:i_object_id, -:v_acc_amount_eur, :v_acc_byr2eur, :v_order_id);
    end
  end
end^


CREATE OR ALTER PROCEDURE ACT_ACCOUNT_PAYMENTIN (
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL,
    I_OBJECT_ID TYPE OF ID_OBJECT NOT NULL,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'ACCOUNT')
AS
declare variable V_AMOUNT_EUR type of MONEY_EUR;
declare variable V_BYR2EUR type of MONEY_BYR;
declare variable V_ORDER_ID type of ID_ORDER;
declare variable V_NOTES type of VALUE_ATTR;
declare variable V_AMOUNT_BYR type of MONEY_BYR;
declare variable V_ORDER_CODE type of CODE_ORDER;
begin

  update paramheads set object_id = :i_object_id where param_id = :i_param_id;

  execute procedure param_set(:i_param_id, 'ID', :i_object_id);

  select o_value from param_get(:i_param_id, 'AMOUNT_BYR') into :v_amount_byr;
  select o_value from param_get(:i_param_id, 'ORDER_ID') into :v_order_id;
  select o_value from param_get(:i_param_id, 'NOTES') into :v_notes;

  select o.byr2eur, o.order_code
    from orders o
    where o.order_id = :v_order_id
    into :v_byr2eur, :v_order_code;

  v_amount_eur = round(cast(v_amount_byr as numeric(18,3)) / v_byr2eur, 2);

  execute procedure param_set(:i_param_id, 'ORDER_CODE', :v_order_code);
  execute procedure param_set(:i_param_id, 'BYR2EUR', :v_byr2eur);
  execute procedure param_set(:i_param_id, 'AMOUNT_EUR', :v_amount_eur);

  select o_pattern from param_fillpattern(:i_param_id, :v_notes) into :v_notes;

  insert into accopers (account_id, amount_eur, byr2eur, order_id, notes)
    values(:i_object_id, :v_amount_eur, :v_byr2eur, :v_order_id, :v_notes);
end^


CREATE OR ALTER PROCEDURE ACT_ACCOUNT_STORE (
    I_PARAM_ID TYPE OF ID_PARAM,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'ACCOUNT')
AS
declare variable V_NOW_STATUS_ID type of ID_STATUS;
declare variable V_NEW_STATUS_ID type of ID_STATUS;
declare variable V_REST_EUR type of MONEY_EUR;
declare variable V_UPDATEABLE type of VALUE_BOOLEAN;
begin
  if (coalesce(i_object_id, 0) = 0) then i_object_id = gen_id(seq_account_id, 1);

  update paramheads set object_id = :i_object_id where param_id = :i_param_id;

  execute procedure param_set(:i_param_id, 'ID', :i_object_id);

  select status_id from accounts where account_id = :i_object_id into :v_now_status_id;

  if (:v_now_status_id is null) then
  begin
    v_rest_eur = 0;
    insert into accounts(account_id, rest_eur, status_id)
      values(:i_object_id, :v_rest_eur, :v_new_status_id)
      returning status_id
      into :v_new_status_id;
    v_updateable = 1;
  end
  else
  begin
    select o_updateable, o_new_status_id
      from object_updateable(:i_param_id, :v_now_status_id, :i_object_sign)
      into :v_updateable, :v_new_status_id;
  end

  if (v_updateable = 1) then
  begin
    execute procedure param_set(:i_param_id, 'STATUS_ID', :v_new_status_id);

    execute procedure object_put(:i_param_id);
  end
end^


CREATE OR ALTER PROCEDURE ACT_ADRESS_STORE (
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'ADRESS')
AS
declare variable V_NOW_STATUS_ID type of ID_STATUS;
declare variable V_PLACE_ID type of ID_PLACE;
declare variable V_CLIENT_ID type of ID_CLIENT;
declare variable V_NEW_STATUS_ID type of ID_STATUS;
declare variable V_UPDATEABLE type of VALUE_BOOLEAN;
begin
  if (coalesce(i_object_id, 0) = 0) then i_object_id = gen_id(seq_adress_id, 1);

  update paramheads set object_id = :i_object_id where param_id = :i_param_id;

  execute procedure param_set(:i_param_id, 'ID', :i_object_id);

  select status_id from adresses oi where adress_id = :i_object_id into :v_now_status_id;

  if (:v_now_status_id is null) then
  begin
    select o_value from param_get(:i_param_id, 'CLIENT_ID') into :v_client_id;
    select o_value from param_get(:i_param_id, 'PLACE_ID') into :v_place_id;

    insert into adresses(adress_id, client_id, place_id, status_id)
      values(:i_object_id, :v_client_id, :v_place_id, :v_new_status_id)
      returning status_id
      into :v_new_status_id;
    v_updateable = 1;
  end
  else
  begin
    select o_updateable, o_new_status_id
      from object_updateable(:i_param_id, :v_now_status_id, :i_object_sign)
      into :v_updateable, :v_new_status_id;
  end

  if (v_updateable = 1) then
  begin
    execute procedure param_set(:i_param_id, 'STATUS_ID', :v_new_status_id);
    execute procedure object_put(:i_param_id);
  end
end^


CREATE OR ALTER PROCEDURE ACT_CLIENT_STORE (
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'CLIENT')
AS
declare variable V_NOW_STATUS_ID type of ID_STATUS;
declare variable V_NEW_STATUS_ID type of ID_STATUS;
declare variable V_LAST_NAME type of NAME_REF;
declare variable V_FIRST_NAME type of NAME_REF;
declare variable V_UPDATEABLE type of VALUE_BOOLEAN;
begin
  if (coalesce(i_object_id, 0) = 0) then i_object_id = gen_id(seq_client_id, 1);

  update paramheads set object_id = :i_object_id where param_id = :i_param_id;

  execute procedure param_set(:i_param_id, 'ID', :i_object_id);

  select status_id from clients where client_id = :i_object_id into :v_now_status_id;

  if (:v_now_status_id is null) then
  begin
    select o_value from param_get(:i_param_id, 'LAST_NAME') into :v_last_name;
    select o_value from param_get(:i_param_id, 'FIRST_NAME') into :v_first_name;

    insert into clients(client_id, last_name, first_name, status_id)
      values(:i_object_id, :v_last_name, :v_first_name, :v_new_status_id)
      returning status_id
      into :v_new_status_id;
    v_updateable = 1;
  end
  else
  begin
    select o_updateable, o_new_status_id
      from object_updateable(:i_param_id, :v_now_status_id, :i_object_sign)
      into :v_updateable, :v_new_status_id;
  end

  if (v_updateable = 1) then
  begin
    execute procedure param_set(:i_param_id, 'STATUS_ID', :v_new_status_id);
    execute procedure object_put(:i_param_id);
  end
end^


CREATE OR ALTER PROCEDURE ACT_EVENT_STORE (
    I_PARAM_ID TYPE OF ID_PARAM,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'EVENT')
AS
declare variable V_NOW_STATUS_ID type of ID_STATUS;
declare variable V_NEW_STATUS_ID type of ID_STATUS;
declare variable V_CATALOG_ID type of ID_CATALOG;
declare variable V_VALID_DATE type of DATE_VALID;
declare variable V_UPDATEABLE type of VALUE_BOOLEAN;
declare variable V_EVENT_SIGN type of SIGN_EVENT;
declare variable V_OBJECT_ID type of ID_OBJECT;
begin
  if (coalesce(i_object_id, 0) = 0) then i_object_id = gen_id(seq_event_id, 1);

  update paramheads set object_id = :i_object_id where param_id = :i_param_id;

  execute procedure param_set(:i_param_id, 'ID', :i_object_id);

  select status_id from events where event_id = :i_object_id into :v_now_status_id;

  if (v_now_status_id is null) then
  begin
    select o_value from param_get(:i_param_id, 'EVENT_SIGN') into :v_event_sign;
    select o_value from param_get(:i_param_id, 'OBJECT_ID') into :v_object_id;
    insert into events(event_id, event_sign, object_id, status_id)
      values(:i_object_id, :v_event_sign, :v_object_id, :v_new_status_id)
      returning status_id
      into :v_new_status_id;
    v_updateable = 1;
  end
  else
  begin
    select o_updateable, o_new_status_id
      from object_updateable(:i_param_id, :v_now_status_id, :i_object_sign)
      into :v_updateable, :v_new_status_id;
  end

  if (v_updateable = 1) then
  begin
    execute procedure param_set(:i_param_id, 'STATUS_ID', :v_new_status_id);
    execute procedure object_put(:i_param_id);
  end

end^


CREATE OR ALTER PROCEDURE ACT_MAGAZINE_STORE (
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'MAGAZINE')
AS
declare variable V_NOW_STATUS_ID type of ID_STATUS;
declare variable V_NEW_STATUS_ID type of ID_STATUS;
declare variable V_CATALOG_ID type of ID_CATALOG;
declare variable V_VALID_DATE type of DATE_VALID;
declare variable V_UPDATEABLE type of VALUE_BOOLEAN;
begin
  if (coalesce(i_object_id, 0) = 0) then i_object_id = gen_id(seq_magazine_id, 1);

  update paramheads set object_id = :i_object_id where param_id = :i_param_id;

  execute procedure param_set(:i_param_id, 'ID', :i_object_id);

  select status_id from magazines where magazine_id = :i_object_id into :v_now_status_id;

  if (v_now_status_id is null) then
  begin
    select o_value from param_get(:i_param_id, 'CATALOG_ID') into :v_catalog_id;
    select o_value from param_get(:i_param_id, 'VALID_DATE') into :v_valid_date;
    insert into magazines(magazine_id, catalog_id, valid_date, status_id)
      values(:i_object_id, :v_catalog_id, :v_valid_date, :v_new_status_id)
      returning status_id
      into :v_new_status_id;
    v_updateable = 1;
  end
  else
  begin
    select o_updateable, o_new_status_id
      from object_updateable(:i_param_id, :v_now_status_id, :i_object_sign)
      into :v_updateable, :v_new_status_id;
  end

  if (v_updateable = 1) then
  begin
    execute procedure param_set(:i_param_id, 'STATUS_ID', :v_new_status_id);
    execute procedure object_put(:i_param_id);
  end

end^


CREATE OR ALTER PROCEDURE ACT_MESSAGE_STORE (
    I_PARAM_ID TYPE OF ID_PARAM,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'MESSAGE')
AS
declare variable V_NOW_STATUS_ID type of ID_STATUS;
declare variable V_NEW_STATUS_ID type of ID_STATUS;
declare variable V_UPDATEABLE type of VALUE_BOOLEAN;
declare variable V_FILENAME type of NAME_FILE;
declare variable V_TEMPLATE_ID type of ID_TEMPLATE;
begin
  if (coalesce(i_object_id, 0) = 0) then i_object_id = gen_id(seq_message_id, 1);

  update paramheads set object_id = :i_object_id where param_id = :i_param_id;

  execute procedure param_set(:i_param_id, 'ID', :i_object_id);

  select status_id from messages where message_id = :i_object_id into :v_now_status_id;

  if (:v_now_status_id is null) then
  begin
    select o_value from param_get(:i_param_id, 'FILE_NAME') into :v_filename;
    select o_value from param_get(:i_param_id, 'TEMPLATE_ID') into :v_template_id;

    insert into messages(message_id, template_id, file_name, status_id)
      values(:i_object_id, :v_template_id, :v_filename, :v_new_status_id)
      returning status_id
      into :v_new_status_id;
    v_updateable = 1;
  end
  else
  begin
    select o_updateable, o_new_status_id
      from object_updateable(:i_param_id, :v_now_status_id, :i_object_sign)
      into :v_updateable, :v_new_status_id;
  end


  if (v_updateable = 1) then
  begin
    execute procedure param_set(:i_param_id, 'STATUS_ID', :v_new_status_id);
    execute procedure object_put(:i_param_id);
  end
end^


CREATE OR ALTER PROCEDURE ACT_ORDER_DEBIT (
    I_PARAM_ID TYPE OF ID_PARAM,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'ORDERITEM')
AS
declare variable V_PARAM_ID type of ID_PARAM;
declare variable V_ACTION_SIGN type of SIGN_ACTION;
declare variable V_OBJECT_ID type of ID_OBJECT;
declare variable V_NEW_STATUS_SIGN type of SIGN_ATTR;
declare variable V_ACTION_ID type of ID_ACTION;
declare variable V_ACTIONTREEITEM_ID type of ID_ACTIONTREEITEM;
begin
  select o_value from param_get(:i_param_id, 'NEW.STATUS_SIGN') into :v_new_status_sign;
  select o_value from param_get(:i_param_id, 'ACTIONTREEITEM_ID') into :v_actiontreeitem_id;

  for select oi.orderitem_id
        from orderitems oi
        where oi.order_id = :i_object_id
        into :v_object_id do
  begin
    select o_param_id from param_create(:i_object_sign, :v_object_id) into :v_param_id;
    insert into params(param_id, param_name, param_value)
      select :v_param_id, p.param_name, p.param_value
        from params p
          inner join actiontree_params atp on (atp.param_name = p.param_name)
        where p.param_id = :i_param_id
          and atp.actiontreeitem_id = :v_actiontreeitem_id;

    select o_action_sign from action_detect(:i_object_sign, :v_object_id, :v_new_status_sign)
      into :v_action_sign;

    if (:v_action_sign is null) then
      select o_value from param_get(:i_param_id, 'ACTION_SIGN') into :v_action_sign;

    if (v_action_sign is not null) then
      execute procedure action_run(:i_object_sign, :v_action_sign, :v_param_id, :v_object_id)
        returning_values :v_action_id;
  end
end^


CREATE OR ALTER PROCEDURE ACT_ORDER_FOREACH_ORDERITEM (
    I_PARAM_ID TYPE OF ID_PARAM,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'ORDERITEM')
AS
declare variable V_PARAM_ID type of ID_PARAM;
declare variable V_ACTION_SIGN type of SIGN_ACTION;
declare variable V_OBJECT_ID type of ID_OBJECT;
declare variable V_NEW_STATUS_SIGN type of SIGN_ATTR;
declare variable V_ACTION_ID type of ID_ACTION;
declare variable V_ACTIONTREEITEM_ID type of ID_ACTIONTREEITEM;
begin
  select o_value from param_get(:i_param_id, 'NEW.STATUS_SIGN') into :v_new_status_sign;
  select o_value from param_get(:i_param_id, 'ACTIONTREEITEM_ID') into :v_actiontreeitem_id;

  for select oi.orderitem_id
        from orderitems oi
        where oi.order_id = :i_object_id
        into :v_object_id do
  begin
    select o_param_id from param_create(:i_object_sign, :v_object_id) into :v_param_id;
    insert into params(param_id, param_name, param_value)
      select :v_param_id, p.param_name, p.param_value
        from params p
          inner join actiontree_params atp on (atp.param_name = p.param_name)
        where p.param_id = :i_param_id
          and atp.actiontreeitem_id = :v_actiontreeitem_id;

    select o_action_sign from action_detect(:i_object_sign, :v_object_id, :v_new_status_sign)
      into :v_action_sign;

    if (:v_action_sign is null) then
      select o_value from param_get(:i_param_id, 'ACTION_SIGN') into :v_action_sign;

    if (v_action_sign is not null) then
      execute procedure action_run(:i_object_sign, :v_action_sign, :v_param_id, :v_object_id)
        returning_values :v_action_id;
  end
end^


CREATE OR ALTER PROCEDURE ACT_ORDER_FOREACH_ORDERTAX (
    I_PARAM_ID TYPE OF ID_PARAM,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'ORDERTAX')
AS
declare variable V_PARAM_ID type of ID_PARAM;
declare variable V_ACTION_SIGN type of SIGN_ACTION;
declare variable V_OBJECT_ID type of ID_OBJECT;
declare variable V_NEW_STATUS_SIGN type of SIGN_ATTR;
declare variable V_ACTION_ID type of ID_ACTION;
declare variable V_ACTIONTREEITEM_ID type of ID_ACTIONTREEITEM;
begin
  select o_value from param_get(:i_param_id, 'NEW.STATUS_SIGN') into :v_new_status_sign;
  select o_value from param_get(:i_param_id, 'ACTIONTREEITEM_ID') into :v_actiontreeitem_id;

  for select ordertax_id
        from ordertaxs
        where order_id = :i_object_id
        into :v_object_id do
  begin
    select o_param_id from param_create(:i_object_sign, :v_object_id) into :v_param_id;
    insert into params(param_id, param_name, param_value)
      select :v_param_id, p.param_name, p.param_value
        from params p
          inner join actiontree_params atp on (atp.param_name = p.param_name)
        where p.param_id = :i_param_id
          and atp.actiontreeitem_id = :v_actiontreeitem_id;

    select o_action_sign from action_detect(:i_object_sign, :v_object_id, :v_new_status_sign)
      into :v_action_sign;

    if (:v_action_sign is null) then
      select o_value from param_get(:i_param_id, 'ACTION_SIGN') into :v_action_sign;

    if (v_action_sign is not null) then
      execute procedure action_run(:i_object_sign, :v_action_sign, :v_param_id, :v_object_id)
        returning_values :v_action_id;
  end
end^


CREATE OR ALTER PROCEDURE ACT_ORDER_FOREACH_TAXRATE (
    I_PARAM_ID TYPE OF ID_PARAM,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'ORDERTAX')
AS
declare variable V_PARAM_ID type of ID_PARAM;
declare variable V_ACTION_SIGN type of SIGN_ACTION;
declare variable V_NEW_STATUS_SIGN type of SIGN_ATTR;
declare variable V_ACTION_ID type of ID_ACTION;
declare variable V_TAXRATE_ID type of ID_TAX;
declare variable V_TAX_PROCEDURE type of NAME_PROCEDURE;
declare variable V_COST_EUR type of MONEY_EUR;
declare variable V_OBJECT_ID type of ID_OBJECT;
declare variable V_ACTIONTREEITEM_ID type of ID_ACTIONTREEITEM;
begin
  select o_value from param_get(:i_param_id, 'NEW.STATUS_SIGN') into :v_new_status_sign;
  select o_value from param_get(:i_param_id, 'ACTIONTREEITEM_ID') into :v_actiontreeitem_id;

  for select tr.taxrate_id, tr.tax_procedure
    from orders o
      inner join calcpoints cp on (cp.object_status_id = o.status_id)
      inner join taxservs ts on (ts.calcpoint_id = cp.calcpoint_id)
      inner join taxrates tr on (tr.taxserv_id = ts.taxserv_id and tr.taxplan_id = o.taxplan_id)
      left join ordertaxs ot on (ot.order_id = o.order_id and ot.taxrate_id = tr.taxrate_id)
    where o.order_id = :i_object_id
      and ot.ordertax_id is null
    into :v_taxrate_id, :v_tax_procedure do
  begin
    v_object_id = gen_id(seq_ordertax_id, 1);

    select o_param_id from param_create(:i_object_sign, :v_object_id) into :v_param_id;
    insert into params(param_id, param_name, param_value)
      select :v_param_id, p.param_name, p.param_value
        from params p
          inner join actiontree_params atp on (atp.param_name = p.param_name)
        where p.param_id = :i_param_id
          and atp.actiontreeitem_id = :v_actiontreeitem_id;

    execute statement ('select o_cost_eur from '||v_tax_procedure||'(:taxrate_id, :param_id)')
      (taxrate_id := :v_taxrate_id, param_id := :v_param_id)
      into :v_cost_eur;
    if (v_cost_eur > 0) then
    begin
      select o_action_sign from action_detect(:i_object_sign, :v_object_id, :v_new_status_sign)
        into :v_action_sign;

      if (v_action_sign is not null) then
      begin
        execute procedure param_set(:v_param_id, 'TAXRATE_ID', :v_taxrate_id);
        execute procedure action_run(:i_object_sign, :v_action_sign, :v_param_id, :v_object_id)
          returning_values :v_action_id;
      end
    end
  end
end^


CREATE OR ALTER PROCEDURE ACT_ORDER_STORE (
    I_PARAM_ID TYPE OF ID_PARAM,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'ORDER')
AS
declare variable V_NOW_STATUS_ID type of ID_STATUS;
declare variable V_NEW_STATUS_ID type of ID_STATUS;
declare variable V_UPDATEABLE type of VALUE_BOOLEAN;
declare variable V_CALCPOINT_ID type of ID_CALCPOINT;
declare variable V_NEW_STATE_SIGN type of SIGN_OBJECT;
declare variable V_NEW_STATE_ID type of ID_STATUS;
begin
  if (coalesce(i_object_id, 0) = 0) then i_object_id = gen_id(seq_order_id, 1);

  update paramheads set object_id = :i_object_id where param_id = :i_param_id;

  execute procedure param_set(:i_param_id, 'ID', :i_object_id);

  select oi.status_id from orders oi where oi.order_id = :i_object_id into :v_now_status_id;

  if (:v_now_status_id is null) then
  begin
    insert into orders(order_id, status_id)
      values(:i_object_id, :v_new_status_id)
      returning status_id
      into :v_new_status_id;
    v_updateable = 1;
  end
  else
  begin
    select o_updateable, o_new_status_id
      from object_updateable(:i_param_id, :v_now_status_id, :i_object_sign)
      into :v_updateable, :v_new_status_id;
  end

  select o_value from param_get(:i_param_id,  'NEW.STATE_SIGN') into :v_new_state_sign;
  if (:v_new_state_sign is not null) then
  begin
    select s.status_id 
      from statuses s
      where s.object_sign = :i_object_sign
        and s.status_sign = :v_new_state_sign
      into :v_new_state_id;
    execute procedure param_set(:i_param_id, 'STATE_ID', :v_new_state_id);
  end

  if (v_updateable = 1) then
  begin
    select cp.calcpoint_id
      from calcpoints cp
      where cp.object_status_id = :v_new_status_id
      into :v_calcpoint_id;
    execute procedure param_set(:i_param_id, 'CALCPOINT_ID', :v_calcpoint_id);

    execute procedure param_set(:i_param_id, 'STATUS_ID', :v_new_status_id);
    execute procedure object_put(:i_param_id);

    execute procedure orderhistory_update(:i_object_id, :v_new_status_id, null);
  end
  else
    exception ex_status_conversion_unavail 'From '||:v_now_status_id||' to '||:v_new_status_id;
end^


CREATE OR ALTER PROCEDURE ACT_ORDERITEM_STORE (
    I_PARAM_ID TYPE OF ID_PARAM,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'ORDERITEM')
AS
declare variable V_NOW_STATUS_ID type of ID_STATUS;
declare variable V_NEW_STATUS_ID type of ID_STATUS;
declare variable V_ORDER_ID type of ID_ORDER;
declare variable V_ARTICLE_ID type of ID_ARTICLE;
declare variable V_UPDATEABLE type of VALUE_BOOLEAN;
declare variable V_NEW_STATE_ID type of ID_STATUS;
declare variable V_NEW_STATE_SIGN type of SIGN_OBJECT;
begin
  if (coalesce(i_object_id, 0) = 0) then i_object_id = gen_id(seq_orderitem_id, 1);

  update paramheads set object_id = :i_object_id where param_id = :i_param_id;

  execute procedure param_set(:i_param_id, 'ID', :i_object_id);

  select status_id from orderitems where orderitem_id = :i_object_id into :v_now_status_id;

  if (:v_now_status_id is null) then
  begin
    select o_value from param_get(:i_param_id, 'STATUS_ID') into :v_new_status_id;
    if (:v_new_status_id is null) then
       select s.status_id
         from param_get(:i_param_id, 'NEW.STATUS_SIGN') p
           inner join statuses s on (s.object_sign = :i_object_sign and s.status_sign = p.o_value)
       into :v_new_status_id;

    select o_value from param_get(:i_param_id, 'ORDER_ID') into :v_order_id;
    select o_value from param_get(:i_param_id, 'ARTICLE_ID') into :v_article_id;

    insert into orderitems(orderitem_id, order_id, article_id, status_id)
      values(:i_object_id, :v_order_id, :v_article_id, :v_new_status_id)
      returning status_id
      into :v_new_status_id;
    v_updateable = 1;
  end
  else
  begin
    select o_updateable, o_new_status_id
      from object_updateable(:i_param_id, :v_now_status_id, :i_object_sign)
      into :v_updateable, :v_new_status_id;

    select oi.order_id
      from orderitems oi
      where oi.orderitem_id = :i_object_id
      into :v_order_id;
  end

  select o_value from param_get(:i_param_id,  'NEW.STATE_SIGN') into :v_new_state_sign;
  if (:v_new_state_sign is not null) then
  begin
    select s.status_id 
      from statuses s
      where s.object_sign = :i_object_sign
        and s.status_sign = :v_new_state_sign
      into :v_new_state_id;
    execute procedure param_set(:i_param_id, 'STATE_ID', :v_new_state_id);
  end

  if (v_updateable = 1) then
  begin
    execute procedure param_set(:i_param_id, 'STATUS_ID', :v_new_status_id);
    execute procedure object_put(:i_param_id);
  end
end^


CREATE OR ALTER PROCEDURE ACT_ORDERMONEY_CREDIT (
    I_PARAM_ID TYPE OF ID_PARAM,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'ORDERMONEY')
AS
declare variable V_NOW_STATUS_ID type of ID_STATUS;
declare variable V_ORDER_ID type of ID_ORDER;
declare variable V_UPDATEABLE type of VALUE_BOOLEAN;
declare variable V_NEW_STATUS_ID type of ID_STATUS;
declare variable V_ACCOUNT_ID type of ID_ACCOUNT;
begin
  if (coalesce(i_object_id, 0) = 0) then i_object_id = gen_id(seq_ordermoney_id, 1);
    
  update paramheads set object_id = :i_object_id where param_id = :i_param_id;
    
  execute procedure param_set(:i_param_id, 'ID', :i_object_id);
    
  select status_id from ordermoneys where ordermoney_id = :i_object_id into :v_now_status_id;

  if (:v_now_status_id is null) then
  begin
    select o_value from param_get(:i_param_id, 'ACCOUNT_ID') into :v_account_id;
    select o_value from param_get(:i_param_id, 'ORDER_ID') into :v_order_id;

    insert into ordermoneys(ordermoney_id, order_id, account_id, status_id)
      values(:i_object_id, :v_order_id, :v_account_id, :v_new_status_id)
      returning status_id
      into :v_new_status_id;
    v_updateable = 1;
  end
  else
  begin
    select o_updateable, o_new_status_id
      from object_updateable(:i_param_id, :v_now_status_id, :i_object_sign)
      into :v_updateable, :v_new_status_id;
  end

  if ((v_updateable = 1) or exists(select o_value from param_get(:i_param_id, 'UPDATEABLE'))) then
  begin
    execute procedure param_set(:i_param_id, 'STATUS_ID', :v_new_status_id);
    execute procedure object_put(:i_param_id);
  end
end^


CREATE OR ALTER PROCEDURE ACT_ORDERMONEY_DEBIT (
    I_PARAM_ID TYPE OF ID_PARAM,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'ORDERMONEY')
AS
declare variable V_NOW_STATUS_ID type of ID_STATUS;
declare variable V_ORDER_ID type of ID_ORDER;
declare variable V_UPDATEABLE type of VALUE_BOOLEAN;
declare variable V_NEW_STATUS_ID type of ID_STATUS;
declare variable V_ACCOUNT_ID type of ID_ACCOUNT;
begin
  if (coalesce(i_object_id, 0) = 0) then i_object_id = gen_id(seq_ordermoney_id, 1);
    
  update paramheads set object_id = :i_object_id where param_id = :i_param_id;
    
  execute procedure param_set(:i_param_id, 'ID', :i_object_id);
    
  select status_id from ordermoneys where ordermoney_id = :i_object_id into :v_now_status_id;

  if (:v_now_status_id is null) then
  begin
    select o_value from param_get(:i_param_id, 'ACCOUNT_ID') into :v_account_id;
    select o_value from param_get(:i_param_id, 'ORDER_ID') into :v_order_id;

    insert into ordermoneys(ordermoney_id, order_id, account_id, status_id)
      values(:i_object_id, :v_order_id, :v_account_id, :v_new_status_id)
      returning status_id
      into :v_new_status_id;
    v_updateable = 1;
  end
  else
  begin
    select o_updateable, o_new_status_id
      from object_updateable(:i_param_id, :v_now_status_id, :i_object_sign)
      into :v_updateable, :v_new_status_id;
  end

  if ((v_updateable = 1) or exists(select o_value from param_get(:i_param_id, 'UPDATEABLE'))) then
  begin
    execute procedure param_set(:i_param_id, 'STATUS_ID', :v_new_status_id);
    execute procedure object_put(:i_param_id);
  end
end^


CREATE OR ALTER PROCEDURE ACT_ORDERMONEY_STORE (
    I_PARAM_ID TYPE OF ID_PARAM,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'ORDERMONEY')
AS
declare variable V_NOW_STATUS_ID type of ID_STATUS;
declare variable V_ORDER_ID type of ID_ORDER;
declare variable V_UPDATEABLE type of VALUE_BOOLEAN;
declare variable V_NEW_STATUS_ID type of ID_STATUS;
declare variable V_ACCOUNT_ID type of ID_ACCOUNT;
begin
  if (coalesce(i_object_id, 0) = 0) then i_object_id = gen_id(seq_ordermoney_id, 1);
    
  update paramheads set object_id = :i_object_id where param_id = :i_param_id;
    
  execute procedure param_set(:i_param_id, 'ID', :i_object_id);
    
  select status_id from ordermoneys where ordermoney_id = :i_object_id into :v_now_status_id;

  if (:v_now_status_id is null) then
  begin
    select o_value from param_get(:i_param_id, 'ACCOUNT_ID') into :v_account_id;
    select o_value from param_get(:i_param_id, 'ORDER_ID') into :v_order_id;

    insert into ordermoneys(ordermoney_id, order_id, account_id, status_id)
      values(:i_object_id, :v_order_id, :v_account_id, :v_new_status_id)
      returning status_id
      into :v_new_status_id;
    v_updateable = 1;
  end
  else
  begin
    select o_updateable, o_new_status_id
      from object_updateable(:i_param_id, :v_now_status_id, :i_object_sign)
      into :v_updateable, :v_new_status_id;
  end

  if ((v_updateable = 1) or exists(select o_value from param_get(:i_param_id, 'UPDATEABLE'))) then
  begin
    execute procedure param_set(:i_param_id, 'STATUS_ID', :v_new_status_id);
    execute procedure object_put(:i_param_id);
  end
end^


CREATE OR ALTER PROCEDURE ACT_ORDERTAX_STORE (
    I_PARAM_ID TYPE OF ID_PARAM,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'ORDERTAX')
AS
declare variable V_NOW_STATUS_ID type of ID_STATUS;
declare variable V_ORDER_ID type of ID_ORDER;
declare variable V_UPDATEABLE type of VALUE_BOOLEAN;
declare variable V_NEW_STATUS_ID type of ID_STATUS;
declare variable V_TAXRATE_ID type of ID_TAX;
declare variable V_TAXPLAN_ID type of ID_TAX;
declare variable V_TAX_PROCEDURE type of NAME_PROCEDURE;
declare variable V_PRICE_EUR type of MONEY_EUR;
declare variable V_AMOUNT type of VALUE_INTEGER;
declare variable V_CALCPOINT_ID type of ID_CALCPOINT;
begin
  if (coalesce(i_object_id, 0) = 0) then i_object_id = gen_id(seq_ordertax_id, 1);
    
  update paramheads set object_id = :i_object_id where param_id = :i_param_id;
    
  execute procedure param_set(:i_param_id, 'ID', :i_object_id);
    
  select status_id from ordertaxs where ordertax_id = :i_object_id into :v_now_status_id;

  if (:v_now_status_id is null) then
  begin
    select o_value from param_get(:i_param_id, 'TAXRATE_ID') into :v_taxrate_id;
    select o_value from param_get(:i_param_id, 'ORDER_ID') into :v_order_id;

    insert into ordertaxs(ordertax_id, order_id, taxrate_id, status_id)
      values(:i_object_id, :v_order_id, :v_taxrate_id, :v_new_status_id)
      returning status_id
      into :v_new_status_id;
    v_updateable = 1;
  end
  else
  begin
    select o_updateable, o_new_status_id
      from object_updateable(:i_param_id, :v_now_status_id, :i_object_sign)
      into :v_updateable, :v_new_status_id;
  end

  if (v_updateable = 1) then
  begin
    execute procedure param_set(:i_param_id, 'STATUS_ID', :v_new_status_id);
    execute procedure object_put(:i_param_id);
  end
  else
    exception ex_status_conversion_unavail 'From '||:v_now_status_id||' to '||:v_new_status_id;

end^


CREATE OR ALTER PROCEDURE ACT_PAYMENT_STORE (
    I_PARAM_ID TYPE OF ID_PARAM,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'INVOICE')
AS
declare variable V_NOW_STATUS_ID type of ID_STATUS;
declare variable V_NEW_STATUS_ID type of ID_STATUS;
declare variable V_UPDATEABLE type of VALUE_BOOLEAN;
declare variable V_AMOUNT_BYR type of MONEY_BYR;
declare variable V_MESSAGE_ID type of ID_MESSAGE;
declare variable V_CREATE_DT type of DT_INVOICE;
begin
  if (coalesce(i_object_id, 0) = 0) then i_object_id = gen_id(seq_payment_id, 1);

  update paramheads set object_id = :i_object_id where param_id = :i_param_id;

  execute procedure param_set(:i_param_id, 'ID', :i_object_id);

  select status_id from payments where payment_id = :i_object_id into :v_now_status_id;

  if (:v_now_status_id is null) then
  begin
    select o_value from param_get(:i_param_id, 'STATUS_ID') into :v_new_status_id;
    if (:v_new_status_id is null) then
       select s.status_id
         from param_get(:i_param_id, 'NEW.STATUS_SIGN') p
           inner join statuses s on (s.object_sign = :i_object_sign and s.status_sign = p.o_value)
       into :v_new_status_id;
    select o_value from param_get(:i_param_id, 'MESSAGE_ID') into :v_message_id;
    select o_value from param_get(:i_param_id, 'AMOUNT_BYR') into :v_amount_byr;
    select o_value from param_get(:i_param_id, 'CREATE_DT') into :v_create_dt;

    insert into payments(payment_id, message_id, create_dt, amount_byr, status_id)
      values(:i_object_id, :v_message_id, :v_create_dt, :v_amount_byr, :v_new_status_id)
      returning status_id
      into :v_new_status_id;
    v_updateable = 1;
  end
  else
  begin
    select o_updateable, o_new_status_id
      from object_updateable(:i_param_id, :v_now_status_id, :i_object_sign)
      into :v_updateable, :v_new_status_id;
  end
  if (v_updateable = 1) then
  begin
    execute procedure param_set(:i_param_id, 'STATUS_ID', :v_new_status_id);
    execute procedure object_put(:i_param_id);
  end
end^


CREATE OR ALTER PROCEDURE ACT_PLACE_STORE (
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT = 'PLACE')
AS
declare variable V_NOW_STATUS_ID type of ID_STATUS;
declare variable V_OWNER_PLACE_ID type of ID_PLACE;
declare variable V_PLACETYPE_CODE type of CODE_PLACETYPE;
declare variable V_PLACE_NAME type of NAME_REF;
declare variable V_NEW_STATUS_ID type of ID_STATUS;
declare variable V_UPDATEABLE type of VALUE_BOOLEAN;
begin
  if (coalesce(i_object_id, 0) = 0) then i_object_id = gen_id(seq_place_id, 1);

  update paramheads set object_id = :i_object_id where param_id = :i_param_id;

  execute procedure param_set(:i_param_id, 'ID', :i_object_id);

  select status_id from places where place_id = :i_object_id into :v_now_status_id;

  if (:v_now_status_id is null) then
  begin
    select o_value from param_get(:i_param_id, 'AREA_ID') into :v_owner_place_id;
    select o_value from param_get(:i_param_id, 'PLACETYPE_CODE') into :v_placetype_code;
    select o_value from param_get(:i_param_id, 'PLACE_NAME') into :v_place_name;

    insert into places(place_id, placetype_code, owner_place, place_name)
      values(:i_object_id, :v_placetype_code, :v_owner_place_id, :v_place_name)
      returning status_id
      into :v_new_status_id;
    v_updateable = 1;
  end
  else
  begin
    select o_updateable, o_new_status_id
      from object_updateable(:i_param_id, :v_now_status_id, :i_object_sign)
      into :v_updateable, :v_new_status_id;
  end

  if (v_updateable = 1) then
  begin
    execute procedure param_set(:i_param_id, 'STATUS_ID', :v_new_status_id);
    execute procedure object_put(:i_param_id);
  end
end^


CREATE OR ALTER PROCEDURE ACTION_DETECT (
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT,
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_NEW_STATUS_SIGN TYPE OF SIGN_OBJECT)
RETURNS (
    O_ACTION_SIGN TYPE OF SIGN_ACTION)
AS
declare variable V_TABLE_NAME type of NAME_PROCEDURE;
declare variable V_IDFIELD_NAME type of NAME_PROCEDURE;
declare variable V_SQL type of SQL_STATEMENT;
declare variable V_NEW_STATUS_ID type of ID_STATUS;
declare variable V_NOW_STATUS_ID type of ID_STATUS;
declare variable V_NOW_STATUS_SIGN type of SIGN_OBJECT;
declare variable V_ERROR_MESSAGE type of RDB$MESSAGE;
declare variable V_ERROR type of VALUE_ATTR;
begin
  i_object_sign = trim(i_object_sign);
  -- get current status_id
  select o.table_name, o.idfield_name
    from objects o
    where o.object_sign = :i_object_sign
    into :v_table_name, :v_idfield_name;

  v_sql = 'select status_id from '||v_table_name||' where '||v_idfield_name||' = :object_id';

  execute statement (:v_sql) (object_id := :i_object_id)
    into :v_now_status_id;

  select s.status_sign
    from statuses s
    where s.status_id = :v_now_status_id
      and s.object_sign = :i_object_sign
    into :v_now_status_sign;

  select s.status_id
    from statuses s
    where s.status_sign = :i_new_status_sign
      and s.object_sign = :i_object_sign
    into :v_new_status_id;

  if (v_now_status_id = v_new_status_id) then
    o_action_sign = :i_object_sign||'_STORE';
  else
  if (v_now_status_id is null) then
  begin
    -- get default action_sign
    select coalesce(s.action_sign, :i_object_sign||'_STORE')
      from statuses s
      where s.object_sign = :i_object_sign
        and s.is_default = 1
      into :o_action_sign;
  end
  else
  if (v_new_status_id is not null) then
  begin
    -- get action_sign
    select sr.action_sign
      from status_rules sr
      where sr.old_status_id = :v_now_status_id
        and sr.new_status_id = :v_new_status_id
      into :o_action_sign;

    if (:o_action_sign is null) then
    begin
      select RDB$MESSAGE
        from RDB$EXCEPTIONS
        where RDB$EXCEPTION_NAME = 'EX_UNDETECTED_ACTIONCODE'
        into :v_error_message;
      v_error = v_error_message||' (объект="'||:i_object_sign||'" id="'||:i_object_id||'" переход из="'||:v_now_status_sign||'" в="'||:i_new_status_sign||'")';
      exception ex_undetected_actioncode :v_error;
    end
  end

  suspend;
end^


CREATE OR ALTER PROCEDURE ACTION_EXECUTE (
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT,
    I_PARAMS TYPE OF VALUE_BLOB,
    I_ACTION_SIGN TYPE OF SIGN_ACTION,
    I_OBJECT_ID TYPE OF ID_OBJECT)
RETURNS (
    O_ACTION_ID TYPE OF ID_ACTION)
AS
declare variable V_NEW_STATUS_SIGN type of SIGN_ATTR;
declare variable V_PARAM_ID type of ID_PARAM;
declare variable V_ACTION_ID type of ID_ACTION;
declare variable V_LOG_ID type of ID_LOG;
declare variable V_NOW_STATUS_ID type of ID_STATUS;
declare variable V_NOW_STATUS_SIGN type of SIGN_OBJECT;
begin
  select o_param_id
    from param_create(:i_object_sign)
    into :v_param_id;

  execute procedure param_unparse(:v_param_id, :i_params);

--  select o_log_id
--    from log_create(:i_object_sign, :v_param_id, null, null, coalesce(:i_object_id, 0))
--    into :v_log_id;

  i_object_id = nullif(i_object_id, 0);
  if (:i_object_id is not null) then
    execute procedure param_set(:v_param_id, 'ID', :i_object_id);
  else
    select o_value from param_get(:v_param_id, 'ID') into :i_object_id;

  select o_value from param_get(:v_param_id, 'NEW.STATUS_SIGN') into :v_new_status_sign;

  if (i_action_sign is null) then
    select o_action_sign
      from action_detect(:i_object_sign, :i_object_id, :v_new_status_sign)
      into :i_action_sign;

  if (i_action_sign is null) then
    i_action_sign= :i_object_sign||'_STORE';

  select o_action_id
    from action_run(:i_object_sign, :i_action_sign, :v_param_id, :i_object_id)
    into :o_action_id;
  suspend;
end^


CREATE OR ALTER PROCEDURE ACTION_REEXECUTE (
    I_LOG_ID TYPE OF ID_LOG)
AS
declare variable V_PARAMS type of VALUE_BLOB;
declare variable V_OBJECT_SIGN type of SIGN_OBJECT;
declare variable V_ACTION_SIGN type of SIGN_ACTION;
declare variable V_ACTION_ID type of ID_ACTION;
begin
  select l.action_sign, l.params_in
    from logs l
    where l.log_id = :i_log_id 
    into :v_object_sign, :v_params;

  select o_action_id from action_execute(:v_object_sign, :v_params, null, null)
    into :v_action_id;

end^


CREATE OR ALTER PROCEDURE ACTION_RERUN (
    I_LOG_ID TYPE OF ID_LOG)
AS
declare variable V_PARAMS type of VALUE_BLOB;
declare variable V_OBJECT_SIGN type of SIGN_OBJECT;
declare variable V_ACTION_SIGN type of SIGN_ACTION;
declare variable V_ACTION_ID type of ID_ACTION;
begin
  select l.action_sign, l.params_in, ac.object_sign
    from logs l
      inner join actioncodes ac on (ac.action_sign = l.action_sign)
    where l.log_id = :i_log_id 
    into :v_action_sign, :v_params, :v_object_sign;

  if (v_object_sign is null) then
    select l.action_sign, l.params_in
      from logs l
      where l.log_id = :i_log_id
      into :v_object_sign, :v_params;

  select o_action_id from action_execute(:v_object_sign, :v_params, null, null)
    into :v_action_id;

end^


CREATE OR ALTER PROCEDURE ACTION_RERUN_ACTION (
    I_LOG_ID TYPE OF ID_LOG)
AS
declare variable V_PARAMS type of VALUE_BLOB;
declare variable V_OBJECT_SIGN type of SIGN_OBJECT;
declare variable V_ACTION_SIGN type of SIGN_ACTION;
declare variable V_ACTION_ID type of ID_ACTION;
begin
  select l.action_sign, l.params_in, ac.object_sign
    from logs l
      inner join actioncodes ac on (ac.action_sign = l.action_sign)
    where l.log_id = :i_log_id 
    into :v_action_sign, :v_params, :v_object_sign;

  if (v_object_sign is null) then
    select l.action_sign, l.params_in
      from logs l
      where l.log_id = :i_log_id
      into :v_object_sign, :v_params;

  select o_action_id from action_execute(:v_object_sign, :v_params, :v_action_sign, null)
    into :v_action_id;

end^


CREATE OR ALTER PROCEDURE ACTION_RUN (
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT,
    I_ACTION_SIGN TYPE OF SIGN_ACTION,
    I_PARAM_ID TYPE OF ID_PARAM,
    I_OBJECT_ID TYPE OF ID_OBJECT)
RETURNS (
    O_ACTION_ID TYPE OF ID_ACTION)
AS
declare variable V_PARAM_ID type of ID_PARAM;
declare variable V_PARAM_NAME type of SIGN_OBJECT;
declare variable V_PARAM_KIND type of KIND_PARAM;
declare variable V_PARAM_VALUE type of VALUE_ATTR;
declare variable V_PARAM_VALUE_2 type of VALUE_ATTR;
declare variable V_ACTIONTREEITEM_ID type of ID_ACTIONTREEITEM;
declare variable V_CHILD_OBJECT_SIGN type of SIGN_OBJECT;
declare variable V_CHILD_ACTION_SIGN type of SIGN_ACTION;
declare variable V_SQL type of SQL_STATEMENT;
declare variable V_PROCEDURE_NAME type of SIGN_OBJECT;
declare variable V_PARAM_ACTION type of SIGN_ACTION;
declare variable V_VALID_CRITERIAS type of BOOLEAN = 1;
declare variable V_LOG_ID type of ID_LOG;
declare variable V_CHILD_ACTION_ID type of ID_ACTION;
begin
  i_object_sign = trim(i_object_sign);
  i_action_sign = trim(i_action_sign);
  o_action_id = gen_id(seq_action_id, 1);
  select o_log_id
    from log_create(:i_action_sign, :i_param_id, :o_action_id, :o_action_id, coalesce(:i_object_id, 0))
    into :v_log_id;

  i_object_id = nullif(i_object_id, 0);
  if (i_object_id is null) then
    select o_value from param_get(:i_param_id, 'ID') into :i_object_id;
  else
    execute procedure param_set(:i_param_id, 'ID', :i_object_id);

  insert into actions (action_id, action_sign, action_dtm, object_id)
    values(:o_action_id, :i_action_sign, current_timestamp, :i_object_id);

  update paramheads
    set action_id = :o_action_id,
        object_id = :i_object_id
    where param_id = :i_param_id;

  -- get action object_code
  select coalesce(a.procedure_name, a.action_sign)
    from actioncodes a
    where a.action_sign = :i_action_sign
    into :v_procedure_name;

  -- read action input params
  for select acp.param_name, trim(acp.param_kind), acp.param_value
    from actioncode_params acp
      inner join paramkinds pk on (pk.param_kind = acp.param_kind)
    where acp.action_sign = :i_action_sign
      and pk.is_output = 0
    order by pk.order_no
    into :v_param_name, :v_param_kind, :v_param_value
  do execute procedure param_calc_in(:i_object_sign, :i_param_id, :v_param_name, :v_param_kind, :v_param_value, :i_param_id);

  if (i_object_id is not null) then
    execute procedure object_get(:i_object_sign, :i_object_id, :i_param_id);

  v_valid_criterias = 1;
  -- check criterias
  for select acc.param_name, acc.param_action, acc.param_kind, acc.param_value_1, acc.param_value_2
    from actioncode_criterias acc
    where acc.actioncode_sign = :i_action_sign
    into :v_param_name, :v_param_action, :v_param_kind, :v_param_value, :v_param_value_2
  do
  begin
    select o_valid
      from param_criteria (:i_param_id, :v_param_name, :v_param_action, :v_param_kind, :v_param_value, :v_param_value_2)
      into :v_valid_criterias;
    if (:v_valid_criterias = 0) then
      leave;
  end

  if (v_valid_criterias = 1) then
  begin
    if (v_procedure_name = 'PAYMENT_STORE') then
      execute procedure act_payment_store(:i_param_id, :i_object_id);
    else
    if (v_procedure_name = 'ACCOUNT_STORE') then
      execute procedure act_account_store(:i_param_id, :i_object_id);
    else
    if (v_procedure_name = 'ORDER_FOREACH_ORDERITEM') then
      execute procedure act_order_foreach_orderitem(:i_param_id, :i_object_id);
    else
    if (v_procedure_name = 'ORDER_FOREACH_ORDERTAX') then
      execute procedure act_order_foreach_ordertax(:i_param_id, :i_object_id);
    else
    if (v_procedure_name = 'ORDER_FOREACH_TAXRATE') then
      execute procedure act_order_foreach_taxrate(:i_param_id, :i_object_id);
    else
    if (v_procedure_name = 'ORDERITEM_STORE') then
      execute procedure act_orderitem_store(:i_param_id, :i_object_id);
    else
    if (v_procedure_name = 'CLIENT_STORE') then
      execute procedure act_client_store(:i_param_id, :i_object_id);
    else
    if (v_procedure_name = 'ORDERTAX_STORE') then
      execute procedure act_ordertax_store(:i_param_id, :i_object_id);
    else
    if (v_procedure_name = 'ORDER_STORE') then
      execute procedure act_order_store(:i_param_id, :i_object_id);
    else
    if (v_procedure_name = 'MESSAGE_STORE') then
      execute procedure act_message_store(:i_param_id, :i_object_id);
    else
    if (v_procedure_name = 'MAGAZINE_STORE') then
      execute procedure act_magazine_store(:i_param_id, :i_object_id);
    else
    begin
    -- run main action
      v_sql = 'execute procedure act_'||:v_procedure_name||'(:param_id, :object_id)';
      execute statement (:v_sql) (param_id := :i_param_id, object_id := :i_object_id);
    end
  
    if (:i_object_id is null) then
    begin
      select o_value from param_get(:i_param_id, 'ID') into :i_object_id;
      update actions
        set object_id = :i_object_id
        where action_id = :o_action_id;
    end
  
    -- run child actions
    for select a.actiontreeitem_id, a.child_action, c.object_sign
      from actiontree a
        inner join actioncodes c on (c.action_sign = a.child_action)
      where a.action_sign = :i_action_sign
      order by a.order_no
      into :v_actiontreeitem_id, :v_child_action_sign, :v_child_object_sign do
    begin
      select o_param_id from param_create(:v_child_object_sign) into :v_param_id;
      execute procedure param_set(:v_param_id, 'ACTIONTREEITEM_ID', :v_actiontreeitem_id);
      -- calc child action input param
      for select atp.param_name, atp.param_kind, atp.param_value
        from actiontree_params atp
          inner join paramkinds pk on (pk.param_kind = atp.param_kind)
        where atp.actiontreeitem_id = :v_actiontreeitem_id
          and pk.is_output = 0
        order by pk.order_no
        into :v_param_name, :v_param_kind, :v_param_value
      do execute procedure param_calc_in(:v_child_object_sign, :v_param_id, :v_param_name, :v_param_kind, :v_param_value, :i_param_id);
  
      v_valid_criterias = 1;
      -- check criterias
      for select atc.param_name, atc.param_action, atc.param_kind, atc.param_value_1, atc.param_value_2
        from actiontree_criterias atc
        where atc.actiontreeitem_id = :v_actiontreeitem_id
        into :v_param_name, :v_param_action, :v_param_kind, :v_param_value, :v_param_value_2
      do
      begin
        select o_valid
          from param_criteria (:v_param_id, :v_param_name, :v_param_action, :v_param_kind, :v_param_value, :v_param_value_2)
          into :v_valid_criterias;
        if (:v_valid_criterias = 0) then
          leave;
      end
      if (:v_valid_criterias = 1) then
      begin
        -- execute child action
        if (v_child_action_sign like '%FOREACH%') then
          execute procedure action_run(:v_child_object_sign, :v_child_action_sign, :v_param_id, :i_object_id)
            returning_values :v_child_action_id;
        else
          execute procedure action_run(:v_child_object_sign, :v_child_action_sign, :v_param_id, null)
            returning_values :v_child_action_id;
        -- extract output params
        for select atp.param_name, atp.param_kind, atp.param_value
          from actiontree_params atp
            inner join paramkinds pk on (pk.param_kind = atp.param_kind)
          where atp.actiontreeitem_id = :v_actiontreeitem_id
            and pk.is_output = 1
          order by pk.order_no
          into :v_param_name, :v_param_kind, :v_param_value
        do execute procedure param_calc_out(:v_child_object_sign, :v_param_id, :v_param_name, :v_param_kind, :v_param_value, :i_param_id);
      end
    end
  
    execute procedure param_set(:i_param_id, 'ACTION_ID', :o_action_id);
  
    for select acp.param_name, acp.param_kind, acp.param_value
      from actioncode_params acp
        inner join paramkinds pk on (pk.param_kind = acp.param_kind)
      where acp.action_sign = :i_action_sign
        and pk.is_output = 1
      order by pk.order_no
      into :v_param_name, :v_param_kind, :v_param_value
    do execute procedure param_calc_out(:i_object_sign, :i_param_id, :v_param_name, :v_param_kind, :v_param_value, :i_param_id);
    execute procedure log_update(:v_log_id, :i_param_id, 0, coalesce(:i_object_id, 0));
  end
  else
    execute procedure log_update_skiped(:v_log_id, :i_param_id, 0, coalesce(:i_object_id, 0));

  suspend;
-- Exception Handler
  when any do
    begin
      execute procedure log_update(:v_log_id, :i_param_id, sqlcode, coalesce(:i_object_id, 0));
      exception;
    end
end^


CREATE OR ALTER PROCEDURE ARTICLE_GOC (
    I_MAGAZINE_ID TYPE OF ID_MAGAZINE,
    I_ARTICLE_CODE TYPE OF SIGN_ARTICLE,
    I_COLOR TYPE OF VALUE_SHORT,
    I_DIMENSION TYPE OF NAME_SHORT,
    I_PRICE_EUR TYPE OF MONEY_EUR,
    I_WEIGHT TYPE OF VALUE_INTEGER,
    I_DESCRIPTION TYPE OF VALUE_SHORT,
    I_IMAGE_URL TYPE OF URL = null)
RETURNS (
    O_ARTICLE_ID TYPE OF ID_ARTICLE)
AS
declare variable V_ARTICLECODE_ID type of ID_ARTICLE;
declare variable V_ARTICLE_SIGN type of SIGN_ARTICLE;
declare variable V_ARTTICLESIGN_ID type of ID_ARTICLE;
begin
  select ac.o_articlecode_id
    from articlecode_goc(:i_article_code, null, :i_magazine_id, :i_color, :i_description, :i_image_url) ac
    into :v_articlecode_id;

  select article_id
    from articles a
    where a.articlecode_id = :v_articlecode_id
      and a.dimension = :i_dimension
    into :o_article_id;

  if (o_article_id is null) then
  begin
    insert into articles(articlecode_id, dimension, price_eur, weight)
      values(:v_articlecode_id, :i_dimension, :i_price_eur, :i_weight)
      returning article_id
      into :o_article_id;
  end
  suspend;
end^


CREATE OR ALTER PROCEDURE ARTICLECODE_GOC (
    I_ARTICLE_CODE TYPE OF CODE_ARTICLE,
    I_ARTICLE_SIGN TYPE OF SIGN_ARTICLE,
    I_MAGAZINE_ID TYPE OF ID_MAGAZINE,
    I_COLOR TYPE OF VALUE_SHORT,
    I_DESCRIPTION TYPE OF VALUE_SHORT,
    I_IMAGE_URL TYPE OF URL = null)
RETURNS (
    O_ARTICLECODE_ID TYPE OF ID_ARTICLE)
AS
declare variable V_ARTICLE_SIGN type of SIGN_ARTICLE;
begin
  select ac.articlecode_id
    from articlecodes ac
    where ac.article_code = :i_article_code
      and ac.magazine_id = :i_magazine_id
    into :o_articlecode_id;

  if (o_articlecode_id is null) then
    insert into articlecodes (article_code, article_sign, magazine_id, color, description, image_url)
      values(:i_article_code, :i_article_sign, :i_magazine_id, :i_color, :i_description, :i_image_url)
      returning articlecode_id, article_sign
      into :o_articlecode_id, :v_article_sign;

  if (:i_image_url is not null) then
    update articlecodes ac
      set ac.image_url = :i_image_url
      where ac.image_url is null
        and ac.article_sign = :v_article_sign;
  suspend;
end^


CREATE OR ALTER PROCEDURE ARTICLES_PUMP
AS
declare variable V_STATUS_ID type of ID_STATUS;
declare variable V_ORIGINAL_VALUE type of VALUE_SHORT;
declare variable V_RECODED_VALUE type of VALUE_SHORT;
begin
  for select r.original_value, r.recoded_value
        from recodes r
        where r.object_sign = 'ARTICLE'
          and r.attr_sign = 'DIMENSION'
        into :v_original_value, :v_recoded_value do
  begin
    update tmp_otto_article oa
      set oa.dimension = :v_recoded_value
      where oa.dimension = :v_original_value;
  end

  select s.status_id
    from statuses s
    where s.object_sign = 'ARTICLECODE'
      and s.status_sign = 'LOADED'
    into :v_status_id;

  merge into articlecodes ac
    using (select distinct magazine_id, article_code, description
      from tmp_otto_article) tmp
    on ac.magazine_id = tmp.magazine_id and ac.article_code = tmp.article_code
    when matched then
      update set ac.description = tmp.description,
                 ac.status_id = :v_status_id
    when not matched then
      insert (magazine_id, article_code, description, status_id)
      values (tmp.magazine_id, tmp.article_code, tmp.description, :v_status_id);

  select s.status_id
    from statuses s
    where s.object_sign = 'ARTICLE'
      and s.status_sign = 'LOADED'
    into :v_status_id;

  merge into articles a
    using (select ac.articlecode_id, t.dimension, t.price_eur, t.weight
      from tmp_otto_article t
        inner join articlecodes ac on (ac.article_code = t.article_code and ac.magazine_id = t.magazine_id)) tmp
    on a.articlecode_id = tmp.articlecode_id and a.dimension = tmp.dimension
    when matched then
      update set a.weight = tmp.weight,
             a.status_id = :v_status_id
    when not matched then
      insert (articlecode_id, dimension, price_eur, weight, status_id)
      values (tmp.articlecode_id, tmp.dimension, tmp.price_eur, tmp.weight, :v_status_id);
end^


CREATE OR ALTER PROCEDURE ARTICLESIGN_DETECT (
    I_ARTICLE_CODE TYPE OF CODE_ARTICLE NOT NULL,
    I_MAGAZINE_ID TYPE OF ID_MAGAZINE)
RETURNS (
    O_ARTICLE_SIGN TYPE OF SIGN_ARTICLE)
AS
declare variable V_ARTRICLE_SIGN type of SIGN_ARTICLE;
declare variable V_CATALOG_ID type of ID_CATALOG;
declare variable V_ARTICLE_SIGN_MASK type of MASK_ARTICLECODE;
begin
  if (i_magazine_id is null) then
    select catalog_id
      from catalogs c
      where upper(c.catalog_name) = 'INTERNET'
      into :v_catalog_id;
  else
    select catalog_id
      from magazines m
      where m.magazine_id = :i_magazine_id
      into :v_catalog_id;

  select am.article_sign_mask
    from articlemasks am
    where am.catalog_id = :v_catalog_id
      and :i_article_code similar to am.article_code_mask
    into :v_article_sign_mask;
  o_article_sign = recode(:i_article_code, :v_article_sign_mask);
  suspend;
end^


CREATE OR ALTER PROCEDURE ATTR_PUT (
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT NOT NULL,
    I_OBJECT_ID TYPE OF ID_OBJECT NOT NULL,
    I_ATTR_SIGN TYPE OF SIGN_ATTR NOT NULL,
    I_ATTR_VALUE TYPE OF VALUE_ATTR NOT NULL)
AS
declare variable V_ATTR_ID type of ID_ATTR;
declare variable V_FIELD_NAME type of NAME_PROCEDURE;
declare variable V_TABLE_NAME type of NAME_PROCEDURE;
declare variable V_IDFIELD_NAME type of NAME_PROCEDURE;
declare variable V_ATTR_TABLE_NAME type of NAME_PROCEDURE;
declare variable V_SQL type of SQL_STATEMENT;
declare variable V_DOMAIN type of NAME_PROCEDURE;
begin
  select a.attr_id, a.field_name, o.table_name, o.idfield_name, o.attr_table_name, rf.rdb$field_source
    from attrs a
      inner join objects o on (o.object_sign = a.object_sign)
      left join rdb$relation_fields rf on (rf.rdb$field_name = a.field_name and rf.rdb$relation_name = o.table_name)
    where a.object_sign = :i_object_sign
      and a.attr_sign = upper(:i_attr_sign)
    into :v_attr_id, :v_field_name, :v_table_name, :v_idfield_name, :v_attr_table_name, :v_domain;

  if (row_count = 0) then
    exit;

  if (v_field_name is not null) then
  begin
    v_sql =
      'update '||v_table_name||
      ' set '||v_field_name||' = :attr_value'||
      ' where '||v_idfield_name||' = cast(:object_id as '||v_domain||')';
    execute statement (:v_sql) (object_id := :i_object_id, attr_value := :i_attr_value);
  end
  else
  begin
    v_sql =
      'update or insert into '||v_attr_table_name||'(object_id, attr_id, attr_value)'||
      ' values(:object_id, :attr_id, :attr_value)'||
      ' matching(object_id, attr_id)';
    execute statement (:v_sql) (object_id := :i_object_id, attr_id := :v_attr_id, attr_value := :i_attr_value);
  end
end^


CREATE OR ALTER PROCEDURE COUNTER_NEXTVAL (
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT NOT NULL,
    I_COUNTER_SIGN TYPE OF SIGN_ATTR NOT NULL,
    I_OBJECT_ID TYPE OF ID_OBJECT NOT NULL)
RETURNS (
    O_NEXTVAL TYPE OF NAME_SHORT)
AS
declare variable V_PEFIX type of NAME_SHORT;
declare variable V_MAX_VALUE type of NAME_SHORT;
begin
  in autonomous transaction do
    update counters c
      set c.curr_value = c.curr_value + 1
      where c.object_sign = :i_object_sign
        and c.attr_sign = :i_counter_sign
        and c.object_id = :i_object_id
      returning c.curr_value, c.prefix_text, c.max_value
      into :o_nextval, :v_pefix, :v_max_value;
  if (v_pefix is not null) then
    o_nextval=:v_pefix||lpad(o_nextval, CHAR_LENGTH(:v_max_value), '0');
  suspend;
end^


CREATE OR ALTER PROCEDURE LOG_CREATE (
    I_ACTION_SIGN TYPE OF SIGN_ACTION NOT NULL,
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL,
    I_OWNER_ACTION TYPE OF ID_ACTION NOT NULL,
    I_ACTION_ID TYPE OF ID_ACTION NOT NULL,
    I_OBJECT_ID TYPE OF ID_OBJECT NOT NULL)
RETURNS (
    O_LOG_ID TYPE OF ID_LOG)
AS
declare variable V_PARAMS type of VALUE_BLOB;
begin
  o_log_id = gen_id(seq_log_id, 1);
  select cast(list(param_name||'="'||escapestring(param_value)||'"', ascii_char(13)||ascii_char(10)) as value_blob)
    from params
    where param_id = :i_param_id
    group by param_id
    into :v_params;
  in autonomous transaction do
    insert into logs(log_id, action_sign, owner_action, action_id, params_in, object_id)
      values(:o_log_id, :i_action_sign, :i_owner_action, :i_action_id, :v_params, :i_object_id);
  suspend;
end^


CREATE OR ALTER PROCEDURE LOG_UPDATE (
    I_LOG_ID TYPE OF ID_LOG NOT NULL,
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL,
    I_RESULT_CODE TYPE OF VALUE_INTEGER NOT NULL,
    I_OBJECT_ID TYPE OF ID_OBJECT NOT NULL)
AS
declare variable V_PARAMS type of VALUE_BLOB;
begin
  select cast(list(param_name||'="'||escapestring(param_value)||'"', ascii_char(13)||ascii_char(10)) as value_blob)
    from params
    where param_id = :i_param_id
    group by param_id
    into :v_params;

  in autonomous transaction do
    update logs l
      set l.params_out = :v_params,
          l.result_code = :i_result_code,
          l.object_id = :i_object_id
      where l.log_id = :i_log_id;
end^


CREATE OR ALTER PROCEDURE LOG_UPDATE_SKIPED (
    I_LOG_ID TYPE OF ID_LOG,
    I_PARAM_ID TYPE OF ID_PARAM,
    I_RESULT_CODE TYPE OF VALUE_INTEGER,
    I_OBJECT_ID TYPE OF ID_OBJECT)
AS
declare variable V_PARAMS type of VALUE_BLOB;
begin
  v_params = 'execution skipped';

  in autonomous transaction do
    update logs l
      set l.params_out = :v_params,
          l.result_code = :i_result_code,
          l.object_id = :i_object_id
      where l.log_id = :i_log_id;
end^


CREATE OR ALTER PROCEDURE MAGAZINE_DETECT (
    I_CATALOG_NAME TYPE OF NAME_REF NOT NULL)
RETURNS (
    O_MAGAZINE_ID TYPE OF ID_MAGAZINE,
    O_CATALOG_ID TYPE OF ID_CATALOG)
AS
declare variable V_CATALOG_ID type of ID_CATALOG;
begin
  select first 1 m.magazine_id, m.catalog_id
    from catalogs c
      inner join magazines m on (m.catalog_id = c.catalog_id)
    where c.catalog_name = :i_catalog_name
      and m.valid_date > current_date
    order by m.valid_date
    into :o_magazine_id, :o_catalog_id;
  suspend;
end^


CREATE OR ALTER PROCEDURE MESSAGE_BUSY (
    I_TEMPLATE_ID TYPE OF ID_TEMPLATE)
RETURNS (
    O_MESSAGE_ID INTEGER)
AS
begin
  in autonomous transaction do
    update messages m
      set m.busy_id = current_connection
      where m.message_id = (
        select first 1 ms.message_id
          from messages ms
            inner join v_statuses s on (s.status_id = ms.status_id)
            where s.flag_sign = 'NEW'
              and ms.template_id = :i_template_id
              and ms.busy_id is null)
      returning m.message_id
      into :o_message_id;
  suspend;
end^


CREATE OR ALTER PROCEDURE MESSAGE_BUSY_2 (
    I_MESSAGE_ID TYPE OF ID_MESSAGE)
AS
declare variable V_PARAM_ID type of ID_PARAM;
declare variable V_ACTION_ID type of ID_ACTION;
begin
  update messages m
    set m.busy_id = current_connection
    where m.message_id = :i_message_id;
end^


CREATE OR ALTER PROCEDURE MESSAGE_CREATE (
    I_FILE_NAME TYPE OF NAME_FILE,
    I_FILE_SIZE TYPE OF SIZE_FILE,
    I_FILE_DTM TYPE OF DTM_FILE)
RETURNS (
    O_MESSAGE_ID TYPE OF ID_MESSAGE)
AS
declare variable V_ACTION_ID type of ID_ACTION;
declare variable V_PARAM_ID type of ID_PARAM;
declare variable V_TEMPLATE_ID type of ID_TEMPLATE;
declare variable V_FILE_NAME type of NAME_FILE;
declare variable V_OBJECT_SIGN type of SIGN_OBJECT = 'MESSAGE';
begin
  if (not exists(select m.message_id
                   from messages m
                   where m.file_name = :i_file_name)) then
  begin
    select o_param_id from param_create(:v_object_sign) into :v_param_id;
    execute procedure param_set(:v_param_id, 'FILE_NAME', :i_file_name);
    execute procedure param_set(:v_param_id, 'FILE_SIZE', :i_file_size);
    execute procedure param_set(:v_param_id, 'FILE_DTM', :i_file_dtm);

    v_file_name = EscapeStringEx(:i_file_name, '-');

    select t.template_id
      from templates t
      where :v_file_name similar to t.filename_mask
      into :v_template_id;

    execute procedure param_set(:v_param_id, 'TEMPLATE_ID', :v_template_id);

    select o_action_id from action_run(:v_object_sign, 'MESSAGE_CREATE', :v_param_id, null)
      into :v_action_id;
    select a.object_id from actions a where a.action_id = :v_action_id
      into :o_message_id;
  end
  suspend;
end^


CREATE OR ALTER PROCEDURE MESSAGE_RELEASE (
    I_MESSAGE_ID TYPE OF ID_MESSAGE NOT NULL)
AS
begin
  in autonomous transaction do
    update messages m
      set m.busy_id = null
      where m.busy_id = current_connection
        and m.message_id = :i_message_id;
end^


CREATE OR ALTER PROCEDURE NOTIFY_CREATE (
    I_MESSAGE_ID TYPE OF ID_MESSAGE,
    I_NOTIFY_TEXT TYPE OF VALUE_ATTR,
    I_PARAMS TYPE OF VALUE_BLOB,
    I_STATE TYPE OF VALUE_CHAR)
RETURNS (
    O_NOTIFY_ID TYPE OF ID_NOTIFY)
AS
declare variable V_PARAM_ID type of ID_PARAM;
begin
  if (nullif(i_params, '') is not null) then
  begin
    select o_param_id from param_create('NOTIFY', :i_message_id) into :v_param_id;
    execute procedure param_unparse(:v_param_id, :i_params);
    select o_pattern from param_fillpattern(:v_param_id, :i_notify_text) into :i_notify_text;
  end


  insert into notifies(message_id, notify_text, notify_class)
    values(:i_message_id, :i_notify_text, upper(:i_state))
    returning notify_id
    into :o_notify_id;
  suspend;
end^


CREATE OR ALTER PROCEDURE OBJECT_GET (
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT NOT NULL,
    I_OBJECT_ID TYPE OF ID_OBJECT NOT NULL,
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL)
AS
declare variable V_PROCEDURE_NAME type of NAME_PROCEDURE;
declare variable V_PIVOT type of SQL_STATEMENT;
declare variable V_SQL type of SQL_STATEMENT;
begin
  execute procedure param_set(:i_param_id, 'ID', :i_object_id);
  select o_sql from pivot_record(:i_object_sign) into v_pivot;
  v_sql =
    'insert into params(param_id, param_name, param_value) '||
    'select cast(:i_param_id as id_param), pv.attr_sign, pv.attr_value '||
    ' from ('||:v_pivot||') pv '||
    ' left join params p on (p.param_name = pv.attr_sign and p.param_id = :i_param_id)'||
    ' where p.param_id is null';
  execute statement (:v_sql) (i_param_id := :i_param_id, id := :i_object_id);

  select o.procedure_read
    from objects o
    where o.object_sign = :i_object_sign
    into :v_procedure_name;
  if (v_procedure_name is not null) then
  begin
    v_sql =
      'insert into params(param_id, param_name, param_value) '||
      'select cast(:i_param_id as id_param), o_param_name, o_param_value '||
      ' from '||:v_procedure_name||' (:id) pv '||
      ' left join params p on (p.param_name = pv.o_param_name and p.param_id = :i_param_id)'||
      ' where p.param_id is null';
    execute statement (:v_sql) (id := :i_object_id, i_param_id := :i_param_id);
  end

end^


CREATE OR ALTER PROCEDURE OBJECT_PUT (
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL)
AS
declare variable V_TABLE_NAME type of NAME_PROCEDURE;
declare variable V_IDFIELD_NAME type of NAME_PROCEDURE;
declare variable V_ATTRTABLE_NAME type of NAME_PROCEDURE;
declare variable V_ATTR_VALUE type of VALUE_ATTR;
declare variable V_FIELD_NAME type of NAME_PROCEDURE;
declare variable V_SQL type of SQL_STATEMENT;
declare variable V_OBJECT_ID type of ID_OBJECT;
begin
  select ph.object_id, o.table_name, o.idfield_name, o.attr_table_name
    from paramheads ph
      inner join objects o on (o.object_sign = ph.object_sign)
    where ph.param_id = :i_param_id
    into :v_object_id, :v_table_name, :v_idfield_name, :v_attrtable_name;

  for select p.param_value, a.field_name
    from params p
      inner join paramheads ph on (ph.param_id = p.param_id)
      inner join attrs a on (a.attr_sign = p.param_name and a.object_sign = ph.object_sign and coalesce(a.direction,'W')='W')
    where p.param_id = :i_param_id
      and a.field_name is not null
    into :v_attr_value, :v_field_name
  do begin
    v_sql =
      'update '||v_table_name||
      ' set '||v_field_name||' = :v_attr_value'||
      ' where '||v_idfield_name||' = :object_id';
    execute statement (:v_sql) (object_id := :v_object_id, v_attr_value := :v_attr_value);
  end


--  if (exists(select *
--    from attrs a
--      inner join paramheads ph on (ph.object_sign = a.object_sign)
--      where ph.param_id = :i_param_id
--        and a.field_name is null)) then
  if (v_attrtable_name is not null) then
  begin
    v_sql =
      'merge into '||v_attrtable_name||' oa
       using (select object_id, attr_id, attr_value
        from v_attrinparam
        where param_id = :i_param_id) ap
      on (oa.object_id = ap.object_id and oa.attr_id = ap.attr_id)
      when matched then
        update set oa.attr_value = ap.attr_value
      when not matched then
        insert (object_id, attr_id, attr_value)
          values (ap.object_id, ap.attr_id, ap.attr_value)';
    execute statement (v_sql) (i_param_id := :i_param_id);
  end
end^


CREATE OR ALTER PROCEDURE OBJECT_READ (
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT,
    I_OBJECT_ID TYPE OF ID_OBJECT)
RETURNS (
    O_PARAM_NAME TYPE OF SIGN_OBJECT,
    O_PARAM_VALUE TYPE OF VALUE_ATTR)
AS
declare variable V_PIVOT type of SQL_STATEMENT;
declare variable V_SQL type of SQL_STATEMENT;
declare variable V_PROCEDURE_NAME type of NAME_PROCEDURE;
begin
  if (i_object_id is null) then
    exit;
  select o_sql from pivot_record(:i_object_sign) into v_pivot;
  v_sql =
    'select pv.attr_sign, pv.attr_value '||
    ' from ('||:v_pivot||') pv ';
  for execute statement (:v_sql) (id := :i_object_id)
    into :o_param_name, :o_param_value do
    suspend;

  select o.procedure_read
    from objects o
    where o.object_sign = :i_object_sign
    into :v_procedure_name;
  if (v_procedure_name is not null) then
  begin
    v_sql = 'select o_param_name, o_param_value '||
    ' from '||:v_procedure_name||' (:id)';
    for execute statement (:v_sql) (id := :i_object_id)
      into :o_param_name, :o_param_value do
      suspend;
  end

end^


CREATE OR ALTER PROCEDURE OBJECT_UPDATEABLE (
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL,
    I_NOW_STATUS_ID TYPE OF ID_STATUS NOT NULL,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT NOT NULL)
RETURNS (
    O_UPDATEABLE TYPE OF VALUE_BOOLEAN,
    O_NEW_STATUS_ID TYPE OF ID_STATUS)
AS
declare variable V_NEW_STATUS_SIGN type of SIGN_OBJECT = 0;
declare variable V_FLAG_SIGN type of SIGN_FLAG;
declare variable V_CHANGED type of BOOLEAN;
begin

  select o_value from param_get(:i_param_id, 'NEW.STATUS_SIGN') into :v_new_status_sign;
  select status_id
    from statuses s
    where s.object_sign = :i_object_sign
      and s.status_sign = :v_new_status_sign
    into :o_new_status_id;

  if (o_new_status_id is null) then
    select o_value from param_get(:i_param_id, 'NEW.STATUS_ID') into :o_new_status_id;

  if (o_new_status_id is null) then
    o_new_status_id = i_now_status_id;

  if (o_new_status_id = i_now_status_id) then
    select case count(*)
            when 0 then 1
            else 0
           end
      from flags2statuses f2s
      where f2s.status_id = :i_now_status_id
        and f2s.flag_sign = 'READONLY'
      into :o_updateable;
  else
    select case count(*)
             when 0 then 0
             else 1
           end
      from status_rules r
      where r.old_status_id = :i_now_status_id
        and r.new_status_id = :o_new_status_id
      into :o_updateable;

  if (o_updateable = 0) then
    select coalesce(o_value, 0) from param_get(:i_param_id, 'CHANGED') into :o_updateable;

  suspend;
end^


CREATE OR ALTER PROCEDURE ORDER_ANUL (
    I_ORDER_ID TYPE OF ID_ORDER)
RETURNS (
    O_NEW_STATUS_SIGN TYPE OF SIGN_OBJECT)
AS
declare variable V_ORDERITEMS_CNT type of VALUE_INTEGER;
declare variable V_ORDER_STATUS_ID type of ID_STATUS;
declare variable V_ORDER_STATUS_SIGN type of SIGN_OBJECT;
declare variable V_PARAM_ID type of ID_PARAM;
declare variable V_ACTION_ID type of ID_ACTION;
begin
  select count(*) from orderitems oi
    inner join flags2statuses f2s on (f2s.status_id = oi.status_id and f2s.flag_sign = 'CREDIT')
    where oi.order_id = :i_order_id
    into :v_orderitems_cnt;

  select s.status_id, s.status_sign
    from orders o
      inner join statuses s on (s.status_id = o.status_id)
    where o.order_id = :i_order_id
    into :v_order_status_id, :v_order_status_sign;

  if (:v_orderitems_cnt = 0 and :v_order_status_sign not in ('CANCELLED', 'ANULLED', 'REJECTED')) then
  begin
    select o_param_id from param_create('ORDER', :i_order_id) into :v_param_id;
    select o_action_id from action_run('ORDER', 'ORDER_CANCELLED', :v_param_id, :i_order_id) into :v_action_id;
  end

  select s.status_sign
    from orders o
      inner join statuses s on (s.status_id = o.status_id)
    where o.order_id = :i_order_id
    into :o_new_status_sign;
  suspend;
end^


CREATE OR ALTER PROCEDURE ORDER_READ (
    I_OBJECT_ID TYPE OF ID_OBJECT)
RETURNS (
    O_PARAM_NAME TYPE OF SIGN_OBJECT,
    O_PARAM_VALUE TYPE OF VALUE_ATTR)
AS
declare variable V_PRODUCT_NAME type of VALUE_ATTR;
declare variable V_CLIENT_FIO type of VALUE_ATTR;
declare variable V_ADRESS_TEXT type of VALUE_ATTR;
declare variable V_STATUS_SIGN type of SIGN_ATTR;
declare variable V_ACCOUNT_ID type of ID_ACCOUNT;
declare variable V_STATUS_FLAG_LIST type of LIST_SIGNS;
declare variable V_STATUS_NAME type of NAME_OBJECT;
begin
  select p.product_name, vc.client_fio, va.adress_text,
         s.status_sign, s.flag_sign_list, s.status_name
    from orders o
      left join products p on (p.product_id = o.product_id)
      left join v_clients_fio vc on (vc.client_id = o.client_id)
      left join v_adress_text va on (va.adress_id = o.adress_id)
      left join statuses s on (s.status_id = o.status_id)
    where o.order_id = :i_object_id
    into :v_product_name, :v_client_fio, :v_adress_text,
         :v_status_sign, :v_status_flag_list, :v_status_name;

  o_param_name = 'STATUS_SIGN';
  o_param_value = v_status_sign;
  suspend;
  o_param_name = 'STATUS_FLAG_LIST';
  o_param_value = v_status_flag_list;
  suspend;
  o_param_name = 'STATUS_NAME';
  o_param_value = v_status_name;
  suspend;


  if (:v_product_name is not null) then
  begin
    o_param_name = 'PRODUCT_NAME';
    o_param_value = :v_product_name;
    suspend;
  end

  if (v_client_fio is not null) then
  begin
    o_param_name = 'CLIENT_FIO';
    o_param_value = :v_client_fio;
    suspend;
  end

  if (:v_adress_text is not null) then
  begin
    o_param_name = 'ADRESS_TEXT';
    o_param_value = :v_adress_text;
    suspend;
  end

  select a.account_id
    from orders o
      inner join clients cl on (cl.client_id = o.client_id)
      inner join accounts a on (a.account_id = cl.account_id)
    where o.order_id = :i_object_id
    into :v_account_id;
  if (:v_account_id is not null) then
  begin
    o_param_name = 'ACCOUNT_ID';
    o_param_value = :v_account_id;
    suspend;
  end

end^


CREATE OR ALTER PROCEDURE ORDER_X_ACTIVEITEMSCOUNT (
    I_DEST_PARAM_ID TYPE OF ID_PARAM NOT NULL,
    I_PARAM_NAME TYPE OF SIGN_ATTR NOT NULL,
    I_SRC_PARAM_ID TYPE OF ID_PARAM)
AS
declare variable V_OBJECT_ID type of ID_OBJECT;
declare variable V_AMOUNT type of VALUE_INTEGER;
begin
  select o_value from param_get(:i_src_param_id, 'ID') into :v_object_id;

  select sum(oi.amount)
    from orderitems oi
    where oi.order_id = :v_object_id
    into :v_amount;

  execute procedure param_set(:i_dest_param_id, :i_param_name, :v_amount);
end^


CREATE OR ALTER PROCEDURE ORDER_X_UNINVOICED (
    I_DEST_PARAM_ID TYPE OF ID_PARAM,
    I_PARAM_NAME TYPE OF SIGN_ATTR,
    I_SRC_PARAM_ID TYPE OF ID_PARAM)
AS
declare variable V_OBJECT_ID type of ID_OBJECT;
declare variable V_ORDERITEMS_COST_EUR type of MONEY_EUR;
declare variable V_ORDERTAXS_COST_EUR type of MONEY_EUR;
declare variable V_ORDERMONEYS_COST_EUR type of MONEY_EUR;
begin
  select o_value from param_get(:i_src_param_id, 'ID') into :v_object_id;

  select sum(oi.cost_eur)
    from orderitems oi
    where oi.order_id = :v_object_id
    into :v_orderitems_cost_eur;

  select sum(ot.cost_eur)
    from ordertaxs ot
    where ot.order_id = :v_object_id
    into :v_ordertaxs_cost_eur;

  select sum(om.amount_eur)
    from ordermoneys om
    where om.order_id = :v_object_id
    into :v_ordermoneys_cost_eur;

  execute procedure param_set(:i_dest_param_id, :i_param_name,
    :v_orderitems_cost_eur+:v_ordertaxs_cost_eur-:v_ordermoneys_cost_eur);
end^


CREATE OR ALTER PROCEDURE ORDERHISTORY_UPDATE (
    I_ORDER_ID TYPE OF ID_ORDER,
    I_STATUS_ID TYPE OF ID_STATUS,
    I_STATE_ID TYPE OF ID_STATUS)
AS
declare variable V_STATUS_ID type of ID_STATUS;
declare variable V_STATE_ID type of ID_STATUS;
begin
  select coalesce(oh.status_id, 0), coalesce(oh.state_id, 0)
    from orderhistory oh
    where oh.order_id = :i_order_id
    order by oh.action_dtm desc
    into :v_status_id, :v_state_id;
  if ((:i_status_id <> :v_status_id) or (coalesce(:i_state_id, 0) <> :v_state_id)) then
  begin
    insert into orderhistory(order_id, status_id, state_id)
      values (:i_order_id, :i_status_id, :i_state_id);
  end
end^


CREATE OR ALTER PROCEDURE ORDERITEM_READ (
    I_OBJECT_ID TYPE OF ID_OBJECT)
RETURNS (
    O_PARAM_NAME TYPE OF SIGN_OBJECT,
    O_PARAM_VALUE TYPE OF VALUE_ATTR)
AS
declare variable V_ARTICLE_ID type of ID_ARTICLE;
declare variable V_WEIGHT type of VALUE_INTEGER;
declare variable V_STATUS_SIGN type of SIGN_OBJECT;
declare variable V_STATUS_FLAG_LIST type of LIST_SIGNS;
declare variable V_STATE_SIGN type of SIGN_OBJECT;
declare variable V_STATE_FLAG_LIST type of LIST_SIGNS;
declare variable V_STATUS_NAME type of NAME_OBJECT;
declare variable V_STATE_NAME type of NAME_OBJECT;
begin
  select s.status_sign, s.flag_sign_list, s.status_name,
         ss.status_sign, ss.flag_sign_list, ss.status_name
    from orderitems oi
      inner join statuses s on (s.status_id = oi.status_id)
      left join statuses ss on (ss.status_id = oi.state_id)
    where oi.orderitem_id = :i_object_id
    into :v_status_sign, :v_status_flag_list, :v_status_name,
         :v_state_sign, :v_state_flag_list, :v_state_name;

  o_param_name = 'STATUS_SIGN';
  o_param_value = v_status_sign;
  suspend;

  o_param_name = 'STATUS_FLAG_LIST';
  o_param_value = v_status_flag_list;
  suspend;

  o_param_name = 'STATUS_NAME';
  o_param_value = v_status_name;
  suspend;


  if (v_state_sign is not null) then
  begin
    o_param_name = 'STATE_SIGN';
    o_param_value = v_state_sign;
    suspend;

    o_param_name = 'STATE_FLAG_LIST';
    o_param_value = v_state_flag_list;
    suspend;

    o_param_name = 'STATE_NAME';
    o_param_value = v_state_name;
    suspend;
  end
end^


CREATE OR ALTER PROCEDURE ORDERITEM_X_GETSTATEID (
    I_DEST_PARAM_ID TYPE OF ID_PARAM,
    I_PARAM_NAME TYPE OF SIGN_ATTR,
    I_SRC_PARAM_ID TYPE OF ID_PARAM)
AS
declare variable V_UNPAID_INVOICE_COUNT type of VALUE_INTEGER;
declare variable V_STATE_ID type of ID_STATUS;
declare variable V_STATE_SIGN type of SIGN_OBJECT;
declare variable V_STORE_DATE type of VALUE_BOOLEAN;
begin
  select o_value from param_get(:i_src_param_id, 'NEW.STATE_SIGN') into :v_state_sign;

  select s.status_id, s.store_date
    from statuses s
    where s.status_sign = :v_state_sign
      and s.object_sign = 'ORDERITEM'
    into :v_state_id, :v_store_date;

  execute procedure param_set(:i_dest_param_id, :i_param_name, :v_state_id);
  if (:v_store_date = 1) then
  begin
    execute procedure param_set(:i_dest_param_id, 'DTM.'||:v_state_sign, current_timestamp);
  end
end^


CREATE OR ALTER PROCEDURE ORDERTAX_READ (
    I_OBJECT_ID TYPE OF ID_OBJECT)
RETURNS (
    O_PARAM_NAME TYPE OF SIGN_OBJECT,
    O_PARAM_VALUE TYPE OF VALUE_ATTR)
AS
declare variable V_TAXSERV_ID type of ID_TAX;
declare variable V_TAXSERV_NAME type of NAME_REF;
declare variable V_STATUS_SIGN type of SIGN_OBJECT;
declare variable V_STATUS_NAME type of NAME_OBJECT;
begin
  select ts.taxserv_id, ts.taxserv_name, s.status_sign, s.status_name
    from ordertaxs ot
      inner join taxrates tr on (tr.taxrate_id = ot.taxrate_id)
      inner join taxservs ts on (ts.taxserv_id = tr.taxserv_id)
      inner join statuses s on (s.status_id = ot.status_id)
    where ot.ordertax_id = :i_object_id
    into :v_taxserv_id, :v_taxserv_name, :v_status_sign, :v_status_name;

  o_param_name = 'TAXSERV_ID';
  o_param_value = :v_taxserv_id;
  suspend;
  o_param_name = 'TAXSERV_NAME';
  o_param_value = :v_taxserv_name;
  suspend;
  o_param_name = 'STATUS_SIGN';
  o_param_value = v_status_sign;
  suspend;
  o_param_name = 'STATUS_NAME';
  o_param_value = v_status_name;
  suspend;

end^


CREATE OR ALTER PROCEDURE PARAM_CALC_IN (
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT,
    I_DEST_PARAM_ID TYPE OF ID_PARAM,
    I_PARAM_NAME TYPE OF SIGN_OBJECT,
    I_PARAM_KIND TYPE OF KIND_PARAM,
    I_PARAM_VALUE TYPE OF VALUE_ATTR,
    I_SRC_PARAM_ID TYPE OF ID_PARAM)
AS
declare variable V_PARAM_VALUE type of VALUE_ATTR;
declare variable V_SQL type of SQL_STATEMENT;
declare variable V_TABLE_NAME type of NAME_PROCEDURE;
begin
  if (exists (select param_value from params
                where param_id = :i_dest_param_id
                  and param_name = :i_param_name)) then exit;

  if (:i_param_kind = 'I') then
    exception ex_mandatory_param_expected 'Mandatory parameter '||:i_param_name||' expected';
  else
  if (:i_param_kind = 'V') then
    execute procedure param_set(:i_dest_param_id, :i_param_name, :i_param_value);
  else
  if (:i_param_kind = 'A') then
  begin
    select param_value from params
      where param_name = :i_param_value
        and param_id = :i_src_param_id
      into :v_param_value;
    if (row_count = 1) then
      execute procedure param_set(:i_dest_param_id, :i_param_name, :v_param_value);
  end
  else
  if (:i_param_kind = 'X') then
  begin
    v_sql = 'execute procedure '||:i_object_sign||'_X_'||:i_param_value||' (:dest_param_id, :pattern, :src_param_id)';
    execute statement (:v_sql) (dest_param_id := :i_dest_param_id, pattern := :i_param_name, src_param_id := :i_src_param_id);
  end
  else
  if (:i_param_kind = 'B') then
  begin
    if (i_object_sign = 'ACCOUNT') then
      execute procedure account_x_search(:i_dest_param_id, :i_param_value, :i_src_param_id);
    else
    begin
      v_sql = 'execute procedure '||:i_object_sign||'_X_SEARCH (:dest_param_id, :pattern, :src_param_id)';
      execute statement (:v_sql) (dest_param_id := :i_dest_param_id, pattern := :i_param_value, src_param_id := :i_src_param_id);
    end
  end
  else
  if (:i_param_kind = 'F') then
  begin
    select o_pattern from param_fillpattern(:i_src_param_id, :i_param_value) into :v_sql;
    execute statement (:v_sql) into :v_param_value;
    execute procedure param_set (:i_dest_param_id, :i_param_name, :v_param_value);
  end
end^


CREATE OR ALTER PROCEDURE PARAM_CALC_OUT (
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT,
    I_SRC_PARAM_ID TYPE OF ID_PARAM,
    I_PARAM_NAME TYPE OF SIGN_OBJECT,
    I_PARAM_KIND TYPE OF KIND_PARAM,
    I_PARAM_VALUE TYPE OF VALUE_ATTR,
    I_DEST_PARAM_ID TYPE OF ID_PARAM)
AS
declare variable V_PARAM_VALUE type of VALUE_ATTR;
declare variable V_SQL type of SQL_STATEMENT;
declare variable V_ATTR_ID type of ID_ATTR;
begin
  if (:i_param_kind = 'O') then
  begin
    select param_value
      from params
      where param_id = :i_src_param_id
        and param_name = :i_param_name
      into :v_param_value;
    if (v_param_value is not null) then
      update or insert into params (param_id, param_name, param_value)
        values (:i_dest_param_id, :i_param_value, :v_param_value)
        matching (param_id, param_name);
  end
end^


CREATE OR ALTER PROCEDURE PARAM_CLONE (
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL,
    I_OBJECT_ID TYPE OF ID_OBJECT NOT NULL,
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT NOT NULL)
RETURNS (
    O_PARAM_ID TYPE OF ID_PARAM)
AS
begin
  o_param_id = gen_id(seq_param_id, 1);
  insert into paramheads(param_id, object_sign, object_id)
    select :o_param_id, :i_object_sign, :i_object_id
      from paramheads ph
      where ph.param_id = :i_param_id;

  insert into params(param_id, param_name, param_value)
    select :o_param_id, param_name, param_value
      from params
      where param_id = :i_param_id;

  update params
    set param_value = :o_param_id
    where param_id = :o_param_id
      and param_name = 'PARAM_ID';

  if (i_object_id is not null) then
    update params
      set param_value = :i_object_id
      where param_id = :o_param_id
        and param_name = 'ID';

  suspend;
end^


CREATE OR ALTER PROCEDURE PARAM_CREATE (
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT NOT NULL,
    I_OBJECT_ID TYPE OF ID_OBJECT = null,
    I_ACTION_ID TYPE OF ID_ACTION = null)
RETURNS (
    O_PARAM_ID TYPE OF ID_PARAM)
AS
begin
  o_param_id = gen_id(seq_param_id, 1);

  insert into paramheads(param_id, object_sign, object_id, action_id)
    values(:o_param_id, :i_object_sign, :i_object_id, :i_action_id);

  insert into params(param_id, param_name, param_value)
    values(:o_param_id, 'PARAM_ID', :o_param_id);

  if (i_object_id is not null) then
    insert into params(param_id, param_name, param_value)
      values(:o_param_id, 'ID', :i_object_id);

  if (i_action_id is not null) then
    insert into params(param_id, param_name, param_value)
      values(:o_param_id, 'ACTION_ID', :i_action_id);

  suspend;
end^


CREATE OR ALTER PROCEDURE PARAM_CRITERIA (
    I_PARAM_ID TYPE OF ID_PARAM,
    I_PARAM_NAME TYPE OF SIGN_OBJECT,
    I_PARAM_ACTION TYPE OF SIGN_ACTION,
    I_PARAM_DATATYPE TYPE OF KIND_PARAM,
    I_PARAM_VALUE_1 TYPE OF VALUE_ATTR,
    I_PARAM_VALUE_2 TYPE OF VALUE_ATTR)
RETURNS (
    O_VALID TYPE OF BOOLEAN)
AS
declare variable V_VALUE type of VALUE_ATTR;
begin
  if (not exists (select param_value
                    from params
                    where param_name = :i_param_name
                      and param_id = :i_param_id)) then
  begin
    o_valid = 0;
    if (:i_param_action = 'NOT EXISTS') then
      o_valid = 1;
  end
  else
  begin
    select param_value
      from params
      where param_name = :i_param_name
        and param_id = :i_param_id
      into :v_value;
    if (:i_param_datatype = 'N') then
    begin
      if ((:i_param_action = '=') and (cast(:v_value as numeric) = cast(:i_param_value_1 as numeric))) then
        o_valid = 1;
      else
      if ((:i_param_action = '<>') and (cast(:v_value as numeric) <> cast(:i_param_value_1 as numeric))) then
        o_valid = 1;
      else
      if ((:i_param_action = '>') and (cast(:v_value as numeric) > cast(:i_param_value_1 as numeric))) then
        o_valid = 1;
      else
      if ((:i_param_action = '<') and (cast(:v_value as numeric) < cast(:i_param_value_1 as numeric))) then
        o_valid = 1;
      else
      if ((:i_param_action = '>=') and (cast(:v_value as numeric) >= cast(:i_param_value_1 as numeric))) then
        o_valid = 1;
      else
      if ((:i_param_action = '<=') and (cast(:v_value as numeric) <= cast(:i_param_value_1 as numeric))) then
        o_valid = 1;
      else
      if ((:i_param_action = 'IS') and (:v_value is null)) then
        o_valid = 1;
      else
      if ((:i_param_action = 'IS NOT') and (:v_value is not null)) then
        o_valid = 1;
      else
      if ((:i_param_action = 'BETWEEN_[]') and (cast(:v_value as numeric) between cast(:i_param_value_1 as numeric) and cast(:i_param_value_2 as numeric))) then
        o_valid = 1;
    end
    else
    if (:i_param_datatype = 'S') then
    begin
      if ((:i_param_action = '=') and (cast(:v_value as value_attr) = cast(:i_param_value_1 as value_attr))) then
        o_valid = 1;
      else
      if ((:i_param_action = '<>') and (cast(:v_value as value_attr) <> cast(:i_param_value_1 as value_attr))) then
        o_valid = 1;
      else
      if ((:i_param_action = 'IS') and (:v_value is null)) then
        o_valid = 1;
      else
      if ((:i_param_action = 'IS NOT') and (:v_value is not null)) then
        o_valid = 1;
    end
  end
  suspend;
end^


CREATE OR ALTER PROCEDURE PARAM_DEL (
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL,
    I_PARAM_NAME TYPE OF SIGN_OBJECT)
AS
begin
  if (:i_param_name is null) then
    delete from params
      where param_id = :i_param_id
        and param_name <> 'PARAM_ID';
  else
    delete from params
      where param_id = :i_param_id
        and param_name = :i_param_name;
end^


CREATE OR ALTER PROCEDURE PARAM_FILLPATTERN (
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL,
    I_PATTERN TYPE OF VALUE_ATTR)
RETURNS (
    O_PATTERN TYPE OF VALUE_ATTR)
AS
declare variable V_PARAM_NAME type of SIGN_ATTR;
declare variable V_PARAM_VALUE type of VALUE_ATTR;
begin
  o_pattern = i_pattern;
  for select p.param_name, coalesce(p.param_value, '')
        from params p
        where p.param_id = :i_param_id
        into :v_param_name, :v_param_value do
      o_pattern = replace(o_pattern, '['||:v_param_name||']', :v_param_value);
  suspend;
end^


CREATE OR ALTER PROCEDURE PARAM_GET (
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL,
    I_PARAM_NAME TYPE OF SIGN_OBJECT NOT NULL)
RETURNS (
    O_VALUE TYPE OF VALUE_ATTR)
AS
begin
  select param_value
    from params
    where param_id = :i_param_id
      and param_name = upper(:i_param_name)
    into :o_value;
  suspend;
end^


CREATE OR ALTER PROCEDURE PARAM_PARSE (
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL)
RETURNS (
    O_PARAMS TYPE OF VALUE_BLOB)
AS
begin
  select list(p.param_name||'='||escapestring(p.param_value), ascii_char(13)||ascii_char(10))
    from params p
    where p.param_id = :i_param_id
    group by p.param_id
    into o_params;
  suspend;
end^


CREATE OR ALTER PROCEDURE PARAM_PARSE_4ACTION (
    I_ACTION_ID TYPE OF ID_PARAM)
RETURNS (
    O_PARAMS TYPE OF VALUE_BLOB)
AS
begin
  select list(p.param_name||'='||escapestring(p.param_value), ascii_char(13)||ascii_char(10))
    from params p
      inner join paramheads ph on (ph.param_id = p.param_id)
    where ph.action_id = :i_action_id
    group by p.param_id
    into o_params;
  suspend;
end^


CREATE OR ALTER PROCEDURE PARAM_SET (
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL,
    I_PARAM_NAME TYPE OF SIGN_OBJECT NOT NULL,
    I_PARAM_VALUE TYPE OF VALUE_ATTR)
AS
begin
  update or insert into params (param_id, param_name, param_value)
    values(:i_param_id, upper(:i_param_name), cast(:i_param_value as value_attr))
    matching (param_id, param_name);
end^


CREATE OR ALTER PROCEDURE PARAM_UNPARSE (
    I_PARAM_ID TYPE OF ID_PARAM,
    I_PARAMS TYPE OF VALUE_BLOB)
AS
declare variable V_LINE type of VALUE_ATTR;
declare variable V_PARAM_SIGN type of SIGN_OBJECT;
declare variable V_PARAM_VALUE type of VALUE_ATTR;
begin
  for select o_line from splitblob(:i_params, ascii_char(13)||ascii_char(10))
    where o_line <> ''
    into :v_line
  do begin
    select trim(o_head), trim(o_tile) from splitstring(:v_line, '=')
      into :v_param_sign, :v_param_value;
    if (v_param_value like '"%"') then
      v_param_value = substring(v_param_value from 2 for strlen(v_param_value)-2);

    update or insert into params(param_id, param_name, param_value)
      values(:i_param_id, :v_param_sign, unescapestring(:v_param_value))
      matching (param_id, param_name);
  end
end^


CREATE OR ALTER PROCEDURE PIVOT_RECORD (
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT NOT NULL)
RETURNS (
    O_SQL TYPE OF SQL_STATEMENT)
AS
declare variable V_ATTR_SIGN type of SIGN_OBJECT;
declare variable V_TABLE_NAME type of NAME_PROCEDURE;
declare variable V_FIELD_NAME type of NAME_PROCEDURE;
declare variable V_IDFIELD_NAME type of NAME_PROCEDURE;
declare variable V_ATTR_TABLE_NAME type of NAME_PROCEDURE;
begin
  select o.table_name, o.idfield_name, o.attr_table_name
    from objects o
    where o.object_sign = :i_object_sign
    into :v_table_name, :v_idfield_name, :v_attr_table_name;

  o_sql = 'select ''ID'' As Attr_sign, '||:v_idfield_name||' as Attr_value '||ascii_char(13)||ascii_char(10)||
      ' from '||v_table_name||' where '||v_idfield_name||' = :id'||ascii_char(13)||ascii_char(10);
  for select a.attr_sign, a.field_name
    from attrs a
    where a.field_name is not null
      and a.object_sign = :i_object_sign
      and coalesce(a.direction, 'R') = 'R'
    into :v_attr_sign, :v_field_name
  do begin
    o_sql = o_sql||'union'||ascii_char(13)||ascii_char(10)||
      'select '''||:v_attr_sign||''', cast('||:v_field_name||' as varchar(4000))'||ascii_char(13)||ascii_char(10)||
      ' from '||v_table_name||
      ' where '||v_idfield_name||' = :id '||
      ' and '||v_field_name||' is not null'||ascii_char(13)||ascii_char(10);
  end
  o_sql = o_sql||'union'||ascii_char(13)||ascii_char(10)||
    'select ''STATUS_SIGN'', statuses.status_sign'||ascii_char(13)||ascii_char(10)||
    ' from  '||v_table_name||' tbl '||
    '   inner join statuses on (statuses.status_id = tbl.status_id)'||
    ' where '||v_idfield_name||' = :id '||ascii_char(13)||ascii_char(10);

  if (v_attr_table_name is not null) then
    o_sql = o_sql||'union'||ascii_char(13)||ascii_char(10)||
      'select a.attr_sign, av.attr_value '||ascii_char(13)||ascii_char(10)||
      ' from '||v_attr_table_name||' av '||ascii_char(13)||ascii_char(10)||
      ' inner join attrs a on (a.attr_id = av.attr_id and coalesce(a.direction, ''R'') = ''R'')'||ascii_char(13)||ascii_char(10)||
      ' where object_id = :id';
  suspend;
end^


CREATE OR ALTER PROCEDURE PLACE_DETECT (
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL)
RETURNS (
    O_PLACE_ID TYPE OF ID_PLACE,
    O_AREA_ID TYPE OF ID_PLACE,
    O_REGION_ID TYPE OF ID_PLACE)
AS
declare variable V_PLACE_NAME type of NAME_REF;
declare variable V_VALUE type of NAME_REF;
declare variable V_PLACETYPE_CODE type of CODE_PLACETYPE;
begin
  -- ischem placetype
  select o_value from param_get(:i_param_id, 'PLACETYPE_SIGN') into :v_value;
  if (v_value is null) then
    v_placetype_code = 4;
  else
  begin
    select pt.placetype_code from placetypes pt
      where pt.adrtype_short = :v_value
      into :v_placetype_code;
    if (:v_placetype_code is null) then
      exception ex_unknown_placetype '=хшчтхёЄэvщ Єшя эрёхыхээюую яєэъЄр "'||v_value||'"';
  end

  -- ischem gorod
  select o_value from param_get(:i_param_id, 'PLACE_NAME') into :v_place_name;
  if (v_placetype_code = 4) then
  begin
    select p.place_id, nullif(p.owner_place, 0)
      from places p
      where lower(p.place_name) = lower(:v_place_name)
        and p.placetype_code = 4
      into :o_place_id, :o_region_id;
  end
  else
  -- ischem prochie naselennye punkty
  begin
    -- ischem raion
    select o_value from param_get(:i_param_id, 'AREA_NAME') into :v_value;
    if (v_value is null) then
      exception ex_areaname_expected '+ЄёєЄёЄтєхЄ эрчтрэшх Ёрщюэр';
    select p.place_id, p.owner_place
      from places p
      where lower(place_name) = lower(:v_value)
        and p.placetype_code = 3
      into :o_area_id, :o_region_id;

    select p.place_id
      from places p
      where lower(p.place_name) = lower(:v_place_name)
        and p.owner_place = :o_area_id
        and p.placetype_code > 4
      into :o_place_id;
  end

  suspend;
end^


CREATE OR ALTER PROCEDURE PLACE_READ (
    I_OBJECT_ID TYPE OF ID_OBJECT)
RETURNS (
    O_PARAM_NAME TYPE OF SIGN_OBJECT,
    O_PARAM_VALUE TYPE OF VALUE_ATTR)
AS
declare variable V_REGION_NAME type of NAME_OBJECT;
declare variable V_AREA_NAME type of NAME_OBJECT;
declare variable V_PLACETYPE_SIGN type of NAME_SHORT;
begin
  select p.area_name, p.region_name, p.placetype_sign
    from v_places p
    where p.place_id = :i_object_id
    into :v_area_name, :v_region_name, :v_placetype_sign;

  if (:v_area_name is not null) then
  begin
    o_param_name = 'AREA_NAME';
    o_param_value = :v_area_name;
    suspend;
  end

  if (:v_region_name is not null) then
  begin
    o_param_name = 'REGION_NAME';
    o_param_value = :v_region_name;
    suspend;
  end

  o_param_name = 'PLACETYPE_SIGN';
  o_param_value = :v_placetype_sign;
  suspend;

end^


CREATE OR ALTER PROCEDURE PLUGIN_VALUE (
    I_PLUGIN_SIGN TYPE OF SIGN_PLUGIN NOT NULL,
    I_PARAM_SIGN TYPE OF SIGN_ATTR NOT NULL)
RETURNS (
    O_VALUE TYPE OF VALUE_ATTR)
AS
begin
  select param_value
    from plugin_params pp
      inner join plugins p on (p.plugin_id = pp.plugin_id)
    where p.plugin_sign = upper(:i_plugin_sign)
      and pp.param_sign = :i_param_sign
    into :o_value;
  suspend;
end^


CREATE OR ALTER PROCEDURE SEARCH (
    I_VALUE TYPE OF NAME_REF,
    I_FROM_CLAUSE TYPE OF SQL_STATEMENT,
    I_FIELDNAME_ID TYPE OF NAME_PROCEDURE,
    I_FIELDNAME_NAME TYPE OF NAME_PROCEDURE,
    I_WHERE_CLAUSE TYPE OF SQL_STATEMENT,
    I_THRESHOLD TYPE OF VALUE_SMALLINT = 80)
RETURNS (
    O_OBJECT_ID TYPE OF ID_OBJECT,
    O_OBJECT_NAME TYPE OF NAME_REF,
    O_VALID TYPE OF VALUE_SMALLINT)
AS
declare variable V_SQL type of SQL_STATEMENT;
declare variable V_MASK type of MASK_NGRAMM;
declare variable V_SEARCH_ID type of ID_SEARCH;
declare variable V_STRLEN type of VALUE_SMALLINT;
begin
  if (:i_value is null) then exit;
  -- try find fitness
  v_sql = 'select '||:i_fieldname_id||', '||:i_fieldname_name||', 100'||
          ' from '||:i_from_clause||
          ' where (lower('||:i_fieldname_name||') = lower(:i_value)'||
          ' or cast('||:i_fieldname_id||' as varchar(100)) = :i_value)'||
          ' and '||coalesce(:i_where_clause, '1=1');

  for execute statement (:v_sql) (i_value := :i_value)
    into :o_object_id, :o_object_name, :o_valid do
      suspend;
  if (o_object_id is null) then
  begin
    -- fuzzy search by NGramm
    v_search_id = gen_id(seq_search_id, 1);
    v_strlen = char_length(:i_value);

    for select o_mask from search_get_ngramm(:i_value) into :v_mask
    do begin
      v_sql = 'insert into searches(search_id, object_id, object_name) '||
              'select :v_search_id, '||:i_fieldname_id||', '||:i_fieldname_name||
              ' from '||:i_from_clause||
              ' where lower('||:i_fieldname_name||') like :v_mask '||
              ' and '||coalesce(:i_where_clause, '1=1');
      execute statement (:v_sql) (v_search_id := :v_search_id, v_mask := :v_mask);
    end

    for select object_id id, max(object_name) name, count(object_id)*100/:v_strlen valid
      from searches s
      where search_id = :v_search_id
      group by object_id
      having count(object_id)*100/:v_strlen > :i_threshold
      order by valid desc
      into :o_object_id, :o_object_name, :o_valid
    do begin
      suspend;
    end

    delete from searches where search_id = :v_search_id;
  end
end^


CREATE OR ALTER PROCEDURE SEARCH_GET_NGRAMM (
    I_VALUE TYPE OF NAME_REF NOT NULL,
    I_NGRAMM_LEN TYPE OF VALUE_INTEGER = 3)
RETURNS (
    O_MASK TYPE OF MASK_NGRAMM)
AS
declare variable V_STRLEN type of VALUE_INTEGER;
declare variable V_POS type of VALUE_INTEGER;
declare variable V_MASKLEN type of VALUE_INTEGER;
begin
  i_value = lower(:i_value);
  v_strlen = char_length(:i_value);
  if (v_strlen <= :i_ngramm_len) then
  begin
    o_mask = '%'||:i_value||'%';
    suspend;
  end
  else
  begin
    v_pos = 1;
    while (v_pos <= v_strlen) do
    begin
      o_mask = substring(:i_value from :v_pos for :i_ngramm_len);
      v_masklen = char_length(o_mask);
      if (v_masklen = i_ngramm_len) then
        o_mask = '%'||o_mask||'%';
      else
        o_mask = substring(:i_value from 1 for i_ngramm_len - v_masklen)||'%'||o_mask;
      suspend;
      v_pos = v_pos + 1;
    end
  end
end^


CREATE OR ALTER PROCEDURE SETTING_GET (
    I_SETTING_SIGN TYPE OF SIGN_ATTR,
    I_ON_DATE TYPE OF DTM_VALID = current_timestamp)
RETURNS (
    O_VALUE TYPE OF VALUE_ATTR)
AS
begin
  select first 1 s.setting_value
    from settings s
    where s.setting_sign = :i_setting_sign
      and s.valid_dtm > :i_on_date
    order by s.valid_dtm
    into :o_value;
  suspend;
end^


CREATE OR ALTER PROCEDURE SETTING_SET (
    I_SETTING_SIGN TYPE OF SIGN_ATTR NOT NULL,
    I_VALUE TYPE OF VALUE_ATTR)
RETURNS (
    O_SETTING_ID TYPE OF ID_SETTING)
AS
declare variable V_VALID_DTM type of DTM_VALID;
begin
  v_valid_dtm = current_timestamp;
  update settings s
    set s.valid_dtm = addsecond(:v_valid_dtm, -1)
    where s.setting_sign = :i_setting_sign
      and s.valid_dtm = '9999.12.31';
  insert into settings (setting_sign, setting_value)
    values(:i_setting_sign, :i_value)
    returning setting_id
    into :o_setting_id;
  suspend;
end^


CREATE OR ALTER PROCEDURE SPLITBLOB (
    I_BLOB TYPE OF VALUE_BLOB,
    I_DEVIDER TYPE OF DEVIDER)
RETURNS (
    O_LINE TYPE OF VALUE_ATTR)
AS
declare variable V_POS type of VALUE_INTEGER;
declare variable V_STR type of VALUE_ATTR;
begin
  v_pos = 1;
  v_str = substring(:i_blob from v_pos for 4000);
  while (char_length(v_str) > 0) do
  begin
    select o_head from splitstring(:v_str, :i_devider) into :o_line;
    v_pos = v_pos + char_length(:o_line) + 2;
    suspend;
    v_str = substring(:i_blob from v_pos for 4000);
  end
end^


CREATE OR ALTER PROCEDURE SPLITSTRING (
    I_STRING TYPE OF VALUE_ATTR,
    I_DEVIDER TYPE OF DEVIDER)
RETURNS (
    O_HEAD TYPE OF VALUE_ATTR,
    O_TILE TYPE OF VALUE_ATTR)
AS
begin
  o_head = nullif(copyfront_withkey(:i_string, :i_devider), '');
  if (o_head is null) then
    o_head = i_string;
  else
  begin
    o_tile = nullif(substring(:i_string from strlen(o_Head)+1), '');
    o_head = nullif(copyfront_withoutkey(:o_Head, :i_devider), '');
  end
  suspend;
end^


CREATE OR ALTER PROCEDURE STATUS_CHECK_CONVERSION (
    I_NOW_STATUS_ID TYPE OF ID_STATUS NOT NULL,
    I_NEW_STATUS_ID TYPE OF ID_STATUS NOT NULL)
RETURNS (
    O_NEW_STATUS_ID TYPE OF ID_STATUS)
AS
declare variable V_CNT type of VALUE_INTEGER;
begin
  if (i_now_status_id <> i_new_status_id) then
    select r.new_status_id
      from status_rules r
      where r.old_status_id = :i_now_status_id
        and r.new_status_id = :i_new_status_id
      into :o_new_status_id;
  else
    o_new_status_id = i_new_status_id;
  suspend;
end^


CREATE OR ALTER PROCEDURE STATUS_CONVERSION_BY_FLAG (
    I_NOW_STATUS_ID TYPE OF ID_STATUS,
    I_NEW_FLAG_SIGN TYPE OF SIGN_FLAG,
    I_PARAM_ID TYPE OF ID_PARAM)
RETURNS (
    O_NEW_STATUS_ID TYPE OF ID_STATUS)
AS
begin
  select r.new_status_id
    from status_rules r
      inner join flags2statuses f2s on (f2s.status_id = r.new_status_id)
      inner join statuses s on (s.status_id = r.old_status_id)
    where r.old_status_id = :i_now_status_id
      and f2s.flag_sign = :i_new_flag_sign
    into :o_new_status_id;

  if (row_count = 0) then
    exception ex_status_conversion_unavail;

  suspend;

  when sqlcode -811 do
    exception ex_to_many_conversion_rules '2 or more new_status_id detected on conversion from STATUS_ID='||:i_now_status_id
      ||' by FLAG_SIGN='||:i_new_flag_sign;
  when any do
    exception;
end^


CREATE OR ALTER PROCEDURE STATUS_GET_CONVERSION (
    I_NOW_STATUS_ID TYPE OF ID_STATUS NOT NULL,
    I_NEW_FLAG_SIGN TYPE OF SIGN_FLAG NOT NULL,
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL)
RETURNS (
    O_NEW_STATUS_ID TYPE OF ID_STATUS)
AS
begin
  select r.new_status_id
    from status_rules r
      inner join flags2statuses f2s on (f2s.status_id = r.new_status_id)
      inner join statuses s on (s.status_id = r.old_status_id)
    where r.old_status_id = :i_now_status_id
      and f2s.flag_sign = :i_new_flag_sign
    into :o_new_status_id;

  if (row_count = 0) then
    exception ex_status_conversion_unavail;

  suspend;

  when sqlcode -811 do
    exception ex_to_many_conversion_rules '2 or more new_status_id detected on conversion from STATUS_ID='||:i_now_status_id
      ||' by FLAG_SIGN='||:i_new_flag_sign;
  when any do
    exception;
end^


CREATE OR ALTER PROCEDURE STATUS_GET_DEFAULT (
    I_OBJECT_SIGN TYPE OF SIGN_OBJECT NOT NULL)
RETURNS (
    O_STATUS_ID TYPE OF ID_STATUS)
AS
begin
  select s.status_id
    from statuses s
    where s.object_sign = :i_object_sign
      and s.is_default = 1
    into :o_status_id;
  suspend;
end^


CREATE OR ALTER PROCEDURE STATUS_STORE_DATE (
    I_OBJECT_ID TYPE OF ID_OBJECT,
    I_STATUS_ID TYPE OF ID_STATUS)
AS
declare variable V_OBJECT_SIGN type of SIGN_OBJECT;
declare variable V_STATUS_SIGN type of SIGN_ATTR;
declare variable V_STORE_DATE type of BOOLEAN;
begin
  select s.object_sign, s.status_sign, s.store_date
    from statuses s
    where s.status_id = :i_status_id
    into :v_object_sign, :v_status_sign, :v_store_date;
  if (v_store_date = 1) then
  begin
    execute procedure attr_put(:v_object_sign, :i_object_id, 'DTM.'||:v_status_sign, current_timestamp);
  end
end^


CREATE OR ALTER PROCEDURE TAX_FIXED_SUM (
    I_TAXRATE_ID TYPE OF ID_TAX NOT NULL,
    I_PARAM_ID TYPE OF ID_PARAM)
RETURNS (
    O_COST_EUR TYPE OF MONEY_EUR)
AS
declare variable V_PRICE_EUR type of MONEY_EUR;
begin
  select ta.attr_value
    from taxrate_attrs ta
      inner join attrs a on (a.attr_id = ta.attr_id)
    where ta.object_id = :i_taxrate_id
      and a.attr_sign = 'VALUE'
    into :v_price_eur;
  execute procedure param_set(:i_param_id, 'PRICE_EUR', :v_price_eur);
  execute procedure param_set(:i_param_id, 'AMOUNT', 1);
  o_cost_eur = v_price_eur;
  suspend;
end^


CREATE OR ALTER PROCEDURE TAX_USE_REST (
    I_TAXRATE_ID TYPE OF ID_TAX,
    I_PARAM_ID TYPE OF ID_PARAM)
RETURNS (
    O_COST_EUR TYPE OF MONEY_EUR)
AS
declare variable V_AMOUNT type of VALUE_INTEGER;
declare variable V_ORDER_ID type of ID_ORDER;
declare variable V_PRICE_AMOUNT type of VALUE_INTEGER;
declare variable V_PRICE_EUR type of MONEY_EUR;
declare variable V_TAX_AMOUNT type of VALUE_INTEGER;
declare variable V_FREE_AMOUNT type of VALUE_INTEGER;
begin
  select o_value from param_get(:i_param_id, 'ORDER_ID') into :v_order_id;

  select a.rest_eur
    from accounts a
      inner join clients c on (c.account_id = a.account_id)
      inner join orders o on (o.client_id = c.client_id)
    where o.order_id = :v_order_id
    into :o_cost_eur;
--  if (o_cost_eur) then

  execute procedure param_set(:i_param_id, 'PRICE_EUR', :v_price_eur);
  execute procedure param_set(:i_param_id, 'AMOUNT', :v_tax_amount);
  o_cost_eur = :v_price_eur*:v_tax_amount;
  suspend;
end^


CREATE OR ALTER PROCEDURE TAX_WEIGHT (
    I_TAXRATE_ID TYPE OF ID_TAX,
    I_PARAM_ID TYPE OF ID_PARAM)
RETURNS (
    O_COST_EUR TYPE OF MONEY_EUR)
AS
declare variable V_AMOUNT type of VALUE_INTEGER;
declare variable V_ORDER_ID type of ID_ORDER;
declare variable V_PRICE_AMOUNT type of VALUE_INTEGER;
declare variable V_PRICE_EUR type of MONEY_EUR;
declare variable V_TAX_AMOUNT type of VALUE_INTEGER;
declare variable V_FREE_AMOUNT type of VALUE_INTEGER;
begin
  select o_value from param_get(:i_param_id, 'ORDER_ID') into :v_order_id;

  select sum(coalesce(a.weight, 1))
    from orderitems oi
      left join articles a on (a.article_id = oi.article_id)
    where oi.order_id = :v_order_id
    into :v_amount;

  select ta.attr_value
    from v_taxrate_attrs ta
    where ta.object_id = :i_taxrate_id
      and ta.attr_sign = 'PRICE'
    into :v_price_eur;

  select ta.attr_value
    from v_taxrate_attrs ta
    where ta.object_id = :i_taxrate_id
      and ta.attr_sign = 'PRICE_AMOUNT'
    into :v_price_amount;

  select ta.attr_value
    from v_taxrate_attrs ta
    where ta.object_id = :i_taxrate_id
      and ta.attr_sign = 'FREE_AMOUNT'
    into :v_free_amount;

  if (v_amount - v_free_amount > 0) then
  begin
    v_tax_amount = (v_amount-v_free_amount)/ v_price_amount;
    if (v_tax_amount * v_price_amount < v_amount) then
     v_tax_amount = v_tax_amount + 1;
  end
  else
    v_tax_amount = 0;

  execute procedure param_set(:i_param_id, 'PRICE_EUR', :v_price_eur);
  execute procedure param_set(:i_param_id, 'AMOUNT', :v_tax_amount);
  o_cost_eur = :v_price_eur*:v_tax_amount;
  suspend;
end^


CREATE OR ALTER PROCEDURE TAXRATE_CALC (
    I_PARAM_ID TYPE OF ID_PARAM NOT NULL)
RETURNS (
    O_TAXRATE_ID TYPE OF ID_TAX,
    O_VALUE_EUR TYPE OF MONEY_EUR)
AS
declare variable V_TAXPLAN_ID type of ID_TAX;
declare variable V_TAXSERV_ID type of ID_TAXSERV;
declare variable V_TAX_PROCEDURE type of NAME_PROCEDURE;
declare variable V_SQL type of SQL_STATEMENT;
begin
  select o_value from param_get(:i_param_id, 'TAXPLAN_ID') into :v_taxplan_id;
  select o_value from param_get(:i_param_id, 'TAXSERV_ID') into :v_taxserv_id;

  select tr.taxrate_id, tr.tax_procedure
    from taxrates tr
    where tr.taxplan_id = :v_taxplan_id
      and tr.taxserv_id = :v_taxserv_id
    into :o_taxrate_id, :v_tax_procedure;

  v_sql = 'select o_value_eur from '||v_tax_procedure||'(:taxrate_id, :param_id)';
  execute statement (:v_sql) (taxrate_id := :o_taxrate_id, param_id := :i_param_id)
    into :o_value_eur;
  suspend;
end^



SET TERM ; ^


/******************************************************************************/
/***                                 Roles                                  ***/
/******************************************************************************/

CREATE ROLE USERS;
